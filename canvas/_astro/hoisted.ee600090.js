(function(s, t, e, i, r, n) {
    s.hj = s.hj || function() {
        (s.hj.q = s.hj.q || []).push(arguments)
    }
    ,
    s._hjSettings = {
        hjid: 3733692,
        hjsv: 6
    },
    r = t.getElementsByTagName("head")[0],
    n = t.createElement("script"),
    n.async = 1,
    n.src = e + s._hjSettings.hjid + i + s._hjSettings.hjsv,
    r.appendChild(n)
}
)(window, document, "https://static.hotjar.com/c/hotjar-", ".js?sv=");
function bg(s, t) {
    for (var e = 0; e < t.length; e++) {
        var i = t[e];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(s, i.key, i)
    }
}
function Fp(s, t, e) {
    return t && bg(s.prototype, t),
    e && bg(s, e),
    s
}
function bn() {
    return (bn = Object.assign || function(s) {
        for (var t = 1; t < arguments.length; t++) {
            var e = arguments[t];
            for (var i in e)
                Object.prototype.hasOwnProperty.call(e, i) && (s[i] = e[i])
        }
        return s
    }
    ).apply(this, arguments)
}
function pc(s, t) {
    s.prototype = Object.create(t.prototype),
    s.prototype.constructor = s,
    s.__proto__ = t
}
function _y(s) {
    return (_y = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
    }
    )(s)
}
function Bp(s, t) {
    return (Bp = Object.setPrototypeOf || function(e, i) {
        return e.__proto__ = i,
        e
    }
    )(s, t)
}
function yy(s, t, e) {
    return (yy = function() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
            return !1;
        if (typeof Proxy == "function")
            return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
            !0
        } catch {
            return !1
        }
    }() ? Reflect.construct : function(i, r, n) {
        var o = [null];
        o.push.apply(o, r);
        var a = new (Function.bind.apply(i, o));
        return n && Bp(a, n.prototype),
        a
    }
    ).apply(null, arguments)
}
function vy(s) {
    var t = typeof Map == "function" ? new Map : void 0;
    return (vy = function(e) {
        if (e === null || Function.toString.call(e).indexOf("[native code]") === -1)
            return e;
        if (typeof e != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (t !== void 0) {
            if (t.has(e))
                return t.get(e);
            t.set(e, i)
        }
        function i() {
            return yy(e, arguments, _y(this).constructor)
        }
        return i.prototype = Object.create(e.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Bp(i, e)
    }
    )(s)
}
function lo(s, t) {
    try {
        var e = s()
    } catch (i) {
        return t(i)
    }
    return e && e.then ? e.then(void 0, t) : e
}
typeof Symbol < "u" && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))),
typeof Symbol < "u" && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
var Fs, cw = "2.9.7", dw = function() {};
(function(s) {
    s[s.off = 0] = "off",
    s[s.error = 1] = "error",
    s[s.warning = 2] = "warning",
    s[s.info = 3] = "info",
    s[s.debug = 4] = "debug"
}
)(Fs || (Fs = {}));
var wg = Fs.off
  , wn = function() {
    function s(e) {
        this.t = e
    }
    s.getLevel = function() {
        return wg
    }
    ,
    s.setLevel = function(e) {
        return wg = Fs[e]
    }
    ;
    var t = s.prototype;
    return t.error = function() {
        for (var e = arguments.length, i = new Array(e), r = 0; r < e; r++)
            i[r] = arguments[r];
        this.i(console.error, Fs.error, i)
    }
    ,
    t.warn = function() {
        for (var e = arguments.length, i = new Array(e), r = 0; r < e; r++)
            i[r] = arguments[r];
        this.i(console.warn, Fs.warning, i)
    }
    ,
    t.info = function() {
        for (var e = arguments.length, i = new Array(e), r = 0; r < e; r++)
            i[r] = arguments[r];
        this.i(console.info, Fs.info, i)
    }
    ,
    t.debug = function() {
        for (var e = arguments.length, i = new Array(e), r = 0; r < e; r++)
            i[r] = arguments[r];
        this.i(console.log, Fs.debug, i)
    }
    ,
    t.i = function(e, i, r) {
        i <= s.getLevel() && e.apply(console, ["[" + this.t + "] "].concat(r))
    }
    ,
    s
}()
  , cn = Lp
  , fw = by
  , pw = Op
  , mw = wy
  , gw = Ey
  , xy = "/"
  , _w = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");
function Op(s, t) {
    for (var e, i = [], r = 0, n = 0, o = "", a = t && t.delimiter || xy, l = t && t.whitelist || void 0, h = !1; (e = _w.exec(s)) !== null; ) {
        var u = e[0]
          , c = e[1]
          , d = e.index;
        if (o += s.slice(n, d),
        n = d + u.length,
        c)
            o += c[1],
            h = !0;
        else {
            var f = ""
              , p = e[2]
              , m = e[3]
              , g = e[4]
              , _ = e[5];
            if (!h && o.length) {
                var x = o.length - 1
                  , y = o[x];
                (!l || l.indexOf(y) > -1) && (f = y,
                o = o.slice(0, x))
            }
            o && (i.push(o),
            o = "",
            h = !1);
            var v = m || g
              , E = f || a;
            i.push({
                name: p || r++,
                prefix: f,
                delimiter: E,
                optional: _ === "?" || _ === "*",
                repeat: _ === "+" || _ === "*",
                pattern: v ? yw(v) : "[^" + os(E === a ? E : E + a) + "]+?"
            })
        }
    }
    return (o || n < s.length) && i.push(o + s.substr(n)),
    i
}
function by(s, t) {
    return function(e, i) {
        var r = s.exec(e);
        if (!r)
            return !1;
        for (var n = r[0], o = r.index, a = {}, l = i && i.decode || decodeURIComponent, h = 1; h < r.length; h++)
            if (r[h] !== void 0) {
                var u = t[h - 1];
                a[u.name] = u.repeat ? r[h].split(u.delimiter).map(function(c) {
                    return l(c, u)
                }) : l(r[h], u)
            }
        return {
            path: n,
            index: o,
            params: a
        }
    }
}
function wy(s, t) {
    for (var e = new Array(s.length), i = 0; i < s.length; i++)
        typeof s[i] == "object" && (e[i] = new RegExp("^(?:" + s[i].pattern + ")$",kp(t)));
    return function(r, n) {
        for (var o = "", a = n && n.encode || encodeURIComponent, l = !n || n.validate !== !1, h = 0; h < s.length; h++) {
            var u = s[h];
            if (typeof u != "string") {
                var c, d = r ? r[u.name] : void 0;
                if (Array.isArray(d)) {
                    if (!u.repeat)
                        throw new TypeError('Expected "' + u.name + '" to not repeat, but got array');
                    if (d.length === 0) {
                        if (u.optional)
                            continue;
                        throw new TypeError('Expected "' + u.name + '" to not be empty')
                    }
                    for (var f = 0; f < d.length; f++) {
                        if (c = a(d[f], u),
                        l && !e[h].test(c))
                            throw new TypeError('Expected all "' + u.name + '" to match "' + u.pattern + '"');
                        o += (f === 0 ? u.prefix : u.delimiter) + c
                    }
                } else if (typeof d != "string" && typeof d != "number" && typeof d != "boolean") {
                    if (!u.optional)
                        throw new TypeError('Expected "' + u.name + '" to be ' + (u.repeat ? "an array" : "a string"))
                } else {
                    if (c = a(String(d), u),
                    l && !e[h].test(c))
                        throw new TypeError('Expected "' + u.name + '" to match "' + u.pattern + '", but got "' + c + '"');
                    o += u.prefix + c
                }
            } else
                o += u
        }
        return o
    }
}
function os(s) {
    return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
}
function yw(s) {
    return s.replace(/([=!:$/()])/g, "\\$1")
}
function kp(s) {
    return s && s.sensitive ? "" : "i"
}
function Ey(s, t, e) {
    for (var i = (e = e || {}).strict, r = e.start !== !1, n = e.end !== !1, o = e.delimiter || xy, a = [].concat(e.endsWith || []).map(os).concat("$").join("|"), l = r ? "^" : "", h = 0; h < s.length; h++) {
        var u = s[h];
        if (typeof u == "string")
            l += os(u);
        else {
            var c = u.repeat ? "(?:" + u.pattern + ")(?:" + os(u.delimiter) + "(?:" + u.pattern + "))*" : u.pattern;
            t && t.push(u),
            l += u.optional ? u.prefix ? "(?:" + os(u.prefix) + "(" + c + "))?" : "(" + c + ")?" : os(u.prefix) + "(" + c + ")"
        }
    }
    if (n)
        i || (l += "(?:" + os(o) + ")?"),
        l += a === "$" ? "$" : "(?=" + a + ")";
    else {
        var d = s[s.length - 1]
          , f = typeof d == "string" ? d[d.length - 1] === o : d === void 0;
        i || (l += "(?:" + os(o) + "(?=" + a + "))?"),
        f || (l += "(?=" + os(o) + "|" + a + ")")
    }
    return new RegExp(l,kp(e))
}
function Lp(s, t, e) {
    return s instanceof RegExp ? function(i, r) {
        if (!r)
            return i;
        var n = i.source.match(/\((?!\?)/g);
        if (n)
            for (var o = 0; o < n.length; o++)
                r.push({
                    name: o,
                    prefix: null,
                    delimiter: null,
                    optional: !1,
                    repeat: !1,
                    pattern: null
                });
        return i
    }(s, t) : Array.isArray(s) ? function(i, r, n) {
        for (var o = [], a = 0; a < i.length; a++)
            o.push(Lp(i[a], r, n).source);
        return new RegExp("(?:" + o.join("|") + ")",kp(n))
    }(s, t, e) : function(i, r, n) {
        return Ey(Op(i, n), r, n)
    }(s, t, e)
}
cn.match = function(s, t) {
    var e = [];
    return by(Lp(s, e, t), e)
}
,
cn.regexpToFunction = fw,
cn.parse = pw,
cn.compile = function(s, t) {
    return wy(Op(s, t), t)
}
,
cn.tokensToFunction = mw,
cn.tokensToRegExp = gw;
var Yr = {
    container: "container",
    history: "history",
    namespace: "namespace",
    prefix: "data-barba",
    prevent: "prevent",
    wrapper: "wrapper"
}
  , En = new (function() {
    function s() {
        this.o = Yr,
        this.u = new DOMParser
    }
    var t = s.prototype;
    return t.toString = function(e) {
        return e.outerHTML
    }
    ,
    t.toDocument = function(e) {
        return this.u.parseFromString(e, "text/html")
    }
    ,
    t.toElement = function(e) {
        var i = document.createElement("div");
        return i.innerHTML = e,
        i
    }
    ,
    t.getHtml = function(e) {
        return e === void 0 && (e = document),
        this.toString(e.documentElement)
    }
    ,
    t.getWrapper = function(e) {
        return e === void 0 && (e = document),
        e.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
    }
    ,
    t.getContainer = function(e) {
        return e === void 0 && (e = document),
        e.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
    }
    ,
    t.removeContainer = function(e) {
        document.body.contains(e) && e.parentNode.removeChild(e)
    }
    ,
    t.addContainer = function(e, i) {
        var r = this.getContainer();
        r ? this.s(e, r) : i.appendChild(e)
    }
    ,
    t.getNamespace = function(e) {
        e === void 0 && (e = document);
        var i = e.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
        return i ? i.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
    }
    ,
    t.getHref = function(e) {
        if (e.tagName && e.tagName.toLowerCase() === "a") {
            if (typeof e.href == "string")
                return e.href;
            var i = e.getAttribute("href") || e.getAttribute("xlink:href");
            if (i)
                return this.resolveUrl(i.baseVal || i)
        }
        return null
    }
    ,
    t.resolveUrl = function() {
        for (var e = arguments.length, i = new Array(e), r = 0; r < e; r++)
            i[r] = arguments[r];
        var n = i.length;
        if (n === 0)
            throw new Error("resolveUrl requires at least one argument; got none.");
        var o = document.createElement("base");
        if (o.href = arguments[0],
        n === 1)
            return o.href;
        var a = document.getElementsByTagName("head")[0];
        a.insertBefore(o, a.firstChild);
        for (var l, h = document.createElement("a"), u = 1; u < n; u++)
            h.href = arguments[u],
            o.href = l = h.href;
        return a.removeChild(o),
        l
    }
    ,
    t.s = function(e, i) {
        i.parentNode.insertBefore(e, i.nextSibling)
    }
    ,
    s
}())
  , Ty = new (function() {
    function s() {
        this.h = [],
        this.v = -1
    }
    var t = s.prototype;
    return t.init = function(e, i) {
        this.l = "barba";
        var r = {
            ns: i,
            scroll: {
                x: window.scrollX,
                y: window.scrollY
            },
            url: e
        };
        this.h.push(r),
        this.v = 0;
        var n = {
            from: this.l,
            index: 0,
            states: [].concat(this.h)
        };
        window.history && window.history.replaceState(n, "", e)
    }
    ,
    t.change = function(e, i, r) {
        if (r && r.state) {
            var n = r.state
              , o = n.index;
            i = this.m(this.v - o),
            this.replace(n.states),
            this.v = o
        } else
            this.add(e, i);
        return i
    }
    ,
    t.add = function(e, i) {
        var r = this.size
          , n = this.p(i)
          , o = {
            ns: "tmp",
            scroll: {
                x: window.scrollX,
                y: window.scrollY
            },
            url: e
        };
        this.h.push(o),
        this.v = r;
        var a = {
            from: this.l,
            index: r,
            states: [].concat(this.h)
        };
        switch (n) {
        case "push":
            window.history && window.history.pushState(a, "", e);
            break;
        case "replace":
            window.history && window.history.replaceState(a, "", e)
        }
    }
    ,
    t.update = function(e, i) {
        var r = i || this.v
          , n = bn({}, this.get(r), {}, e);
        this.set(r, n)
    }
    ,
    t.remove = function(e) {
        e ? this.h.splice(e, 1) : this.h.pop(),
        this.v--
    }
    ,
    t.clear = function() {
        this.h = [],
        this.v = -1
    }
    ,
    t.replace = function(e) {
        this.h = e
    }
    ,
    t.get = function(e) {
        return this.h[e]
    }
    ,
    t.set = function(e, i) {
        return this.h[e] = i
    }
    ,
    t.p = function(e) {
        var i = "push"
          , r = e
          , n = Yr.prefix + "-" + Yr.history;
        return r.hasAttribute && r.hasAttribute(n) && (i = r.getAttribute(n)),
        i
    }
    ,
    t.m = function(e) {
        return Math.abs(e) > 1 ? e > 0 ? "forward" : "back" : e === 0 ? "popstate" : e > 0 ? "back" : "forward"
    }
    ,
    Fp(s, [{
        key: "current",
        get: function() {
            return this.h[this.v]
        }
    }, {
        key: "state",
        get: function() {
            return this.h[this.h.length - 1]
        }
    }, {
        key: "previous",
        get: function() {
            return this.v < 1 ? null : this.h[this.v - 1]
        }
    }, {
        key: "size",
        get: function() {
            return this.h.length
        }
    }]),
    s
}())
  , xu = function(s, t) {
    try {
        var e = function() {
            if (!t.next.html)
                return Promise.resolve(s).then(function(i) {
                    var r = t.next;
                    if (i) {
                        var n = En.toElement(i);
                        r.namespace = En.getNamespace(n),
                        r.container = En.getContainer(n),
                        r.html = i,
                        Ty.update({
                            ns: r.namespace
                        });
                        var o = En.toDocument(i);
                        document.title = o.title
                    }
                })
        }();
        return Promise.resolve(e && e.then ? e.then(function() {}) : void 0)
    } catch (i) {
        return Promise.reject(i)
    }
}
  , Dy = cn
  , vw = {
    __proto__: null,
    update: xu,
    nextTick: function() {
        return new Promise(function(s) {
            window.requestAnimationFrame(s)
        }
        )
    },
    pathToRegexp: Dy
}
  , Ay = function() {
    return window.location.origin
}
  , gl = function(s) {
    return s === void 0 && (s = window.location.href),
    bu(s).port
}
  , bu = function(s) {
    var t, e = s.match(/:\d+/);
    if (e === null)
        /^http/.test(s) && (t = 80),
        /^https/.test(s) && (t = 443);
    else {
        var i = e[0].substring(1);
        t = parseInt(i, 10)
    }
    var r, n = s.replace(Ay(), ""), o = {}, a = n.indexOf("#");
    a >= 0 && (r = n.slice(a + 1),
    n = n.slice(0, a));
    var l = n.indexOf("?");
    return l >= 0 && (o = Sy(n.slice(l + 1)),
    n = n.slice(0, l)),
    {
        hash: r,
        path: n,
        port: t,
        query: o
    }
}
  , Sy = function(s) {
    return s.split("&").reduce(function(t, e) {
        var i = e.split("=");
        return t[i[0]] = i[1],
        t
    }, {})
}
  , Qd = function(s) {
    return s === void 0 && (s = window.location.href),
    s.replace(/(\/#.*|\/|#.*)$/, "")
}
  , xw = {
    __proto__: null,
    getHref: function() {
        return window.location.href
    },
    getOrigin: Ay,
    getPort: gl,
    getPath: function(s) {
        return s === void 0 && (s = window.location.href),
        bu(s).path
    },
    parse: bu,
    parseQuery: Sy,
    clean: Qd
};
function bw(s, t, e) {
    return t === void 0 && (t = 2e3),
    new Promise(function(i, r) {
        var n = new XMLHttpRequest;
        n.onreadystatechange = function() {
            if (n.readyState === XMLHttpRequest.DONE) {
                if (n.status === 200)
                    i(n.responseText);
                else if (n.status) {
                    var o = {
                        status: n.status,
                        statusText: n.statusText
                    };
                    e(s, o),
                    r(o)
                }
            }
        }
        ,
        n.ontimeout = function() {
            var o = new Error("Timeout error [" + t + "]");
            e(s, o),
            r(o)
        }
        ,
        n.onerror = function() {
            var o = new Error("Fetch error");
            e(s, o),
            r(o)
        }
        ,
        n.open("GET", s),
        n.timeout = t,
        n.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"),
        n.setRequestHeader("x-barba", "yes"),
        n.send()
    }
    )
}
var ww = function(s) {
    return !!s && (typeof s == "object" || typeof s == "function") && typeof s.then == "function"
};
function xo(s, t) {
    return t === void 0 && (t = {}),
    function() {
        for (var e = arguments.length, i = new Array(e), r = 0; r < e; r++)
            i[r] = arguments[r];
        var n = !1
          , o = new Promise(function(a, l) {
            t.async = function() {
                return n = !0,
                function(u, c) {
                    u ? l(u) : a(c)
                }
            }
            ;
            var h = s.apply(t, i);
            n || (ww(h) ? h.then(a, l) : a(h))
        }
        );
        return o
    }
}
var Ps = new (function(s) {
    function t() {
        var i;
        return (i = s.call(this) || this).logger = new wn("@barba/core"),
        i.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"],
        i.registered = new Map,
        i.init(),
        i
    }
    pc(t, s);
    var e = t.prototype;
    return e.init = function() {
        var i = this;
        this.registered.clear(),
        this.all.forEach(function(r) {
            i[r] || (i[r] = function(n, o) {
                i.registered.has(r) || i.registered.set(r, new Set),
                i.registered.get(r).add({
                    ctx: o || {},
                    fn: n
                })
            }
            )
        })
    }
    ,
    e.do = function(i) {
        for (var r = this, n = arguments.length, o = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
            o[a - 1] = arguments[a];
        if (this.registered.has(i)) {
            var l = Promise.resolve();
            return this.registered.get(i).forEach(function(h) {
                l = l.then(function() {
                    return xo(h.fn, h.ctx).apply(void 0, o)
                })
            }),
            l.catch(function(h) {
                r.logger.debug("Hook error [" + i + "]"),
                r.logger.error(h)
            })
        }
        return Promise.resolve()
    }
    ,
    e.clear = function() {
        var i = this;
        this.all.forEach(function(r) {
            delete i[r]
        }),
        this.init()
    }
    ,
    e.help = function() {
        this.logger.info("Available hooks: " + this.all.join(","));
        var i = [];
        this.registered.forEach(function(r, n) {
            return i.push(n)
        }),
        this.logger.info("Registered hooks: " + i.join(","))
    }
    ,
    t
}(dw))
  , Cy = function() {
    function s(t) {
        if (this.P = [],
        typeof t == "boolean")
            this.g = t;
        else {
            var e = Array.isArray(t) ? t : [t];
            this.P = e.map(function(i) {
                return Dy(i)
            })
        }
    }
    return s.prototype.checkHref = function(t) {
        if (typeof this.g == "boolean")
            return this.g;
        var e = bu(t).path;
        return this.P.some(function(i) {
            return i.exec(e) !== null
        })
    }
    ,
    s
}()
  , Ew = function(s) {
    function t(i) {
        var r;
        return (r = s.call(this, i) || this).k = new Map,
        r
    }
    pc(t, s);
    var e = t.prototype;
    return e.set = function(i, r, n) {
        return this.k.set(i, {
            action: n,
            request: r
        }),
        {
            action: n,
            request: r
        }
    }
    ,
    e.get = function(i) {
        return this.k.get(i)
    }
    ,
    e.getRequest = function(i) {
        return this.k.get(i).request
    }
    ,
    e.getAction = function(i) {
        return this.k.get(i).action
    }
    ,
    e.has = function(i) {
        return !this.checkHref(i) && this.k.has(i)
    }
    ,
    e.delete = function(i) {
        return this.k.delete(i)
    }
    ,
    e.update = function(i, r) {
        var n = bn({}, this.k.get(i), {}, r);
        return this.k.set(i, n),
        n
    }
    ,
    t
}(Cy)
  , Tw = function() {
    return !window.history.pushState
}
  , Dw = function(s) {
    return !s.el || !s.href
}
  , Aw = function(s) {
    var t = s.event;
    return t.which > 1 || t.metaKey || t.ctrlKey || t.shiftKey || t.altKey
}
  , Sw = function(s) {
    var t = s.el;
    return t.hasAttribute("target") && t.target === "_blank"
}
  , Cw = function(s) {
    var t = s.el;
    return t.protocol !== void 0 && window.location.protocol !== t.protocol || t.hostname !== void 0 && window.location.hostname !== t.hostname
}
  , Pw = function(s) {
    var t = s.el;
    return t.port !== void 0 && gl() !== gl(t.href)
}
  , Iw = function(s) {
    var t = s.el;
    return t.getAttribute && typeof t.getAttribute("download") == "string"
}
  , Rw = function(s) {
    return s.el.hasAttribute(Yr.prefix + "-" + Yr.prevent)
}
  , Mw = function(s) {
    return !!s.el.closest("[" + Yr.prefix + "-" + Yr.prevent + '="all"]')
}
  , Fw = function(s) {
    var t = s.href;
    return Qd(t) === Qd() && gl(t) === gl()
}
  , Bw = function(s) {
    function t(i) {
        var r;
        return (r = s.call(this, i) || this).suite = [],
        r.tests = new Map,
        r.init(),
        r
    }
    pc(t, s);
    var e = t.prototype;
    return e.init = function() {
        this.add("pushState", Tw),
        this.add("exists", Dw),
        this.add("newTab", Aw),
        this.add("blank", Sw),
        this.add("corsDomain", Cw),
        this.add("corsPort", Pw),
        this.add("download", Iw),
        this.add("preventSelf", Rw),
        this.add("preventAll", Mw),
        this.add("sameUrl", Fw, !1)
    }
    ,
    e.add = function(i, r, n) {
        n === void 0 && (n = !0),
        this.tests.set(i, r),
        n && this.suite.push(i)
    }
    ,
    e.run = function(i, r, n, o) {
        return this.tests.get(i)({
            el: r,
            event: n,
            href: o
        })
    }
    ,
    e.checkLink = function(i, r, n) {
        var o = this;
        return this.suite.some(function(a) {
            return o.run(a, i, r, n)
        })
    }
    ,
    t
}(Cy)
  , Uc = function(s) {
    function t(e, i) {
        var r;
        i === void 0 && (i = "Barba error");
        for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), a = 2; a < n; a++)
            o[a - 2] = arguments[a];
        return (r = s.call.apply(s, [this].concat(o)) || this).error = e,
        r.label = i,
        Error.captureStackTrace && Error.captureStackTrace(function(l) {
            if (l === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l
        }(r), t),
        r.name = "BarbaError",
        r
    }
    return pc(t, s),
    t
}(vy(Error))
  , Ow = function() {
    function s(e) {
        e === void 0 && (e = []),
        this.logger = new wn("@barba/core"),
        this.all = [],
        this.page = [],
        this.once = [],
        this.A = [{
            name: "namespace",
            type: "strings"
        }, {
            name: "custom",
            type: "function"
        }],
        e && (this.all = this.all.concat(e)),
        this.update()
    }
    var t = s.prototype;
    return t.add = function(e, i) {
        switch (e) {
        case "rule":
            this.A.splice(i.position || 0, 0, i.value);
            break;
        case "transition":
        default:
            this.all.push(i)
        }
        this.update()
    }
    ,
    t.resolve = function(e, i) {
        var r = this;
        i === void 0 && (i = {});
        var n = i.once ? this.once : this.page;
        n = n.filter(i.self ? function(d) {
            return d.name && d.name === "self"
        }
        : function(d) {
            return !d.name || d.name !== "self"
        }
        );
        var o = new Map
          , a = n.find(function(d) {
            var f = !0
              , p = {};
            return !(!i.self || d.name !== "self") || (r.A.reverse().forEach(function(m) {
                f && (f = r.R(d, m, e, p),
                d.from && d.to && (f = r.R(d, m, e, p, "from") && r.R(d, m, e, p, "to")),
                d.from && !d.to && (f = r.R(d, m, e, p, "from")),
                !d.from && d.to && (f = r.R(d, m, e, p, "to")))
            }),
            o.set(d, p),
            f)
        })
          , l = o.get(a)
          , h = [];
        if (h.push(i.once ? "once" : "page"),
        i.self && h.push("self"),
        l) {
            var u, c = [a];
            Object.keys(l).length > 0 && c.push(l),
            (u = this.logger).info.apply(u, ["Transition found [" + h.join(",") + "]"].concat(c))
        } else
            this.logger.info("No transition found [" + h.join(",") + "]");
        return a
    }
    ,
    t.update = function() {
        var e = this;
        this.all = this.all.map(function(i) {
            return e.T(i)
        }).sort(function(i, r) {
            return i.priority - r.priority
        }).reverse().map(function(i) {
            return delete i.priority,
            i
        }),
        this.page = this.all.filter(function(i) {
            return i.leave !== void 0 || i.enter !== void 0
        }),
        this.once = this.all.filter(function(i) {
            return i.once !== void 0
        })
    }
    ,
    t.R = function(e, i, r, n, o) {
        var a = !0
          , l = !1
          , h = e
          , u = i.name
          , c = u
          , d = u
          , f = u
          , p = o ? h[o] : h
          , m = o === "to" ? r.next : r.current;
        if (o ? p && p[u] : p[u]) {
            switch (i.type) {
            case "strings":
            default:
                var g = Array.isArray(p[c]) ? p[c] : [p[c]];
                m[c] && g.indexOf(m[c]) !== -1 && (l = !0),
                g.indexOf(m[c]) === -1 && (a = !1);
                break;
            case "object":
                var _ = Array.isArray(p[d]) ? p[d] : [p[d]];
                m[d] ? (m[d].name && _.indexOf(m[d].name) !== -1 && (l = !0),
                _.indexOf(m[d].name) === -1 && (a = !1)) : a = !1;
                break;
            case "function":
                p[f](r) ? l = !0 : a = !1
            }
            l && (o ? (n[o] = n[o] || {},
            n[o][u] = h[o][u]) : n[u] = h[u])
        }
        return a
    }
    ,
    t.O = function(e, i, r) {
        var n = 0;
        return (e[i] || e.from && e.from[i] || e.to && e.to[i]) && (n += Math.pow(10, r),
        e.from && e.from[i] && (n += 1),
        e.to && e.to[i] && (n += 2)),
        n
    }
    ,
    t.T = function(e) {
        var i = this;
        e.priority = 0;
        var r = 0;
        return this.A.forEach(function(n, o) {
            r += i.O(e, n.name, o + 1)
        }),
        e.priority = r,
        e
    }
    ,
    s
}()
  , kw = function() {
    function s(e) {
        e === void 0 && (e = []),
        this.logger = new wn("@barba/core"),
        this.S = !1,
        this.store = new Ow(e)
    }
    var t = s.prototype;
    return t.get = function(e, i) {
        return this.store.resolve(e, i)
    }
    ,
    t.doOnce = function(e) {
        var i = e.data
          , r = e.transition;
        try {
            var n = function() {
                o.S = !1
            }
              , o = this
              , a = r || {};
            o.S = !0;
            var l = lo(function() {
                return Promise.resolve(o.j("beforeOnce", i, a)).then(function() {
                    return Promise.resolve(o.once(i, a)).then(function() {
                        return Promise.resolve(o.j("afterOnce", i, a)).then(function() {})
                    })
                })
            }, function(h) {
                o.S = !1,
                o.logger.debug("Transition error [before/after/once]"),
                o.logger.error(h)
            });
            return Promise.resolve(l && l.then ? l.then(n) : n())
        } catch (h) {
            return Promise.reject(h)
        }
    }
    ,
    t.doPage = function(e) {
        var i = e.data
          , r = e.transition
          , n = e.page
          , o = e.wrapper;
        try {
            var a = function(f) {
                if (l)
                    return f;
                h.S = !1
            }
              , l = !1
              , h = this
              , u = r || {}
              , c = u.sync === !0 || !1;
            h.S = !0;
            var d = lo(function() {
                function f() {
                    return Promise.resolve(h.j("before", i, u)).then(function() {
                        var m = !1;
                        function g(x) {
                            return m ? x : Promise.resolve(h.remove(i)).then(function() {
                                return Promise.resolve(h.j("after", i, u)).then(function() {})
                            })
                        }
                        var _ = function() {
                            if (c)
                                return lo(function() {
                                    return Promise.resolve(h.add(i, o)).then(function() {
                                        return Promise.resolve(h.j("beforeLeave", i, u)).then(function() {
                                            return Promise.resolve(h.j("beforeEnter", i, u)).then(function() {
                                                return Promise.resolve(Promise.all([h.leave(i, u), h.enter(i, u)])).then(function() {
                                                    return Promise.resolve(h.j("afterLeave", i, u)).then(function() {
                                                        return Promise.resolve(h.j("afterEnter", i, u)).then(function() {})
                                                    })
                                                })
                                            })
                                        })
                                    })
                                }, function(E) {
                                    if (h.M(E))
                                        throw new Uc(E,"Transition error [sync]")
                                });
                            var x = function(E) {
                                return m ? E : lo(function() {
                                    var P = function() {
                                        if (y !== !1)
                                            return Promise.resolve(h.add(i, o)).then(function() {
                                                return Promise.resolve(h.j("beforeEnter", i, u)).then(function() {
                                                    return Promise.resolve(h.enter(i, u, y)).then(function() {
                                                        return Promise.resolve(h.j("afterEnter", i, u)).then(function() {})
                                                    })
                                                })
                                            })
                                    }();
                                    if (P && P.then)
                                        return P.then(function() {})
                                }, function(P) {
                                    if (h.M(P))
                                        throw new Uc(P,"Transition error [before/after/enter]")
                                })
                            }
                              , y = !1
                              , v = lo(function() {
                                return Promise.resolve(h.j("beforeLeave", i, u)).then(function() {
                                    return Promise.resolve(Promise.all([h.leave(i, u), xu(n, i)]).then(function(E) {
                                        return E[0]
                                    })).then(function(E) {
                                        return y = E,
                                        Promise.resolve(h.j("afterLeave", i, u)).then(function() {})
                                    })
                                })
                            }, function(E) {
                                if (h.M(E))
                                    throw new Uc(E,"Transition error [before/after/leave]")
                            });
                            return v && v.then ? v.then(x) : x(v)
                        }();
                        return _ && _.then ? _.then(g) : g(_)
                    })
                }
                var p = function() {
                    if (c)
                        return Promise.resolve(xu(n, i)).then(function() {})
                }();
                return p && p.then ? p.then(f) : f()
            }, function(f) {
                throw h.S = !1,
                f.name && f.name === "BarbaError" ? (h.logger.debug(f.label),
                h.logger.error(f.error),
                f) : (h.logger.debug("Transition error [page]"),
                h.logger.error(f),
                f)
            });
            return Promise.resolve(d && d.then ? d.then(a) : a(d))
        } catch (f) {
            return Promise.reject(f)
        }
    }
    ,
    t.once = function(e, i) {
        try {
            return Promise.resolve(Ps.do("once", e, i)).then(function() {
                return i.once ? xo(i.once, i)(e) : Promise.resolve()
            })
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    t.leave = function(e, i) {
        try {
            return Promise.resolve(Ps.do("leave", e, i)).then(function() {
                return i.leave ? xo(i.leave, i)(e) : Promise.resolve()
            })
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    t.enter = function(e, i, r) {
        try {
            return Promise.resolve(Ps.do("enter", e, i)).then(function() {
                return i.enter ? xo(i.enter, i)(e, r) : Promise.resolve()
            })
        } catch (n) {
            return Promise.reject(n)
        }
    }
    ,
    t.add = function(e, i) {
        try {
            return En.addContainer(e.next.container, i),
            Ps.do("nextAdded", e),
            Promise.resolve()
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    t.remove = function(e) {
        try {
            return En.removeContainer(e.current.container),
            Ps.do("currentRemoved", e),
            Promise.resolve()
        } catch (i) {
            return Promise.reject(i)
        }
    }
    ,
    t.M = function(e) {
        return e.message ? !/Timeout error|Fetch error/.test(e.message) : !e.status
    }
    ,
    t.j = function(e, i, r) {
        try {
            return Promise.resolve(Ps.do(e, i, r)).then(function() {
                return r[e] ? xo(r[e], r)(i) : Promise.resolve()
            })
        } catch (n) {
            return Promise.reject(n)
        }
    }
    ,
    Fp(s, [{
        key: "isRunning",
        get: function() {
            return this.S
        },
        set: function(e) {
            this.S = e
        }
    }, {
        key: "hasOnce",
        get: function() {
            return this.store.once.length > 0
        }
    }, {
        key: "hasSelf",
        get: function() {
            return this.store.all.some(function(e) {
                return e.name === "self"
            })
        }
    }, {
        key: "shouldWait",
        get: function() {
            return this.store.all.some(function(e) {
                return e.to && !e.to.route || e.sync
            })
        }
    }]),
    s
}()
  , Lw = function() {
    function s(t) {
        var e = this;
        this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"],
        this.byNamespace = new Map,
        t.length !== 0 && (t.forEach(function(i) {
            e.byNamespace.set(i.namespace, i)
        }),
        this.names.forEach(function(i) {
            Ps[i](e.L(i))
        }))
    }
    return s.prototype.L = function(t) {
        var e = this;
        return function(i) {
            var r = t.match(/enter/i) ? i.next : i.current
              , n = e.byNamespace.get(r.namespace);
            return n && n[t] ? xo(n[t], n)(i) : Promise.resolve()
        }
    }
    ,
    s
}();
Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector),
Element.prototype.closest || (Element.prototype.closest = function(s) {
    var t = this;
    do {
        if (t.matches(s))
            return t;
        t = t.parentElement || t.parentNode
    } while (t !== null && t.nodeType === 1);
    return null
}
);
var Nw = {
    container: null,
    html: "",
    namespace: "",
    url: {
        hash: "",
        href: "",
        path: "",
        port: null,
        query: {}
    }
}
  , Uw = new (function() {
    function s() {
        this.version = cw,
        this.schemaPage = Nw,
        this.Logger = wn,
        this.logger = new wn("@barba/core"),
        this.plugins = [],
        this.hooks = Ps,
        this.dom = En,
        this.helpers = vw,
        this.history = Ty,
        this.request = bw,
        this.url = xw
    }
    var t = s.prototype;
    return t.use = function(e, i) {
        var r = this.plugins;
        r.indexOf(e) > -1 ? this.logger.warn("Plugin [" + e.name + "] already installed.") : typeof e.install == "function" ? (e.install(this, i),
        r.push(e)) : this.logger.warn("Plugin [" + e.name + '] has no "install" method.')
    }
    ,
    t.init = function(e) {
        var i = e === void 0 ? {} : e
          , r = i.transitions
          , n = r === void 0 ? [] : r
          , o = i.views
          , a = o === void 0 ? [] : o
          , l = i.schema
          , h = l === void 0 ? Yr : l
          , u = i.requestError
          , c = i.timeout
          , d = c === void 0 ? 2e3 : c
          , f = i.cacheIgnore
          , p = f !== void 0 && f
          , m = i.prefetchIgnore
          , g = m !== void 0 && m
          , _ = i.preventRunning
          , x = _ !== void 0 && _
          , y = i.prevent
          , v = y === void 0 ? null : y
          , E = i.debug
          , P = i.logLevel;
        if (wn.setLevel((E !== void 0 && E) === !0 ? "debug" : P === void 0 ? "off" : P),
        this.logger.info(this.version),
        Object.keys(h).forEach(function(I) {
            Yr[I] && (Yr[I] = h[I])
        }),
        this.$ = u,
        this.timeout = d,
        this.cacheIgnore = p,
        this.prefetchIgnore = g,
        this.preventRunning = x,
        this._ = this.dom.getWrapper(),
        !this._)
            throw new Error("[@barba/core] No Barba wrapper found");
        this._.setAttribute("aria-live", "polite"),
        this.q();
        var w = this.data.current;
        if (!w.container)
            throw new Error("[@barba/core] No Barba container found");
        if (this.cache = new Ew(p),
        this.prevent = new Bw(g),
        this.transitions = new kw(n),
        this.views = new Lw(a),
        v !== null) {
            if (typeof v != "function")
                throw new Error("[@barba/core] Prevent should be a function");
            this.prevent.add("preventCustom", v)
        }
        this.history.init(w.url.href, w.namespace),
        this.B = this.B.bind(this),
        this.U = this.U.bind(this),
        this.D = this.D.bind(this),
        this.F(),
        this.plugins.forEach(function(I) {
            return I.init()
        });
        var A = this.data;
        A.trigger = "barba",
        A.next = A.current,
        A.current = bn({}, this.schemaPage),
        this.hooks.do("ready", A),
        this.once(A),
        this.q()
    }
    ,
    t.destroy = function() {
        this.q(),
        this.H(),
        this.history.clear(),
        this.hooks.clear(),
        this.plugins = []
    }
    ,
    t.force = function(e) {
        window.location.assign(e)
    }
    ,
    t.go = function(e, i, r) {
        var n;
        if (i === void 0 && (i = "barba"),
        this.transitions.isRunning)
            this.force(e);
        else if (!(n = i === "popstate" ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(e) : this.prevent.run("sameUrl", null, null, e)) || this.transitions.hasSelf)
            return i = this.history.change(e, i, r),
            r && (r.stopPropagation(),
            r.preventDefault()),
            this.page(e, i, n)
    }
    ,
    t.once = function(e) {
        try {
            var i = this;
            return Promise.resolve(i.hooks.do("beforeEnter", e)).then(function() {
                function r() {
                    return Promise.resolve(i.hooks.do("afterEnter", e)).then(function() {})
                }
                var n = function() {
                    if (i.transitions.hasOnce) {
                        var o = i.transitions.get(e, {
                            once: !0
                        });
                        return Promise.resolve(i.transitions.doOnce({
                            transition: o,
                            data: e
                        })).then(function() {})
                    }
                }();
                return n && n.then ? n.then(r) : r()
            })
        } catch (r) {
            return Promise.reject(r)
        }
    }
    ,
    t.page = function(e, i, r) {
        try {
            var n = function() {
                var h = o.data;
                return Promise.resolve(o.hooks.do("page", h)).then(function() {
                    var u = lo(function() {
                        var c = o.transitions.get(h, {
                            once: !1,
                            self: r
                        });
                        return Promise.resolve(o.transitions.doPage({
                            data: h,
                            page: a,
                            transition: c,
                            wrapper: o._
                        })).then(function() {
                            o.q()
                        })
                    }, function() {
                        wn.getLevel() === 0 && o.force(h.current.url.href)
                    });
                    if (u && u.then)
                        return u.then(function() {})
                })
            }
              , o = this;
            o.data.next.url = bn({
                href: e
            }, o.url.parse(e)),
            o.data.trigger = i;
            var a = o.cache.has(e) ? o.cache.update(e, {
                action: "click"
            }).request : o.cache.set(e, o.request(e, o.timeout, o.onRequestError.bind(o, i)), "click").request
              , l = function() {
                if (o.transitions.shouldWait)
                    return Promise.resolve(xu(a, o.data)).then(function() {})
            }();
            return Promise.resolve(l && l.then ? l.then(n) : n())
        } catch (h) {
            return Promise.reject(h)
        }
    }
    ,
    t.onRequestError = function(e) {
        this.transitions.isRunning = !1;
        for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++)
            r[n - 1] = arguments[n];
        var o = r[0]
          , a = r[1]
          , l = this.cache.getAction(o);
        return this.cache.delete(o),
        !(this.$ && this.$(e, l, o, a) === !1 || (l === "click" && this.force(o),
        1))
    }
    ,
    t.prefetch = function(e) {
        var i = this;
        this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, "barba")).catch(function(r) {
            i.logger.error(r)
        }), "prefetch")
    }
    ,
    t.F = function() {
        this.prefetchIgnore !== !0 && (document.addEventListener("mouseover", this.B),
        document.addEventListener("touchstart", this.B)),
        document.addEventListener("click", this.U),
        window.addEventListener("popstate", this.D)
    }
    ,
    t.H = function() {
        this.prefetchIgnore !== !0 && (document.removeEventListener("mouseover", this.B),
        document.removeEventListener("touchstart", this.B)),
        document.removeEventListener("click", this.U),
        window.removeEventListener("popstate", this.D)
    }
    ,
    t.B = function(e) {
        var i = this
          , r = this.I(e);
        if (r) {
            var n = this.dom.getHref(r);
            this.prevent.checkHref(n) || this.cache.has(n) || this.cache.set(n, this.request(n, this.timeout, this.onRequestError.bind(this, r)).catch(function(o) {
                i.logger.error(o)
            }), "enter")
        }
    }
    ,
    t.U = function(e) {
        var i = this.I(e);
        if (i)
            return this.transitions.isRunning && this.preventRunning ? (e.preventDefault(),
            void e.stopPropagation()) : void this.go(this.dom.getHref(i), i, e)
    }
    ,
    t.D = function(e) {
        this.go(this.url.getHref(), "popstate", e)
    }
    ,
    t.I = function(e) {
        for (var i = e.target; i && !this.dom.getHref(i); )
            i = i.parentNode;
        if (i && !this.prevent.checkLink(i, e, this.dom.getHref(i)))
            return i
    }
    ,
    t.q = function() {
        var e = this.url.getHref()
          , i = {
            container: this.dom.getContainer(),
            html: this.dom.getHtml(),
            namespace: this.dom.getNamespace(),
            url: bn({
                href: e
            }, this.url.parse(e))
        };
        this.C = {
            current: i,
            next: bn({}, this.schemaPage),
            trigger: void 0
        },
        this.hooks.do("reset", this.data)
    }
    ,
    Fp(s, [{
        key: "data",
        get: function() {
            return this.C
        }
    }, {
        key: "wrapper",
        get: function() {
            return this._
        }
    }]),
    s
}());
function as(s) {
    if (s === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return s
}
function Py(s, t) {
    s.prototype = Object.create(t.prototype),
    s.prototype.constructor = s,
    s.__proto__ = t
}
var $i = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, Wo = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, Np, ei, de, rr = 1e8, Zt = 1 / rr, Jd = Math.PI * 2, Gw = Jd / 4, Hw = 0, Iy = Math.sqrt, $w = Math.cos, zw = Math.sin, Ge = function(t) {
    return typeof t == "string"
}, fe = function(t) {
    return typeof t == "function"
}, vs = function(t) {
    return typeof t == "number"
}, Up = function(t) {
    return typeof t > "u"
}, ts = function(t) {
    return typeof t == "object"
}, wi = function(t) {
    return t !== !1
}, Gp = function() {
    return typeof window < "u"
}, nh = function(t) {
    return fe(t) || Ge(t)
}, Ry = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, ii = Array.isArray, tf = /(?:-?\.?\d|\.)+/gi, My = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, bo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Gc = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Fy = /[+-]=-?[.\d]+/, By = /[^,'"\[\]\s]+/gi, Vw = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, le, Ki, ef, Hp, Xi = {}, wu = {}, Oy, ky = function(t) {
    return (wu = Hn(t, Xi)) && Ai
}, $p = function(t, e) {
    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
}, _l = function(t, e) {
    return !e && console.warn(t)
}, Ly = function(t, e) {
    return t && (Xi[t] = e) && wu && (wu[t] = e) || Xi
}, yl = function() {
    return 0
}, Xw = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, Kh = {
    suppressEvents: !0,
    kill: !1
}, Ww = {
    suppressEvents: !0
}, zp = {}, Vs = [], rf = {}, Ny, ki = {}, Hc = {}, Eg = 30, Zh = [], Vp = "", Xp = function(t) {
    var e = t[0], i, r;
    if (ts(e) || fe(e) || (t = [t]),
    !(i = (e._gsap || {}).harness)) {
        for (r = Zh.length; r-- && !Zh[r].targetTest(e); )
            ;
        i = Zh[r]
    }
    for (r = t.length; r--; )
        t[r] && (t[r]._gsap || (t[r]._gsap = new lv(t[r],i))) || t.splice(r, 1);
    return t
}, Sn = function(t) {
    return t._gsap || Xp(sr(t))[0]._gsap
}, Uy = function(t, e, i) {
    return (i = t[e]) && fe(i) ? t[e]() : Up(i) && t.getAttribute && t.getAttribute(e) || i
}, Ei = function(t, e) {
    return (t = t.split(",")).forEach(e) || t
}, me = function(t) {
    return Math.round(t * 1e5) / 1e5 || 0
}, Le = function(t) {
    return Math.round(t * 1e7) / 1e7 || 0
}, Ro = function(t, e) {
    var i = e.charAt(0)
      , r = parseFloat(e.substr(2));
    return t = parseFloat(t),
    i === "+" ? t + r : i === "-" ? t - r : i === "*" ? t * r : t / r
}, jw = function(t, e) {
    for (var i = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < i; )
        ;
    return r < i
}, Eu = function() {
    var t = Vs.length, e = Vs.slice(0), i, r;
    for (rf = {},
    Vs.length = 0,
    i = 0; i < t; i++)
        r = e[i],
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0)
}, Gy = function(t, e, i, r) {
    Vs.length && !ei && Eu(),
    t.render(e, i, r || ei && e < 0 && (t._initted || t._startAt)),
    Vs.length && !ei && Eu()
}, Hy = function(t) {
    var e = parseFloat(t);
    return (e || e === 0) && (t + "").match(By).length < 2 ? e : Ge(t) ? t.trim() : t
}, $y = function(t) {
    return t
}, lr = function(t, e) {
    for (var i in e)
        i in t || (t[i] = e[i]);
    return t
}, qw = function(t) {
    return function(e, i) {
        for (var r in i)
            r in e || r === "duration" && t || r === "ease" || (e[r] = i[r])
    }
}, Hn = function(t, e) {
    for (var i in e)
        t[i] = e[i];
    return t
}, Tg = function s(t, e) {
    for (var i in e)
        i !== "__proto__" && i !== "constructor" && i !== "prototype" && (t[i] = ts(e[i]) ? s(t[i] || (t[i] = {}), e[i]) : e[i]);
    return t
}, Tu = function(t, e) {
    var i = {}, r;
    for (r in t)
        r in e || (i[r] = t[r]);
    return i
}, Wa = function(t) {
    var e = t.parent || le
      , i = t.keyframes ? qw(ii(t.keyframes)) : lr;
    if (wi(t.inherit))
        for (; e; )
            i(t, e.vars.defaults),
            e = e.parent || e._dp;
    return t
}, Yw = function(t, e) {
    for (var i = t.length, r = i === e.length; r && i-- && t[i] === e[i]; )
        ;
    return i < 0
}, zy = function(t, e, i, r, n) {
    i === void 0 && (i = "_first"),
    r === void 0 && (r = "_last");
    var o = t[r], a;
    if (n)
        for (a = e[n]; o && o[n] > a; )
            o = o._prev;
    return o ? (e._next = o._next,
    o._next = e) : (e._next = t[i],
    t[i] = e),
    e._next ? e._next._prev = e : t[r] = e,
    e._prev = o,
    e.parent = e._dp = t,
    e
}, mc = function(t, e, i, r) {
    i === void 0 && (i = "_first"),
    r === void 0 && (r = "_last");
    var n = e._prev
      , o = e._next;
    n ? n._next = o : t[i] === e && (t[i] = o),
    o ? o._prev = n : t[r] === e && (t[r] = n),
    e._next = e._prev = e.parent = null
}, Ys = function(t, e) {
    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t),
    t._act = 0
}, Cn = function(t, e) {
    if (t && (!e || e._end > t._dur || e._start < 0))
        for (var i = t; i; )
            i._dirty = 1,
            i = i.parent;
    return t
}, Kw = function(t) {
    for (var e = t.parent; e && e.parent; )
        e._dirty = 1,
        e.totalDuration(),
        e = e.parent;
    return t
}, sf = function(t, e, i, r) {
    return t._startAt && (ei ? t._startAt.revert(Kh) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, r))
}, Zw = function s(t) {
    return !t || t._ts && s(t.parent)
}, Dg = function(t) {
    return t._repeat ? jo(t._tTime, t = t.duration() + t._rDelay) * t : 0
}, jo = function(t, e) {
    var i = Math.floor(t /= e);
    return t && i === t ? i - 1 : i
}, Du = function(t, e) {
    return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
}, gc = function(t) {
    return t._end = Le(t._start + (t._tDur / Math.abs(t._ts || t._rts || Zt) || 0))
}, _c = function(t, e) {
    var i = t._dp;
    return i && i.smoothChildTiming && t._ts && (t._start = Le(i._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
    gc(t),
    i._dirty || Cn(i, t)),
    t
}, Vy = function(t, e) {
    var i;
    if ((e._time || !e._dur && e._initted || e._start < t._time && (e._dur || !e.add)) && (i = Du(t.rawTime(), e),
    (!e._dur || Xl(0, e.totalDuration(), i) - e._tTime > Zt) && e.render(i, !0)),
    Cn(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
        if (t._dur < t.duration())
            for (i = t; i._dp; )
                i.rawTime() >= 0 && i.totalTime(i._tTime),
                i = i._dp;
        t._zTime = -Zt
    }
}, zr = function(t, e, i, r) {
    return e.parent && Ys(e),
    e._start = Le((vs(i) ? i : i || t !== le ? qi(t, i, e) : t._time) + e._delay),
    e._end = Le(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
    zy(t, e, "_first", "_last", t._sort ? "_start" : 0),
    nf(e) || (t._recent = e),
    r || Vy(t, e),
    t._ts < 0 && _c(t, t._tTime),
    t
}, Xy = function(t, e) {
    return (Xi.ScrollTrigger || $p("scrollTrigger", e)) && Xi.ScrollTrigger.create(e, t)
}, Wy = function(t, e, i, r, n) {
    if (jp(t, e, n),
    !t._initted)
        return 1;
    if (!i && t._pt && !ei && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && Ny !== Li.frame)
        return Vs.push(t),
        t._lazy = [n, r],
        1
}, Qw = function s(t) {
    var e = t.parent;
    return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || s(e))
}, nf = function(t) {
    var e = t.data;
    return e === "isFromStart" || e === "isStart"
}, Jw = function(t, e, i, r) {
    var n = t.ratio, o = e < 0 || !e && (!t._start && Qw(t) && !(!t._initted && nf(t)) || (t._ts < 0 || t._dp._ts < 0) && !nf(t)) ? 0 : 1, a = t._rDelay, l = 0, h, u, c;
    if (a && t._repeat && (l = Xl(0, t._tDur, e),
    u = jo(l, a),
    t._yoyo && u & 1 && (o = 1 - o),
    u !== jo(t._tTime, a) && (n = 1 - o,
    t.vars.repeatRefresh && t._initted && t.invalidate())),
    o !== n || ei || r || t._zTime === Zt || !e && t._zTime) {
        if (!t._initted && Wy(t, e, r, i, l))
            return;
        for (c = t._zTime,
        t._zTime = e || (i ? Zt : 0),
        i || (i = e && !c),
        t.ratio = o,
        t._from && (o = 1 - o),
        t._time = 0,
        t._tTime = l,
        h = t._pt; h; )
            h.r(o, h.d),
            h = h._next;
        e < 0 && sf(t, e, i, !0),
        t._onUpdate && !i && Gi(t, "onUpdate"),
        l && t._repeat && !i && t.parent && Gi(t, "onRepeat"),
        (e >= t._tDur || e < 0) && t.ratio === o && (o && Ys(t, 1),
        !i && !ei && (Gi(t, o ? "onComplete" : "onReverseComplete", !0),
        t._prom && t._prom()))
    } else
        t._zTime || (t._zTime = e)
}, tE = function(t, e, i) {
    var r;
    if (i > e)
        for (r = t._first; r && r._start <= i; ) {
            if (r.data === "isPause" && r._start > e)
                return r;
            r = r._next
        }
    else
        for (r = t._last; r && r._start >= i; ) {
            if (r.data === "isPause" && r._start < e)
                return r;
            r = r._prev
        }
}, qo = function(t, e, i, r) {
    var n = t._repeat
      , o = Le(e) || 0
      , a = t._tTime / t._tDur;
    return a && !r && (t._time *= o / t._dur),
    t._dur = o,
    t._tDur = n ? n < 0 ? 1e10 : Le(o * (n + 1) + t._rDelay * n) : o,
    a > 0 && !r && _c(t, t._tTime = t._tDur * a),
    t.parent && gc(t),
    i || Cn(t.parent, t),
    t
}, Ag = function(t) {
    return t instanceof pi ? Cn(t) : qo(t, t._dur)
}, eE = {
    _start: 0,
    endTime: yl,
    totalDuration: yl
}, qi = function s(t, e, i) {
    var r = t.labels, n = t._recent || eE, o = t.duration() >= rr ? n.endTime(!1) : t._dur, a, l, h;
    return Ge(e) && (isNaN(e) || e in r) ? (l = e.charAt(0),
    h = e.substr(-1) === "%",
    a = e.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (e = e.replace(/=/, "")),
    (l === "<" ? n._start : n.endTime(n._repeat >= 0)) + (parseFloat(e.substr(1)) || 0) * (h ? (a < 0 ? n : i).totalDuration() / 100 : 1)) : a < 0 ? (e in r || (r[e] = o),
    r[e]) : (l = parseFloat(e.charAt(a - 1) + e.substr(a + 1)),
    h && i && (l = l / 100 * (ii(i) ? i[0] : i).totalDuration()),
    a > 1 ? s(t, e.substr(0, a - 1), i) + l : o + l)) : e == null ? o : +e
}, ja = function(t, e, i) {
    var r = vs(e[1]), n = (r ? 2 : 1) + (t < 2 ? 0 : 1), o = e[n], a, l;
    if (r && (o.duration = e[1]),
    o.parent = i,
    t) {
        for (a = o,
        l = i; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = wi(l.vars.inherit) && l.parent;
        o.immediateRender = wi(a.immediateRender),
        t < 2 ? o.runBackwards = 1 : o.startAt = e[n - 1]
    }
    return new be(e[0],o,e[n + 1])
}, en = function(t, e) {
    return t || t === 0 ? e(t) : e
}, Xl = function(t, e, i) {
    return i < t ? t : i > e ? e : i
}, Qe = function(t, e) {
    return !Ge(t) || !(e = Vw.exec(t)) ? "" : e[1]
}, iE = function(t, e, i) {
    return en(i, function(r) {
        return Xl(t, e, r)
    })
}, of = [].slice, jy = function(t, e) {
    return t && ts(t) && "length"in t && (!e && !t.length || t.length - 1 in t && ts(t[0])) && !t.nodeType && t !== Ki
}, rE = function(t, e, i) {
    return i === void 0 && (i = []),
    t.forEach(function(r) {
        var n;
        return Ge(r) && !e || jy(r, 1) ? (n = i).push.apply(n, sr(r)) : i.push(r)
    }) || i
}, sr = function(t, e, i) {
    return de && !e && de.selector ? de.selector(t) : Ge(t) && !i && (ef || !Yo()) ? of.call((e || Hp).querySelectorAll(t), 0) : ii(t) ? rE(t, i) : jy(t) ? of.call(t, 0) : t ? [t] : []
}, af = function(t) {
    return t = sr(t)[0] || _l("Invalid scope") || {},
    function(e) {
        var i = t.current || t.nativeElement || t;
        return sr(e, i.querySelectorAll ? i : i === t ? _l("Invalid scope") || Hp.createElement("div") : t)
    }
}, qy = function(t) {
    return t.sort(function() {
        return .5 - Math.random()
    })
}, Yy = function(t) {
    if (fe(t))
        return t;
    var e = ts(t) ? t : {
        each: t
    }
      , i = Pn(e.ease)
      , r = e.from || 0
      , n = parseFloat(e.base) || 0
      , o = {}
      , a = r > 0 && r < 1
      , l = isNaN(r) || a
      , h = e.axis
      , u = r
      , c = r;
    return Ge(r) ? u = c = {
        center: .5,
        edges: .5,
        end: 1
    }[r] || 0 : !a && l && (u = r[0],
    c = r[1]),
    function(d, f, p) {
        var m = (p || e).length, g = o[m], _, x, y, v, E, P, w, A, I;
        if (!g) {
            if (I = e.grid === "auto" ? 0 : (e.grid || [1, rr])[1],
            !I) {
                for (w = -rr; w < (w = p[I++].getBoundingClientRect().left) && I < m; )
                    ;
                I < m && I--
            }
            for (g = o[m] = [],
            _ = l ? Math.min(I, m) * u - .5 : r % I,
            x = I === rr ? 0 : l ? m * c / I - .5 : r / I | 0,
            w = 0,
            A = rr,
            P = 0; P < m; P++)
                y = P % I - _,
                v = x - (P / I | 0),
                g[P] = E = h ? Math.abs(h === "y" ? v : y) : Iy(y * y + v * v),
                E > w && (w = E),
                E < A && (A = E);
            r === "random" && qy(g),
            g.max = w - A,
            g.min = A,
            g.v = m = (parseFloat(e.amount) || parseFloat(e.each) * (I > m ? m - 1 : h ? h === "y" ? m / I : I : Math.max(I, m / I)) || 0) * (r === "edges" ? -1 : 1),
            g.b = m < 0 ? n - m : n,
            g.u = Qe(e.amount || e.each) || 0,
            i = i && m < 0 ? nv(i) : i
        }
        return m = (g[d] - g.min) / g.max || 0,
        Le(g.b + (i ? i(m) : m) * g.v) + g.u
    }
}, lf = function(t) {
    var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
    return function(i) {
        var r = Le(Math.round(parseFloat(i) / t) * t * e);
        return (r - r % 1) / e + (vs(i) ? 0 : Qe(i))
    }
}, Ky = function(t, e) {
    var i = ii(t), r, n;
    return !i && ts(t) && (r = i = t.radius || rr,
    t.values ? (t = sr(t.values),
    (n = !vs(t[0])) && (r *= r)) : t = lf(t.increment)),
    en(e, i ? fe(t) ? function(o) {
        return n = t(o),
        Math.abs(n - o) <= r ? n : o
    }
    : function(o) {
        for (var a = parseFloat(n ? o.x : o), l = parseFloat(n ? o.y : 0), h = rr, u = 0, c = t.length, d, f; c--; )
            n ? (d = t[c].x - a,
            f = t[c].y - l,
            d = d * d + f * f) : d = Math.abs(t[c] - a),
            d < h && (h = d,
            u = c);
        return u = !r || h <= r ? t[u] : o,
        n || u === o || vs(o) ? u : u + Qe(o)
    }
    : lf(t))
}, Zy = function(t, e, i, r) {
    return en(ii(t) ? !e : i === !0 ? !!(i = 0) : !r, function() {
        return ii(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (e - t + i * .99)) / i) * i * r) / r
    })
}, sE = function() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
        e[i] = arguments[i];
    return function(r) {
        return e.reduce(function(n, o) {
            return o(n)
        }, r)
    }
}, nE = function(t, e) {
    return function(i) {
        return t(parseFloat(i)) + (e || Qe(i))
    }
}, oE = function(t, e, i) {
    return Jy(t, e, 0, 1, i)
}, Qy = function(t, e, i) {
    return en(i, function(r) {
        return t[~~e(r)]
    })
}, aE = function s(t, e, i) {
    var r = e - t;
    return ii(t) ? Qy(t, s(0, t.length), e) : en(i, function(n) {
        return (r + (n - t) % r) % r + t
    })
}, lE = function s(t, e, i) {
    var r = e - t
      , n = r * 2;
    return ii(t) ? Qy(t, s(0, t.length - 1), e) : en(i, function(o) {
        return o = (n + (o - t) % n) % n || 0,
        t + (o > r ? n - o : o)
    })
}, vl = function(t) {
    for (var e = 0, i = "", r, n, o, a; ~(r = t.indexOf("random(", e)); )
        o = t.indexOf(")", r),
        a = t.charAt(r + 7) === "[",
        n = t.substr(r + 7, o - r - 7).match(a ? By : tf),
        i += t.substr(e, r - e) + Zy(a ? n : +n[0], a ? 0 : +n[1], +n[2] || 1e-5),
        e = o + 1;
    return i + t.substr(e, t.length - e)
}, Jy = function(t, e, i, r, n) {
    var o = e - t
      , a = r - i;
    return en(n, function(l) {
        return i + ((l - t) / o * a || 0)
    })
}, hE = function s(t, e, i, r) {
    var n = isNaN(t + e) ? 0 : function(f) {
        return (1 - f) * t + f * e
    }
    ;
    if (!n) {
        var o = Ge(t), a = {}, l, h, u, c, d;
        if (i === !0 && (r = 1) && (i = null),
        o)
            t = {
                p: t
            },
            e = {
                p: e
            };
        else if (ii(t) && !ii(e)) {
            for (u = [],
            c = t.length,
            d = c - 2,
            h = 1; h < c; h++)
                u.push(s(t[h - 1], t[h]));
            c--,
            n = function(p) {
                p *= c;
                var m = Math.min(d, ~~p);
                return u[m](p - m)
            }
            ,
            i = e
        } else
            r || (t = Hn(ii(t) ? [] : {}, t));
        if (!u) {
            for (l in e)
                Wp.call(a, t, l, "get", e[l]);
            n = function(p) {
                return Kp(p, a) || (o ? t.p : t)
            }
        }
    }
    return en(i, n)
}, Sg = function(t, e, i) {
    var r = t.labels, n = rr, o, a, l;
    for (o in r)
        a = r[o] - e,
        a < 0 == !!i && a && n > (a = Math.abs(a)) && (l = o,
        n = a);
    return l
}, Gi = function(t, e, i) {
    var r = t.vars, n = r[e], o = de, a = t._ctx, l, h, u;
    if (n)
        return l = r[e + "Params"],
        h = r.callbackScope || t,
        i && Vs.length && Eu(),
        a && (de = a),
        u = l ? n.apply(h, l) : n.call(h),
        de = o,
        u
}, Ca = function(t) {
    return Ys(t),
    t.scrollTrigger && t.scrollTrigger.kill(!!ei),
    t.progress() < 1 && Gi(t, "onInterrupt"),
    t
}, wo, tv = [], ev = function(t) {
    if (Gp() && t) {
        t = !t.name && t.default || t;
        var e = t.name
          , i = fe(t)
          , r = e && !i && t.init ? function() {
            this._props = []
        }
        : t
          , n = {
            init: yl,
            render: Kp,
            add: Wp,
            kill: DE,
            modifier: TE,
            rawVars: 0
        }
          , o = {
            targetTest: 0,
            get: 0,
            getSetter: Yp,
            aliases: {},
            register: 0
        };
        if (Yo(),
        t !== r) {
            if (ki[e])
                return;
            lr(r, lr(Tu(t, n), o)),
            Hn(r.prototype, Hn(n, Tu(t, o))),
            ki[r.prop = e] = r,
            t.targetTest && (Zh.push(r),
            zp[e] = 1),
            e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
        }
        Ly(e, r),
        t.register && t.register(Ai, r, Ti)
    } else
        t && tv.push(t)
}, Kt = 255, Pa = {
    aqua: [0, Kt, Kt],
    lime: [0, Kt, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Kt],
    navy: [0, 0, 128],
    white: [Kt, Kt, Kt],
    olive: [128, 128, 0],
    yellow: [Kt, Kt, 0],
    orange: [Kt, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Kt, 0, 0],
    pink: [Kt, 192, 203],
    cyan: [0, Kt, Kt],
    transparent: [Kt, Kt, Kt, 0]
}, $c = function(t, e, i) {
    return t += t < 0 ? 1 : t > 1 ? -1 : 0,
    (t * 6 < 1 ? e + (i - e) * t * 6 : t < .5 ? i : t * 3 < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * Kt + .5 | 0
}, iv = function(t, e, i) {
    var r = t ? vs(t) ? [t >> 16, t >> 8 & Kt, t & Kt] : 0 : Pa.black, n, o, a, l, h, u, c, d, f, p;
    if (!r) {
        if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)),
        Pa[t])
            r = Pa[t];
        else if (t.charAt(0) === "#") {
            if (t.length < 6 && (n = t.charAt(1),
            o = t.charAt(2),
            a = t.charAt(3),
            t = "#" + n + n + o + o + a + a + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")),
            t.length === 9)
                return r = parseInt(t.substr(1, 6), 16),
                [r >> 16, r >> 8 & Kt, r & Kt, parseInt(t.substr(7), 16) / 255];
            t = parseInt(t.substr(1), 16),
            r = [t >> 16, t >> 8 & Kt, t & Kt]
        } else if (t.substr(0, 3) === "hsl") {
            if (r = p = t.match(tf),
            !e)
                l = +r[0] % 360 / 360,
                h = +r[1] / 100,
                u = +r[2] / 100,
                o = u <= .5 ? u * (h + 1) : u + h - u * h,
                n = u * 2 - o,
                r.length > 3 && (r[3] *= 1),
                r[0] = $c(l + 1 / 3, n, o),
                r[1] = $c(l, n, o),
                r[2] = $c(l - 1 / 3, n, o);
            else if (~t.indexOf("="))
                return r = t.match(My),
                i && r.length < 4 && (r[3] = 1),
                r
        } else
            r = t.match(tf) || Pa.transparent;
        r = r.map(Number)
    }
    return e && !p && (n = r[0] / Kt,
    o = r[1] / Kt,
    a = r[2] / Kt,
    c = Math.max(n, o, a),
    d = Math.min(n, o, a),
    u = (c + d) / 2,
    c === d ? l = h = 0 : (f = c - d,
    h = u > .5 ? f / (2 - c - d) : f / (c + d),
    l = c === n ? (o - a) / f + (o < a ? 6 : 0) : c === o ? (a - n) / f + 2 : (n - o) / f + 4,
    l *= 60),
    r[0] = ~~(l + .5),
    r[1] = ~~(h * 100 + .5),
    r[2] = ~~(u * 100 + .5)),
    i && r.length < 4 && (r[3] = 1),
    r
}, rv = function(t) {
    var e = []
      , i = []
      , r = -1;
    return t.split(Xs).forEach(function(n) {
        var o = n.match(bo) || [];
        e.push.apply(e, o),
        i.push(r += o.length + 1)
    }),
    e.c = i,
    e
}, Cg = function(t, e, i) {
    var r = "", n = (t + r).match(Xs), o = e ? "hsla(" : "rgba(", a = 0, l, h, u, c;
    if (!n)
        return t;
    if (n = n.map(function(d) {
        return (d = iv(d, e, 1)) && o + (e ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
    }),
    i && (u = rv(t),
    l = i.c,
    l.join(r) !== u.c.join(r)))
        for (h = t.replace(Xs, "1").split(bo),
        c = h.length - 1; a < c; a++)
            r += h[a] + (~l.indexOf(a) ? n.shift() || o + "0,0,0,0)" : (u.length ? u : n.length ? n : i).shift());
    if (!h)
        for (h = t.split(Xs),
        c = h.length - 1; a < c; a++)
            r += h[a] + n[a];
    return r + h[c]
}, Xs = function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t;
    for (t in Pa)
        s += "|" + t + "\\b";
    return new RegExp(s + ")","gi")
}(), uE = /hsl[a]?\(/, sv = function(t) {
    var e = t.join(" "), i;
    if (Xs.lastIndex = 0,
    Xs.test(e))
        return i = uE.test(e),
        t[1] = Cg(t[1], i),
        t[0] = Cg(t[0], i, rv(t[1])),
        !0
}, xl, Li = function() {
    var s = Date.now, t = 500, e = 33, i = s(), r = i, n = 1e3 / 240, o = n, a = [], l, h, u, c, d, f, p = function m(g) {
        var _ = s() - r, x = g === !0, y, v, E, P;
        if (_ > t && (i += _ - e),
        r += _,
        E = r - i,
        y = E - o,
        (y > 0 || x) && (P = ++c.frame,
        d = E - c.time * 1e3,
        c.time = E = E / 1e3,
        o += y + (y >= n ? 4 : n - y),
        v = 1),
        x || (l = h(m)),
        v)
            for (f = 0; f < a.length; f++)
                a[f](E, d, P, g)
    };
    return c = {
        time: 0,
        frame: 0,
        tick: function() {
            p(!0)
        },
        deltaRatio: function(g) {
            return d / (1e3 / (g || 60))
        },
        wake: function() {
            Oy && (!ef && Gp() && (Ki = ef = window,
            Hp = Ki.document || {},
            Xi.gsap = Ai,
            (Ki.gsapVersions || (Ki.gsapVersions = [])).push(Ai.version),
            ky(wu || Ki.GreenSockGlobals || !Ki.gsap && Ki || {}),
            u = Ki.requestAnimationFrame,
            tv.forEach(ev)),
            l && c.sleep(),
            h = u || function(g) {
                return setTimeout(g, o - c.time * 1e3 + 1 | 0)
            }
            ,
            xl = 1,
            p(2))
        },
        sleep: function() {
            (u ? Ki.cancelAnimationFrame : clearTimeout)(l),
            xl = 0,
            h = yl
        },
        lagSmoothing: function(g, _) {
            t = g || 1 / 0,
            e = Math.min(_ || 33, t)
        },
        fps: function(g) {
            n = 1e3 / (g || 240),
            o = c.time * 1e3 + n
        },
        add: function(g, _, x) {
            var y = _ ? function(v, E, P, w) {
                g(v, E, P, w),
                c.remove(y)
            }
            : g;
            return c.remove(g),
            a[x ? "unshift" : "push"](y),
            Yo(),
            y
        },
        remove: function(g, _) {
            ~(_ = a.indexOf(g)) && a.splice(_, 1) && f >= _ && f--
        },
        _listeners: a
    },
    c
}(), Yo = function() {
    return !xl && Li.wake()
}, Gt = {}, cE = /^[\d.\-M][\d.\-,\s]/, dE = /["']/g, fE = function(t) {
    for (var e = {}, i = t.substr(1, t.length - 3).split(":"), r = i[0], n = 1, o = i.length, a, l, h; n < o; n++)
        l = i[n],
        a = n !== o - 1 ? l.lastIndexOf(",") : l.length,
        h = l.substr(0, a),
        e[r] = isNaN(h) ? h.replace(dE, "").trim() : +h,
        r = l.substr(a + 1).trim();
    return e
}, pE = function(t) {
    var e = t.indexOf("(") + 1
      , i = t.indexOf(")")
      , r = t.indexOf("(", e);
    return t.substring(e, ~r && r < i ? t.indexOf(")", i + 1) : i)
}, mE = function(t) {
    var e = (t + "").split("(")
      , i = Gt[e[0]];
    return i && e.length > 1 && i.config ? i.config.apply(null, ~t.indexOf("{") ? [fE(e[1])] : pE(t).split(",").map(Hy)) : Gt._CE && cE.test(t) ? Gt._CE("", t) : i
}, nv = function(t) {
    return function(e) {
        return 1 - t(1 - e)
    }
}, ov = function s(t, e) {
    for (var i = t._first, r; i; )
        i instanceof pi ? s(i, e) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== e && (i.timeline ? s(i.timeline, e) : (r = i._ease,
        i._ease = i._yEase,
        i._yEase = r,
        i._yoyo = e)),
        i = i._next
}, Pn = function(t, e) {
    return t && (fe(t) ? t : Gt[t] || mE(t)) || e
}, Kn = function(t, e, i, r) {
    i === void 0 && (i = function(l) {
        return 1 - e(1 - l)
    }
    ),
    r === void 0 && (r = function(l) {
        return l < .5 ? e(l * 2) / 2 : 1 - e((1 - l) * 2) / 2
    }
    );
    var n = {
        easeIn: e,
        easeOut: i,
        easeInOut: r
    }, o;
    return Ei(t, function(a) {
        Gt[a] = Xi[a] = n,
        Gt[o = a.toLowerCase()] = i;
        for (var l in n)
            Gt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Gt[a + "." + l] = n[l]
    }),
    n
}, av = function(t) {
    return function(e) {
        return e < .5 ? (1 - t(1 - e * 2)) / 2 : .5 + t((e - .5) * 2) / 2
    }
}, zc = function s(t, e, i) {
    var r = e >= 1 ? e : 1
      , n = (i || (t ? .3 : .45)) / (e < 1 ? e : 1)
      , o = n / Jd * (Math.asin(1 / r) || 0)
      , a = function(u) {
        return u === 1 ? 1 : r * Math.pow(2, -10 * u) * zw((u - o) * n) + 1
    }
      , l = t === "out" ? a : t === "in" ? function(h) {
        return 1 - a(1 - h)
    }
    : av(a);
    return n = Jd / n,
    l.config = function(h, u) {
        return s(t, h, u)
    }
    ,
    l
}, Vc = function s(t, e) {
    e === void 0 && (e = 1.70158);
    var i = function(o) {
        return o ? --o * o * ((e + 1) * o + e) + 1 : 0
    }
      , r = t === "out" ? i : t === "in" ? function(n) {
        return 1 - i(1 - n)
    }
    : av(i);
    return r.config = function(n) {
        return s(t, n)
    }
    ,
    r
};
Ei("Linear,Quad,Cubic,Quart,Quint,Strong", function(s, t) {
    var e = t < 5 ? t + 1 : t;
    Kn(s + ",Power" + (e - 1), t ? function(i) {
        return Math.pow(i, e)
    }
    : function(i) {
        return i
    }
    , function(i) {
        return 1 - Math.pow(1 - i, e)
    }, function(i) {
        return i < .5 ? Math.pow(i * 2, e) / 2 : 1 - Math.pow((1 - i) * 2, e) / 2
    })
});
Gt.Linear.easeNone = Gt.none = Gt.Linear.easeIn;
Kn("Elastic", zc("in"), zc("out"), zc());
(function(s, t) {
    var e = 1 / t
      , i = 2 * e
      , r = 2.5 * e
      , n = function(a) {
        return a < e ? s * a * a : a < i ? s * Math.pow(a - 1.5 / t, 2) + .75 : a < r ? s * (a -= 2.25 / t) * a + .9375 : s * Math.pow(a - 2.625 / t, 2) + .984375
    };
    Kn("Bounce", function(o) {
        return 1 - n(1 - o)
    }, n)
}
)(7.5625, 2.75);
Kn("Expo", function(s) {
    return s ? Math.pow(2, 10 * (s - 1)) : 0
});
Kn("Circ", function(s) {
    return -(Iy(1 - s * s) - 1)
});
Kn("Sine", function(s) {
    return s === 1 ? 1 : -$w(s * Gw) + 1
});
Kn("Back", Vc("in"), Vc("out"), Vc());
Gt.SteppedEase = Gt.steps = Xi.SteppedEase = {
    config: function(t, e) {
        t === void 0 && (t = 1);
        var i = 1 / t
          , r = t + (e ? 0 : 1)
          , n = e ? 1 : 0
          , o = 1 - Zt;
        return function(a) {
            return ((r * Xl(0, o, a) | 0) + n) * i
        }
    }
};
Wo.ease = Gt["quad.out"];
Ei("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(s) {
    return Vp += s + "," + s + "Params,"
});
var lv = function(t, e) {
    this.id = Hw++,
    t._gsap = this,
    this.target = t,
    this.harness = e,
    this.get = e ? e.get : Uy,
    this.set = e ? e.getSetter : Yp
}
  , bl = function() {
    function s(e) {
        this.vars = e,
        this._delay = +e.delay || 0,
        (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0,
        this._yoyo = !!e.yoyo || !!e.yoyoEase),
        this._ts = 1,
        qo(this, +e.duration, 1, 1),
        this.data = e.data,
        de && (this._ctx = de,
        de.data.push(this)),
        xl || Li.wake()
    }
    var t = s.prototype;
    return t.delay = function(i) {
        return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay),
        this._delay = i,
        this) : this._delay
    }
    ,
    t.duration = function(i) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
    }
    ,
    t.totalDuration = function(i) {
        return arguments.length ? (this._dirty = 0,
        qo(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    t.totalTime = function(i, r) {
        if (Yo(),
        !arguments.length)
            return this._tTime;
        var n = this._dp;
        if (n && n.smoothChildTiming && this._ts) {
            for (_c(this, i),
            !n._dp || n.parent || Vy(n, this); n && n.parent; )
                n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                n = n.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && zr(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === Zt || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i),
        Gy(this, i, r)),
        this
    }
    ,
    t.time = function(i, r) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + Dg(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time
    }
    ,
    t.totalProgress = function(i, r) {
        return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    }
    ,
    t.progress = function(i, r) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + Dg(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    }
    ,
    t.iteration = function(i, r) {
        var n = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (i - 1) * n, r) : this._repeat ? jo(this._tTime, n) + 1 : 1
    }
    ,
    t.timeScale = function(i, r) {
        if (!arguments.length)
            return this._rts === -Zt ? 0 : this._rts;
        if (this._rts === i)
            return this;
        var n = this.parent && this._ts ? Du(this.parent._time, this) : this._tTime;
        return this._rts = +i || 0,
        this._ts = this._ps || i === -Zt ? 0 : this._rts,
        this.totalTime(Xl(-Math.abs(this._delay), this._tDur, n), r !== !1),
        gc(this),
        Kw(this)
    }
    ,
    t.paused = function(i) {
        return arguments.length ? (this._ps !== i && (this._ps = i,
        i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (Yo(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Zt && (this._tTime -= Zt)))),
        this) : this._ps
    }
    ,
    t.startTime = function(i) {
        if (arguments.length) {
            this._start = i;
            var r = this.parent || this._dp;
            return r && (r._sort || !this.parent) && zr(r, this, i - this._delay),
            this
        }
        return this._start
    }
    ,
    t.endTime = function(i) {
        return this._start + (wi(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    t.rawTime = function(i) {
        var r = this.parent || this._dp;
        return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Du(r.rawTime(i), this) : this._tTime : this._tTime
    }
    ,
    t.revert = function(i) {
        i === void 0 && (i = Ww);
        var r = ei;
        return ei = i,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i),
        this.totalTime(-.01, i.suppressEvents)),
        this.data !== "nested" && i.kill !== !1 && this.kill(),
        ei = r,
        this
    }
    ,
    t.globalTime = function(i) {
        for (var r = this, n = arguments.length ? i : r.rawTime(); r; )
            n = r._start + n / (Math.abs(r._ts) || 1),
            r = r._dp;
        return !this.parent && this._sat ? this._sat.globalTime(i) : n
    }
    ,
    t.repeat = function(i) {
        return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i,
        Ag(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    t.repeatDelay = function(i) {
        if (arguments.length) {
            var r = this._time;
            return this._rDelay = i,
            Ag(this),
            r ? this.time(r) : this
        }
        return this._rDelay
    }
    ,
    t.yoyo = function(i) {
        return arguments.length ? (this._yoyo = i,
        this) : this._yoyo
    }
    ,
    t.seek = function(i, r) {
        return this.totalTime(qi(this, i), wi(r))
    }
    ,
    t.restart = function(i, r) {
        return this.play().totalTime(i ? -this._delay : 0, wi(r))
    }
    ,
    t.play = function(i, r) {
        return i != null && this.seek(i, r),
        this.reversed(!1).paused(!1)
    }
    ,
    t.reverse = function(i, r) {
        return i != null && this.seek(i || this.totalDuration(), r),
        this.reversed(!0).paused(!1)
    }
    ,
    t.pause = function(i, r) {
        return i != null && this.seek(i, r),
        this.paused(!0)
    }
    ,
    t.resume = function() {
        return this.paused(!1)
    }
    ,
    t.reversed = function(i) {
        return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -Zt : 0)),
        this) : this._rts < 0
    }
    ,
    t.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -Zt,
        this
    }
    ,
    t.isActive = function() {
        var i = this.parent || this._dp, r = this._start, n;
        return !!(!i || this._ts && this._initted && i.isActive() && (n = i.rawTime(!0)) >= r && n < this.endTime(!0) - Zt)
    }
    ,
    t.eventCallback = function(i, r, n) {
        var o = this.vars;
        return arguments.length > 1 ? (r ? (o[i] = r,
        n && (o[i + "Params"] = n),
        i === "onUpdate" && (this._onUpdate = r)) : delete o[i],
        this) : o[i]
    }
    ,
    t.then = function(i) {
        var r = this;
        return new Promise(function(n) {
            var o = fe(i) ? i : $y
              , a = function() {
                var h = r.then;
                r.then = null,
                fe(o) && (o = o(r)) && (o.then || o === r) && (r.then = h),
                n(o),
                r.then = h
            };
            r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? a() : r._prom = a
        }
        )
    }
    ,
    t.kill = function() {
        Ca(this)
    }
    ,
    s
}();
lr(bl.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Zt,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var pi = function(s) {
    Py(t, s);
    function t(i, r) {
        var n;
        return i === void 0 && (i = {}),
        n = s.call(this, i) || this,
        n.labels = {},
        n.smoothChildTiming = !!i.smoothChildTiming,
        n.autoRemoveChildren = !!i.autoRemoveChildren,
        n._sort = wi(i.sortChildren),
        le && zr(i.parent || le, as(n), r),
        i.reversed && n.reverse(),
        i.paused && n.paused(!0),
        i.scrollTrigger && Xy(as(n), i.scrollTrigger),
        n
    }
    var e = t.prototype;
    return e.to = function(r, n, o) {
        return ja(0, arguments, this),
        this
    }
    ,
    e.from = function(r, n, o) {
        return ja(1, arguments, this),
        this
    }
    ,
    e.fromTo = function(r, n, o, a) {
        return ja(2, arguments, this),
        this
    }
    ,
    e.set = function(r, n, o) {
        return n.duration = 0,
        n.parent = this,
        Wa(n).repeatDelay || (n.repeat = 0),
        n.immediateRender = !!n.immediateRender,
        new be(r,n,qi(this, o),1),
        this
    }
    ,
    e.call = function(r, n, o) {
        return zr(this, be.delayedCall(0, r, n), o)
    }
    ,
    e.staggerTo = function(r, n, o, a, l, h, u) {
        return o.duration = n,
        o.stagger = o.stagger || a,
        o.onComplete = h,
        o.onCompleteParams = u,
        o.parent = this,
        new be(r,o,qi(this, l)),
        this
    }
    ,
    e.staggerFrom = function(r, n, o, a, l, h, u) {
        return o.runBackwards = 1,
        Wa(o).immediateRender = wi(o.immediateRender),
        this.staggerTo(r, n, o, a, l, h, u)
    }
    ,
    e.staggerFromTo = function(r, n, o, a, l, h, u, c) {
        return a.startAt = o,
        Wa(a).immediateRender = wi(a.immediateRender),
        this.staggerTo(r, n, a, l, h, u, c)
    }
    ,
    e.render = function(r, n, o) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, h = this._dur, u = r <= 0 ? 0 : Le(r), c = this._zTime < 0 != r < 0 && (this._initted || !h), d, f, p, m, g, _, x, y, v, E, P, w;
        if (this !== le && u > l && r >= 0 && (u = l),
        u !== this._tTime || o || c) {
            if (a !== this._time && h && (u += this._time - a,
            r += this._time - a),
            d = u,
            v = this._start,
            y = this._ts,
            _ = !y,
            c && (h || (a = this._zTime),
            (r || !n) && (this._zTime = r)),
            this._repeat) {
                if (P = this._yoyo,
                g = h + this._rDelay,
                this._repeat < -1 && r < 0)
                    return this.totalTime(g * 100 + r, n, o);
                if (d = Le(u % g),
                u === l ? (m = this._repeat,
                d = h) : (m = ~~(u / g),
                m && m === u / g && (d = h,
                m--),
                d > h && (d = h)),
                E = jo(this._tTime, g),
                !a && this._tTime && E !== m && this._tTime - E * g - this._dur <= 0 && (E = m),
                P && m & 1 && (d = h - d,
                w = 1),
                m !== E && !this._lock) {
                    var A = P && E & 1
                      , I = A === (P && m & 1);
                    if (m < E && (A = !A),
                    a = A ? 0 : u % h ? h : u,
                    this._lock = 1,
                    this.render(a || (w ? 0 : Le(m * g)), n, !h)._lock = 0,
                    this._tTime = u,
                    !n && this.parent && Gi(this, "onRepeat"),
                    this.vars.repeatRefresh && !w && (this.invalidate()._lock = 1),
                    a && a !== this._time || _ !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (h = this._dur,
                    l = this._tDur,
                    I && (this._lock = 2,
                    a = A ? h : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !w && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !_)
                        return this;
                    ov(this, w)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (x = tE(this, Le(a), Le(d)),
            x && (u -= d - (d = x._start))),
            this._tTime = u,
            this._time = d,
            this._act = !y,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = r,
            a = 0),
            !a && d && !n && !m && (Gi(this, "onStart"),
            this._tTime !== u))
                return this;
            if (d >= a && r >= 0)
                for (f = this._first; f; ) {
                    if (p = f._next,
                    (f._act || d >= f._start) && f._ts && x !== f) {
                        if (f.parent !== this)
                            return this.render(r, n, o);
                        if (f.render(f._ts > 0 ? (d - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (d - f._start) * f._ts, n, o),
                        d !== this._time || !this._ts && !_) {
                            x = 0,
                            p && (u += this._zTime = -Zt);
                            break
                        }
                    }
                    f = p
                }
            else {
                f = this._last;
                for (var F = r < 0 ? r : d; f; ) {
                    if (p = f._prev,
                    (f._act || F <= f._end) && f._ts && x !== f) {
                        if (f.parent !== this)
                            return this.render(r, n, o);
                        if (f.render(f._ts > 0 ? (F - f._start) * f._ts : (f._dirty ? f.totalDuration() : f._tDur) + (F - f._start) * f._ts, n, o || ei && (f._initted || f._startAt)),
                        d !== this._time || !this._ts && !_) {
                            x = 0,
                            p && (u += this._zTime = F ? -Zt : Zt);
                            break
                        }
                    }
                    f = p
                }
            }
            if (x && !n && (this.pause(),
            x.render(d >= a ? 0 : -Zt)._zTime = d >= a ? 1 : -1,
            this._ts))
                return this._start = v,
                gc(this),
                this.render(r, n, o);
            this._onUpdate && !n && Gi(this, "onUpdate", !0),
            (u === l && this._tTime >= this.totalDuration() || !u && a) && (v === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((r || !h) && (u === l && this._ts > 0 || !u && this._ts < 0) && Ys(this, 1),
            !n && !(r < 0 && !a) && (u || a || !l) && (Gi(this, u === l && r >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    e.add = function(r, n) {
        var o = this;
        if (vs(n) || (n = qi(this, n, r)),
        !(r instanceof bl)) {
            if (ii(r))
                return r.forEach(function(a) {
                    return o.add(a, n)
                }),
                this;
            if (Ge(r))
                return this.addLabel(r, n);
            if (fe(r))
                r = be.delayedCall(0, r);
            else
                return this
        }
        return this !== r ? zr(this, r, n) : this
    }
    ,
    e.getChildren = function(r, n, o, a) {
        r === void 0 && (r = !0),
        n === void 0 && (n = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -rr);
        for (var l = [], h = this._first; h; )
            h._start >= a && (h instanceof be ? n && l.push(h) : (o && l.push(h),
            r && l.push.apply(l, h.getChildren(!0, n, o)))),
            h = h._next;
        return l
    }
    ,
    e.getById = function(r) {
        for (var n = this.getChildren(1, 1, 1), o = n.length; o--; )
            if (n[o].vars.id === r)
                return n[o]
    }
    ,
    e.remove = function(r) {
        return Ge(r) ? this.removeLabel(r) : fe(r) ? this.killTweensOf(r) : (mc(this, r),
        r === this._recent && (this._recent = this._last),
        Cn(this))
    }
    ,
    e.totalTime = function(r, n) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = Le(Li.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))),
        s.prototype.totalTime.call(this, r, n),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    e.addLabel = function(r, n) {
        return this.labels[r] = qi(this, n),
        this
    }
    ,
    e.removeLabel = function(r) {
        return delete this.labels[r],
        this
    }
    ,
    e.addPause = function(r, n, o) {
        var a = be.delayedCall(0, n || yl, o);
        return a.data = "isPause",
        this._hasPause = 1,
        zr(this, a, qi(this, r))
    }
    ,
    e.removePause = function(r) {
        var n = this._first;
        for (r = qi(this, r); n; )
            n._start === r && n.data === "isPause" && Ys(n),
            n = n._next
    }
    ,
    e.killTweensOf = function(r, n, o) {
        for (var a = this.getTweensOf(r, o), l = a.length; l--; )
            Ls !== a[l] && a[l].kill(r, n);
        return this
    }
    ,
    e.getTweensOf = function(r, n) {
        for (var o = [], a = sr(r), l = this._first, h = vs(n), u; l; )
            l instanceof be ? jw(l._targets, a) && (h ? (!Ls || l._initted && l._ts) && l.globalTime(0) <= n && l.globalTime(l.totalDuration()) > n : !n || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, n)).length && o.push.apply(o, u),
            l = l._next;
        return o
    }
    ,
    e.tweenTo = function(r, n) {
        n = n || {};
        var o = this, a = qi(o, r), l = n, h = l.startAt, u = l.onStart, c = l.onStartParams, d = l.immediateRender, f, p = be.to(o, lr({
            ease: n.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: n.duration || Math.abs((a - (h && "time"in h ? h.time : o._time)) / o.timeScale()) || Zt,
            onStart: function() {
                if (o.pause(),
                !f) {
                    var g = n.duration || Math.abs((a - (h && "time"in h ? h.time : o._time)) / o.timeScale());
                    p._dur !== g && qo(p, g, 0, 1).render(p._time, !0, !0),
                    f = 1
                }
                u && u.apply(p, c || [])
            }
        }, n));
        return d ? p.render(0) : p
    }
    ,
    e.tweenFromTo = function(r, n, o) {
        return this.tweenTo(n, lr({
            startAt: {
                time: qi(this, r)
            }
        }, o))
    }
    ,
    e.recent = function() {
        return this._recent
    }
    ,
    e.nextLabel = function(r) {
        return r === void 0 && (r = this._time),
        Sg(this, qi(this, r))
    }
    ,
    e.previousLabel = function(r) {
        return r === void 0 && (r = this._time),
        Sg(this, qi(this, r), 1)
    }
    ,
    e.currentLabel = function(r) {
        return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + Zt)
    }
    ,
    e.shiftChildren = function(r, n, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, h; a; )
            a._start >= o && (a._start += r,
            a._end += r),
            a = a._next;
        if (n)
            for (h in l)
                l[h] >= o && (l[h] += r);
        return Cn(this)
    }
    ,
    e.invalidate = function(r) {
        var n = this._first;
        for (this._lock = 0; n; )
            n.invalidate(r),
            n = n._next;
        return s.prototype.invalidate.call(this, r)
    }
    ,
    e.clear = function(r) {
        r === void 0 && (r = !0);
        for (var n = this._first, o; n; )
            o = n._next,
            this.remove(n),
            n = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        Cn(this)
    }
    ,
    e.totalDuration = function(r) {
        var n = 0, o = this, a = o._last, l = rr, h, u, c;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r));
        if (o._dirty) {
            for (c = o.parent; a; )
                h = a._prev,
                a._dirty && a.totalDuration(),
                u = a._start,
                u > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                zr(o, a, u - a._delay, 1)._lock = 0) : l = u,
                u < 0 && a._ts && (n -= u,
                (!c && !o._dp || c && c.smoothChildTiming) && (o._start += u / o._ts,
                o._time -= u,
                o._tTime -= u),
                o.shiftChildren(-u, !1, -1 / 0),
                l = 0),
                a._end > n && a._ts && (n = a._end),
                a = h;
            qo(o, o === le && o._time > n ? o._time : n, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    t.updateRoot = function(r) {
        if (le._ts && (Gy(le, Du(r, le)),
        Ny = Li.frame),
        Li.frame >= Eg) {
            Eg += $i.autoSleep || 120;
            var n = le._first;
            if ((!n || !n._ts) && $i.autoSleep && Li._listeners.length < 2) {
                for (; n && !n._ts; )
                    n = n._next;
                n || Li.sleep()
            }
        }
    }
    ,
    t
}(bl);
lr(pi.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var gE = function(t, e, i, r, n, o, a) {
    var l = new Ti(this._pt,t,e,0,1,pv,null,n), h = 0, u = 0, c, d, f, p, m, g, _, x;
    for (l.b = i,
    l.e = r,
    i += "",
    r += "",
    (_ = ~r.indexOf("random(")) && (r = vl(r)),
    o && (x = [i, r],
    o(x, t, e),
    i = x[0],
    r = x[1]),
    d = i.match(Gc) || []; c = Gc.exec(r); )
        p = c[0],
        m = r.substring(h, c.index),
        f ? f = (f + 1) % 5 : m.substr(-5) === "rgba(" && (f = 1),
        p !== d[u++] && (g = parseFloat(d[u - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: m || u === 1 ? m : ",",
            s: g,
            c: p.charAt(1) === "=" ? Ro(g, p) - g : parseFloat(p) - g,
            m: f && f < 4 ? Math.round : 0
        },
        h = Gc.lastIndex);
    return l.c = h < r.length ? r.substring(h, r.length) : "",
    l.fp = a,
    (Fy.test(r) || _) && (l.e = 0),
    this._pt = l,
    l
}, Wp = function(t, e, i, r, n, o, a, l, h, u) {
    fe(r) && (r = r(n || 0, t, o));
    var c = t[e], d = i !== "get" ? i : fe(c) ? h ? t[e.indexOf("set") || !fe(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](h) : t[e]() : c, f = fe(c) ? h ? bE : dv : qp, p;
    if (Ge(r) && (~r.indexOf("random(") && (r = vl(r)),
    r.charAt(1) === "=" && (p = Ro(d, r) + (Qe(d) || 0),
    (p || p === 0) && (r = p))),
    !u || d !== r || hf)
        return !isNaN(d * r) && r !== "" ? (p = new Ti(this._pt,t,e,+d || 0,r - (d || 0),typeof c == "boolean" ? EE : fv,0,f),
        h && (p.fp = h),
        a && p.modifier(a, this, t),
        this._pt = p) : (!c && !(e in t) && $p(e, r),
        gE.call(this, t, e, d, r, f, l || $i.stringFilter, h))
}, _E = function(t, e, i, r, n) {
    if (fe(t) && (t = qa(t, n, e, i, r)),
    !ts(t) || t.style && t.nodeType || ii(t) || Ry(t))
        return Ge(t) ? qa(t, n, e, i, r) : t;
    var o = {}, a;
    for (a in t)
        o[a] = qa(t[a], n, e, i, r);
    return o
}, hv = function(t, e, i, r, n, o) {
    var a, l, h, u;
    if (ki[t] && (a = new ki[t]).init(n, a.rawVars ? e[t] : _E(e[t], r, n, o, i), i, r, o) !== !1 && (i._pt = l = new Ti(i._pt,n,t,0,1,a.render,a,0,a.priority),
    i !== wo))
        for (h = i._ptLookup[i._targets.indexOf(n)],
        u = a._props.length; u--; )
            h[a._props[u]] = l;
    return a
}, Ls, hf, jp = function s(t, e, i) {
    var r = t.vars, n = r.ease, o = r.startAt, a = r.immediateRender, l = r.lazy, h = r.onUpdate, u = r.runBackwards, c = r.yoyoEase, d = r.keyframes, f = r.autoRevert, p = t._dur, m = t._startAt, g = t._targets, _ = t.parent, x = _ && _.data === "nested" ? _.vars.targets : g, y = t._overwrite === "auto" && !Np, v = t.timeline, E, P, w, A, I, F, O, B, S, T, M, D, C;
    if (v && (!d || !n) && (n = "none"),
    t._ease = Pn(n, Wo.ease),
    t._yEase = c ? nv(Pn(c === !0 ? n : c, Wo.ease)) : 0,
    c && t._yoyo && !t._repeat && (c = t._yEase,
    t._yEase = t._ease,
    t._ease = c),
    t._from = !v && !!r.runBackwards,
    !v || d && !r.stagger) {
        if (B = g[0] ? Sn(g[0]).harness : 0,
        D = B && r[B.prop],
        E = Tu(r, zp),
        m && (m._zTime < 0 && m.progress(1),
        e < 0 && u && a && !f ? m.render(-1, !0) : m.revert(u && p ? Kh : Xw),
        m._lazy = 0),
        o) {
            if (Ys(t._startAt = be.set(g, lr({
                data: "isStart",
                overwrite: !1,
                parent: _,
                immediateRender: !0,
                lazy: !m && wi(l),
                startAt: null,
                delay: 0,
                onUpdate: h && function() {
                    return Gi(t, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            t._startAt._dp = 0,
            t._startAt._sat = t,
            e < 0 && (ei || !a && !f) && t._startAt.revert(Kh),
            a && p && e <= 0 && i <= 0) {
                e && (t._zTime = e);
                return
            }
        } else if (u && p && !m) {
            if (e && (a = !1),
            w = lr({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !m && wi(l),
                immediateRender: a,
                stagger: 0,
                parent: _
            }, E),
            D && (w[B.prop] = D),
            Ys(t._startAt = be.set(g, w)),
            t._startAt._dp = 0,
            t._startAt._sat = t,
            e < 0 && (ei ? t._startAt.revert(Kh) : t._startAt.render(-1, !0)),
            t._zTime = e,
            !a)
                s(t._startAt, Zt, Zt);
            else if (!e)
                return
        }
        for (t._pt = t._ptCache = 0,
        l = p && wi(l) || l && !p,
        P = 0; P < g.length; P++) {
            if (I = g[P],
            O = I._gsap || Xp(g)[P]._gsap,
            t._ptLookup[P] = T = {},
            rf[O.id] && Vs.length && Eu(),
            M = x === g ? P : x.indexOf(I),
            B && (S = new B).init(I, D || E, t, M, x) !== !1 && (t._pt = A = new Ti(t._pt,I,S.name,0,1,S.render,S,0,S.priority),
            S._props.forEach(function(k) {
                T[k] = A
            }),
            S.priority && (F = 1)),
            !B || D)
                for (w in E)
                    ki[w] && (S = hv(w, E, t, M, I, x)) ? S.priority && (F = 1) : T[w] = A = Wp.call(t, I, w, "get", E[w], M, x, 0, r.stringFilter);
            t._op && t._op[P] && t.kill(I, t._op[P]),
            y && t._pt && (Ls = t,
            le.killTweensOf(I, T, t.globalTime(e)),
            C = !t.parent,
            Ls = 0),
            t._pt && l && (rf[O.id] = 1)
        }
        F && mv(t),
        t._onInit && t._onInit(t)
    }
    t._onUpdate = h,
    t._initted = (!t._op || t._pt) && !C,
    d && e <= 0 && v.render(rr, !0, !0)
}, yE = function(t, e, i, r, n, o, a, l) {
    var h = (t._pt && t._ptCache || (t._ptCache = {}))[e], u, c, d, f;
    if (!h)
        for (h = t._ptCache[e] = [],
        d = t._ptLookup,
        f = t._targets.length; f--; ) {
            if (u = d[f][e],
            u && u.d && u.d._pt)
                for (u = u.d._pt; u && u.p !== e && u.fp !== e; )
                    u = u._next;
            if (!u)
                return hf = 1,
                t.vars[e] = "+=0",
                jp(t, a),
                hf = 0,
                l ? _l(e + " not eligible for reset") : 1;
            h.push(u)
        }
    for (f = h.length; f--; )
        c = h[f],
        u = c._pt || c,
        u.s = (r || r === 0) && !n ? r : u.s + (r || 0) + o * u.c,
        u.c = i - u.s,
        c.e && (c.e = me(i) + Qe(c.e)),
        c.b && (c.b = u.s + Qe(c.b))
}, vE = function(t, e) {
    var i = t[0] ? Sn(t[0]).harness : 0, r = i && i.aliases, n, o, a, l;
    if (!r)
        return e;
    n = Hn({}, e);
    for (o in r)
        if (o in n)
            for (l = r[o].split(","),
            a = l.length; a--; )
                n[l[a]] = n[o];
    return n
}, xE = function(t, e, i, r) {
    var n = e.ease || r || "power1.inOut", o, a;
    if (ii(e))
        a = i[t] || (i[t] = []),
        e.forEach(function(l, h) {
            return a.push({
                t: h / (e.length - 1) * 100,
                v: l,
                e: n
            })
        });
    else
        for (o in e)
            a = i[o] || (i[o] = []),
            o === "ease" || a.push({
                t: parseFloat(t),
                v: e[o],
                e: n
            })
}, qa = function(t, e, i, r, n) {
    return fe(t) ? t.call(e, i, r, n) : Ge(t) && ~t.indexOf("random(") ? vl(t) : t
}, uv = Vp + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", cv = {};
Ei(uv + ",id,stagger,delay,duration,paused,scrollTrigger", function(s) {
    return cv[s] = 1
});
var be = function(s) {
    Py(t, s);
    function t(i, r, n, o) {
        var a;
        typeof r == "number" && (n.duration = r,
        r = n,
        n = null),
        a = s.call(this, o ? r : Wa(r)) || this;
        var l = a.vars, h = l.duration, u = l.delay, c = l.immediateRender, d = l.stagger, f = l.overwrite, p = l.keyframes, m = l.defaults, g = l.scrollTrigger, _ = l.yoyoEase, x = r.parent || le, y = (ii(i) || Ry(i) ? vs(i[0]) : "length"in r) ? [i] : sr(i), v, E, P, w, A, I, F, O;
        if (a._targets = y.length ? Xp(y) : _l("GSAP target " + i + " not found. https://gsap.com", !$i.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = f,
        p || d || nh(h) || nh(u)) {
            if (r = a.vars,
            v = a.timeline = new pi({
                data: "nested",
                defaults: m || {},
                targets: x && x.data === "nested" ? x.vars.targets : y
            }),
            v.kill(),
            v.parent = v._dp = as(a),
            v._start = 0,
            d || nh(h) || nh(u)) {
                if (w = y.length,
                F = d && Yy(d),
                ts(d))
                    for (A in d)
                        ~uv.indexOf(A) && (O || (O = {}),
                        O[A] = d[A]);
                for (E = 0; E < w; E++)
                    P = Tu(r, cv),
                    P.stagger = 0,
                    _ && (P.yoyoEase = _),
                    O && Hn(P, O),
                    I = y[E],
                    P.duration = +qa(h, as(a), E, I, y),
                    P.delay = (+qa(u, as(a), E, I, y) || 0) - a._delay,
                    !d && w === 1 && P.delay && (a._delay = u = P.delay,
                    a._start += u,
                    P.delay = 0),
                    v.to(I, P, F ? F(E, I, y) : 0),
                    v._ease = Gt.none;
                v.duration() ? h = u = 0 : a.timeline = 0
            } else if (p) {
                Wa(lr(v.vars.defaults, {
                    ease: "none"
                })),
                v._ease = Pn(p.ease || r.ease || "none");
                var B = 0, S, T, M;
                if (ii(p))
                    p.forEach(function(D) {
                        return v.to(y, D, ">")
                    }),
                    v.duration();
                else {
                    P = {};
                    for (A in p)
                        A === "ease" || A === "easeEach" || xE(A, p[A], P, p.easeEach);
                    for (A in P)
                        for (S = P[A].sort(function(D, C) {
                            return D.t - C.t
                        }),
                        B = 0,
                        E = 0; E < S.length; E++)
                            T = S[E],
                            M = {
                                ease: T.e,
                                duration: (T.t - (E ? S[E - 1].t : 0)) / 100 * h
                            },
                            M[A] = T.v,
                            v.to(y, M, B),
                            B += M.duration;
                    v.duration() < h && v.to({}, {
                        duration: h - v.duration()
                    })
                }
            }
            h || a.duration(h = v.duration())
        } else
            a.timeline = 0;
        return f === !0 && !Np && (Ls = as(a),
        le.killTweensOf(y),
        Ls = 0),
        zr(x, as(a), n),
        r.reversed && a.reverse(),
        r.paused && a.paused(!0),
        (c || !h && !p && a._start === Le(x._time) && wi(c) && Zw(as(a)) && x.data !== "nested") && (a._tTime = -Zt,
        a.render(Math.max(0, -u) || 0)),
        g && Xy(as(a), g),
        a
    }
    var e = t.prototype;
    return e.render = function(r, n, o) {
        var a = this._time, l = this._tDur, h = this._dur, u = r < 0, c = r > l - Zt && !u ? l : r < Zt ? 0 : r, d, f, p, m, g, _, x, y, v;
        if (!h)
            Jw(this, r, n, o);
        else if (c !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
            if (d = c,
            y = this.timeline,
            this._repeat) {
                if (m = h + this._rDelay,
                this._repeat < -1 && u)
                    return this.totalTime(m * 100 + r, n, o);
                if (d = Le(c % m),
                c === l ? (p = this._repeat,
                d = h) : (p = ~~(c / m),
                p && p === Le(c / m) && (d = h,
                p--),
                d > h && (d = h)),
                _ = this._yoyo && p & 1,
                _ && (v = this._yEase,
                d = h - d),
                g = jo(this._tTime, m),
                d === a && !o && this._initted && p === g)
                    return this._tTime = c,
                    this;
                p !== g && (y && this._yEase && ov(y, _),
                this.vars.repeatRefresh && !_ && !this._lock && this._time !== h && this._initted && (this._lock = o = 1,
                this.render(Le(m * p), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (Wy(this, u ? r : d, o, n, c))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && p !== g))
                    return this;
                if (h !== this._dur)
                    return this.render(r, n, o)
            }
            if (this._tTime = c,
            this._time = d,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = x = (v || this._ease)(d / h),
            this._from && (this.ratio = x = 1 - x),
            d && !a && !n && !p && (Gi(this, "onStart"),
            this._tTime !== c))
                return this;
            for (f = this._pt; f; )
                f.r(x, f.d),
                f = f._next;
            y && y.render(r < 0 ? r : !d && _ ? -Zt : y._dur * y._ease(d / this._dur), n, o) || this._startAt && (this._zTime = r),
            this._onUpdate && !n && (u && sf(this, r, n, o),
            Gi(this, "onUpdate")),
            this._repeat && p !== g && this.vars.onRepeat && !n && this.parent && Gi(this, "onRepeat"),
            (c === this._tDur || !c) && this._tTime === c && (u && !this._onUpdate && sf(this, r, !0, !0),
            (r || !h) && (c === this._tDur && this._ts > 0 || !c && this._ts < 0) && Ys(this, 1),
            !n && !(u && !a) && (c || a || _) && (Gi(this, c === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(c < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    e.targets = function() {
        return this._targets
    }
    ,
    e.invalidate = function(r) {
        return (!r || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(r),
        s.prototype.invalidate.call(this, r)
    }
    ,
    e.resetTo = function(r, n, o, a, l) {
        xl || Li.wake(),
        this._ts || this.play();
        var h = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
        return this._initted || jp(this, h),
        u = this._ease(h / this._dur),
        yE(this, r, n, o, a, u, h, l) ? this.resetTo(r, n, o, a, 1) : (_c(this, 0),
        this.parent || zy(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    e.kill = function(r, n) {
        if (n === void 0 && (n = "all"),
        !r && (!n || n === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? Ca(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(r, n, Ls && Ls.vars.overwrite !== !0)._first || Ca(this),
            this.parent && o !== this.timeline.totalDuration() && qo(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, l = r ? sr(r) : a, h = this._ptLookup, u = this._pt, c, d, f, p, m, g, _;
        if ((!n || n === "all") && Yw(a, l))
            return n === "all" && (this._pt = 0),
            Ca(this);
        for (c = this._op = this._op || [],
        n !== "all" && (Ge(n) && (m = {},
        Ei(n, function(x) {
            return m[x] = 1
        }),
        n = m),
        n = vE(a, n)),
        _ = a.length; _--; )
            if (~l.indexOf(a[_])) {
                d = h[_],
                n === "all" ? (c[_] = n,
                p = d,
                f = {}) : (f = c[_] = c[_] || {},
                p = n);
                for (m in p)
                    g = d && d[m],
                    g && ((!("kill"in g.d) || g.d.kill(m) === !0) && mc(this, g, "_pt"),
                    delete d[m]),
                    f !== "all" && (f[m] = 1)
            }
        return this._initted && !this._pt && u && Ca(this),
        this
    }
    ,
    t.to = function(r, n) {
        return new t(r,n,arguments[2])
    }
    ,
    t.from = function(r, n) {
        return ja(1, arguments)
    }
    ,
    t.delayedCall = function(r, n, o, a) {
        return new t(n,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: r,
            onComplete: n,
            onReverseComplete: n,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    t.fromTo = function(r, n, o) {
        return ja(2, arguments)
    }
    ,
    t.set = function(r, n) {
        return n.duration = 0,
        n.repeatDelay || (n.repeat = 0),
        new t(r,n)
    }
    ,
    t.killTweensOf = function(r, n, o) {
        return le.killTweensOf(r, n, o)
    }
    ,
    t
}(bl);
lr(be.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
Ei("staggerTo,staggerFrom,staggerFromTo", function(s) {
    be[s] = function() {
        var t = new pi
          , e = of.call(arguments, 0);
        return e.splice(s === "staggerFromTo" ? 5 : 4, 0, 0),
        t[s].apply(t, e)
    }
});
var qp = function(t, e, i) {
    return t[e] = i
}
  , dv = function(t, e, i) {
    return t[e](i)
}
  , bE = function(t, e, i, r) {
    return t[e](r.fp, i)
}
  , wE = function(t, e, i) {
    return t.setAttribute(e, i)
}
  , Yp = function(t, e) {
    return fe(t[e]) ? dv : Up(t[e]) && t.setAttribute ? wE : qp
}
  , fv = function(t, e) {
    return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e6) / 1e6, e)
}
  , EE = function(t, e) {
    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
}
  , pv = function(t, e) {
    var i = e._pt
      , r = "";
    if (!t && e.b)
        r = e.b;
    else if (t === 1 && e.e)
        r = e.e;
    else {
        for (; i; )
            r = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round((i.s + i.c * t) * 1e4) / 1e4) + r,
            i = i._next;
        r += e.c
    }
    e.set(e.t, e.p, r, e)
}
  , Kp = function(t, e) {
    for (var i = e._pt; i; )
        i.r(t, i.d),
        i = i._next
}
  , TE = function(t, e, i, r) {
    for (var n = this._pt, o; n; )
        o = n._next,
        n.p === r && n.modifier(t, e, i),
        n = o
}
  , DE = function(t) {
    for (var e = this._pt, i, r; e; )
        r = e._next,
        e.p === t && !e.op || e.op === t ? mc(this, e, "_pt") : e.dep || (i = 1),
        e = r;
    return !i
}
  , AE = function(t, e, i, r) {
    r.mSet(t, e, r.m.call(r.tween, i, r.mt), r)
}
  , mv = function(t) {
    for (var e = t._pt, i, r, n, o; e; ) {
        for (i = e._next,
        r = n; r && r.pr > e.pr; )
            r = r._next;
        (e._prev = r ? r._prev : o) ? e._prev._next = e : n = e,
        (e._next = r) ? r._prev = e : o = e,
        e = i
    }
    t._pt = n
}
  , Ti = function() {
    function s(e, i, r, n, o, a, l, h, u) {
        this.t = i,
        this.s = n,
        this.c = o,
        this.p = r,
        this.r = a || fv,
        this.d = l || this,
        this.set = h || qp,
        this.pr = u || 0,
        this._next = e,
        e && (e._prev = this)
    }
    var t = s.prototype;
    return t.modifier = function(i, r, n) {
        this.mSet = this.mSet || this.set,
        this.set = AE,
        this.m = i,
        this.mt = n,
        this.tween = r
    }
    ,
    s
}();
Ei(Vp + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(s) {
    return zp[s] = 1
});
Xi.TweenMax = Xi.TweenLite = be;
Xi.TimelineLite = Xi.TimelineMax = pi;
le = new pi({
    sortChildren: !1,
    defaults: Wo,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
$i.stringFilter = sv;
var In = []
  , Qh = {}
  , SE = []
  , Pg = 0
  , CE = 0
  , Xc = function(t) {
    return (Qh[t] || SE).map(function(e) {
        return e()
    })
}
  , uf = function() {
    var t = Date.now()
      , e = [];
    t - Pg > 2 && (Xc("matchMediaInit"),
    In.forEach(function(i) {
        var r = i.queries, n = i.conditions, o, a, l, h;
        for (a in r)
            o = Ki.matchMedia(r[a]).matches,
            o && (l = 1),
            o !== n[a] && (n[a] = o,
            h = 1);
        h && (i.revert(),
        l && e.push(i))
    }),
    Xc("matchMediaRevert"),
    e.forEach(function(i) {
        return i.onMatch(i, function(r) {
            return i.add(null, r)
        })
    }),
    Pg = t,
    Xc("matchMedia"))
}
  , gv = function() {
    function s(e, i) {
        this.selector = i && af(i),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = CE++,
        e && this.add(e)
    }
    var t = s.prototype;
    return t.add = function(i, r, n) {
        fe(i) && (n = r,
        r = i,
        i = fe);
        var o = this
          , a = function() {
            var h = de, u = o.selector, c;
            return h && h !== o && h.data.push(o),
            n && (o.selector = af(n)),
            de = o,
            c = r.apply(o, arguments),
            fe(c) && o._r.push(c),
            de = h,
            o.selector = u,
            o.isReverted = !1,
            c
        };
        return o.last = a,
        i === fe ? a(o, function(l) {
            return o.add(null, l)
        }) : i ? o[i] = a : a
    }
    ,
    t.ignore = function(i) {
        var r = de;
        de = null,
        i(this),
        de = r
    }
    ,
    t.getTweens = function() {
        var i = [];
        return this.data.forEach(function(r) {
            return r instanceof s ? i.push.apply(i, r.getTweens()) : r instanceof be && !(r.parent && r.parent.data === "nested") && i.push(r)
        }),
        i
    }
    ,
    t.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    t.kill = function(i, r) {
        var n = this;
        if (i ? function() {
            for (var a = n.getTweens(), l = n.data.length, h; l--; )
                h = n.data[l],
                h.data === "isFlip" && (h.revert(),
                h.getChildren(!0, !0, !1).forEach(function(u) {
                    return a.splice(a.indexOf(u), 1)
                }));
            for (a.map(function(u) {
                return {
                    g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
                    t: u
                }
            }).sort(function(u, c) {
                return c.g - u.g || -1 / 0
            }).forEach(function(u) {
                return u.t.revert(i)
            }),
            l = n.data.length; l--; )
                h = n.data[l],
                h instanceof pi ? h.data !== "nested" && (h.scrollTrigger && h.scrollTrigger.revert(),
                h.kill()) : !(h instanceof be) && h.revert && h.revert(i);
            n._r.forEach(function(u) {
                return u(i, n)
            }),
            n.isReverted = !0
        }() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        r)
            for (var o = In.length; o--; )
                In[o].id === this.id && In.splice(o, 1)
    }
    ,
    t.revert = function(i) {
        this.kill(i || {})
    }
    ,
    s
}()
  , PE = function() {
    function s(e) {
        this.contexts = [],
        this.scope = e
    }
    var t = s.prototype;
    return t.add = function(i, r, n) {
        ts(i) || (i = {
            matches: i
        });
        var o = new gv(0,n || this.scope), a = o.conditions = {}, l, h, u;
        de && !o.selector && (o.selector = de.selector),
        this.contexts.push(o),
        r = o.add("onMatch", r),
        o.queries = i;
        for (h in i)
            h === "all" ? u = 1 : (l = Ki.matchMedia(i[h]),
            l && (In.indexOf(o) < 0 && In.push(o),
            (a[h] = l.matches) && (u = 1),
            l.addListener ? l.addListener(uf) : l.addEventListener("change", uf)));
        return u && r(o, function(c) {
            return o.add(null, c)
        }),
        this
    }
    ,
    t.revert = function(i) {
        this.kill(i || {})
    }
    ,
    t.kill = function(i) {
        this.contexts.forEach(function(r) {
            return r.kill(i, !0)
        })
    }
    ,
    s
}()
  , Au = {
    registerPlugin: function() {
        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
            e[i] = arguments[i];
        e.forEach(function(r) {
            return ev(r)
        })
    },
    timeline: function(t) {
        return new pi(t)
    },
    getTweensOf: function(t, e) {
        return le.getTweensOf(t, e)
    },
    getProperty: function(t, e, i, r) {
        Ge(t) && (t = sr(t)[0]);
        var n = Sn(t || {}).get
          , o = i ? $y : Hy;
        return i === "native" && (i = ""),
        t && (e ? o((ki[e] && ki[e].get || n)(t, e, i, r)) : function(a, l, h) {
            return o((ki[a] && ki[a].get || n)(t, a, l, h))
        }
        )
    },
    quickSetter: function(t, e, i) {
        if (t = sr(t),
        t.length > 1) {
            var r = t.map(function(u) {
                return Ai.quickSetter(u, e, i)
            })
              , n = r.length;
            return function(u) {
                for (var c = n; c--; )
                    r[c](u)
            }
        }
        t = t[0] || {};
        var o = ki[e]
          , a = Sn(t)
          , l = a.harness && (a.harness.aliases || {})[e] || e
          , h = o ? function(u) {
            var c = new o;
            wo._pt = 0,
            c.init(t, i ? u + i : u, wo, 0, [t]),
            c.render(1, c),
            wo._pt && Kp(1, wo)
        }
        : a.set(t, l);
        return o ? h : function(u) {
            return h(t, l, i ? u + i : u, a, 1)
        }
    },
    quickTo: function(t, e, i) {
        var r, n = Ai.to(t, Hn((r = {},
        r[e] = "+=0.1",
        r.paused = !0,
        r), i || {})), o = function(l, h, u) {
            return n.resetTo(e, l, h, u)
        };
        return o.tween = n,
        o
    },
    isTweening: function(t) {
        return le.getTweensOf(t, !0).length > 0
    },
    defaults: function(t) {
        return t && t.ease && (t.ease = Pn(t.ease, Wo.ease)),
        Tg(Wo, t || {})
    },
    config: function(t) {
        return Tg($i, t || {})
    },
    registerEffect: function(t) {
        var e = t.name
          , i = t.effect
          , r = t.plugins
          , n = t.defaults
          , o = t.extendTimeline;
        (r || "").split(",").forEach(function(a) {
            return a && !ki[a] && !Xi[a] && _l(e + " effect requires " + a + " plugin.")
        }),
        Hc[e] = function(a, l, h) {
            return i(sr(a), lr(l || {}, n), h)
        }
        ,
        o && (pi.prototype[e] = function(a, l, h) {
            return this.add(Hc[e](a, ts(l) ? l : (h = l) && {}, this), h)
        }
        )
    },
    registerEase: function(t, e) {
        Gt[t] = Pn(e)
    },
    parseEase: function(t, e) {
        return arguments.length ? Pn(t, e) : Gt
    },
    getById: function(t) {
        return le.getById(t)
    },
    exportRoot: function(t, e) {
        t === void 0 && (t = {});
        var i = new pi(t), r, n;
        for (i.smoothChildTiming = wi(t.smoothChildTiming),
        le.remove(i),
        i._dp = 0,
        i._time = i._tTime = le._time,
        r = le._first; r; )
            n = r._next,
            (e || !(!r._dur && r instanceof be && r.vars.onComplete === r._targets[0])) && zr(i, r, r._start - r._delay),
            r = n;
        return zr(le, i, 0),
        i
    },
    context: function(t, e) {
        return t ? new gv(t,e) : de
    },
    matchMedia: function(t) {
        return new PE(t)
    },
    matchMediaRefresh: function() {
        return In.forEach(function(t) {
            var e = t.conditions, i, r;
            for (r in e)
                e[r] && (e[r] = !1,
                i = 1);
            i && t.revert()
        }) || uf()
    },
    addEventListener: function(t, e) {
        var i = Qh[t] || (Qh[t] = []);
        ~i.indexOf(e) || i.push(e)
    },
    removeEventListener: function(t, e) {
        var i = Qh[t]
          , r = i && i.indexOf(e);
        r >= 0 && i.splice(r, 1)
    },
    utils: {
        wrap: aE,
        wrapYoyo: lE,
        distribute: Yy,
        random: Zy,
        snap: Ky,
        normalize: oE,
        getUnit: Qe,
        clamp: iE,
        splitColor: iv,
        toArray: sr,
        selector: af,
        mapRange: Jy,
        pipe: sE,
        unitize: nE,
        interpolate: hE,
        shuffle: qy
    },
    install: ky,
    effects: Hc,
    ticker: Li,
    updateRoot: pi.updateRoot,
    plugins: ki,
    globalTimeline: le,
    core: {
        PropTween: Ti,
        globals: Ly,
        Tween: be,
        Timeline: pi,
        Animation: bl,
        getCache: Sn,
        _removeLinkedListItem: mc,
        reverting: function() {
            return ei
        },
        context: function(t) {
            return t && de && (de.data.push(t),
            t._ctx = de),
            de
        },
        suppressOverwrites: function(t) {
            return Np = t
        }
    }
};
Ei("to,from,fromTo,delayedCall,set,killTweensOf", function(s) {
    return Au[s] = be[s]
});
Li.add(pi.updateRoot);
wo = Au.to({}, {
    duration: 0
});
var IE = function(t, e) {
    for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e; )
        i = i._next;
    return i
}
  , RE = function(t, e) {
    var i = t._targets, r, n, o;
    for (r in e)
        for (n = i.length; n--; )
            o = t._ptLookup[n][r],
            o && (o = o.d) && (o._pt && (o = IE(o, r)),
            o && o.modifier && o.modifier(e[r], t, i[n], r))
}
  , Wc = function(t, e) {
    return {
        name: t,
        rawVars: 1,
        init: function(r, n, o) {
            o._onInit = function(a) {
                var l, h;
                if (Ge(n) && (l = {},
                Ei(n, function(u) {
                    return l[u] = 1
                }),
                n = l),
                e) {
                    l = {};
                    for (h in n)
                        l[h] = e(n[h]);
                    n = l
                }
                RE(a, n)
            }
        }
    }
}
  , Ai = Au.registerPlugin({
    name: "attr",
    init: function(t, e, i, r, n) {
        var o, a, l;
        this.tween = i;
        for (o in e)
            l = t.getAttribute(o) || "",
            a = this.add(t, "setAttribute", (l || 0) + "", e[o], r, n, 0, 0, o),
            a.op = o,
            a.b = l,
            this._props.push(o)
    },
    render: function(t, e) {
        for (var i = e._pt; i; )
            ei ? i.set(i.t, i.p, i.b, i) : i.r(t, i.d),
            i = i._next
    }
}, {
    name: "endArray",
    init: function(t, e) {
        for (var i = e.length; i--; )
            this.add(t, i, t[i] || 0, e[i], 0, 0, 0, 0, 0, 1)
    }
}, Wc("roundProps", lf), Wc("modifiers"), Wc("snap", Ky)) || Au;
be.version = pi.version = Ai.version = "3.12.3";
Oy = 1;
Gp() && Yo();
Gt.Power0;
Gt.Power1;
Gt.Power2;
Gt.Power3;
Gt.Power4;
Gt.Linear;
Gt.Quad;
Gt.Cubic;
Gt.Quart;
Gt.Quint;
Gt.Strong;
Gt.Elastic;
Gt.Back;
Gt.SteppedEase;
Gt.Bounce;
Gt.Sine;
Gt.Expo;
Gt.Circ;
/*!
 * CSSPlugin 3.12.3
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ig, Ns, Mo, Zp, Tn, Rg, Qp, ME = function() {
    return typeof window < "u"
}, xs = {}, dn = 180 / Math.PI, Fo = Math.PI / 180, to = Math.atan2, Mg = 1e8, Jp = /([A-Z])/g, FE = /(left|right|width|margin|padding|x)/i, BE = /[\s,\(]\S/, Vr = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, cf = function(t, e) {
    return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
}, OE = function(t, e) {
    return e.set(e.t, e.p, t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
}, kE = function(t, e) {
    return e.set(e.t, e.p, t ? Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u : e.b, e)
}, LE = function(t, e) {
    var i = e.s + e.c * t;
    e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
}, _v = function(t, e) {
    return e.set(e.t, e.p, t ? e.e : e.b, e)
}, yv = function(t, e) {
    return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e)
}, NE = function(t, e, i) {
    return t.style[e] = i
}, UE = function(t, e, i) {
    return t.style.setProperty(e, i)
}, GE = function(t, e, i) {
    return t._gsap[e] = i
}, HE = function(t, e, i) {
    return t._gsap.scaleX = t._gsap.scaleY = i
}, $E = function(t, e, i, r, n) {
    var o = t._gsap;
    o.scaleX = o.scaleY = i,
    o.renderTransform(n, o)
}, zE = function(t, e, i, r, n) {
    var o = t._gsap;
    o[e] = i,
    o.renderTransform(n, o)
}, he = "transform", Di = he + "Origin", VE = function s(t, e) {
    var i = this
      , r = this.target
      , n = r.style
      , o = r._gsap;
    if (t in xs && n) {
        if (this.tfm = this.tfm || {},
        t !== "transform")
            t = Vr[t] || t,
            ~t.indexOf(",") ? t.split(",").forEach(function(a) {
                return i.tfm[a] = hs(r, a)
            }) : this.tfm[t] = o.x ? o[t] : hs(r, t),
            t === Di && (this.tfm.zOrigin = o.zOrigin);
        else
            return Vr.transform.split(",").forEach(function(a) {
                return s.call(i, a, e)
            });
        if (this.props.indexOf(he) >= 0)
            return;
        o.svg && (this.svgo = r.getAttribute("data-svg-origin"),
        this.props.push(Di, e, "")),
        t = he
    }
    (n || e) && this.props.push(t, e, n[t])
}, vv = function(t) {
    t.translate && (t.removeProperty("translate"),
    t.removeProperty("scale"),
    t.removeProperty("rotate"))
}, XE = function() {
    var t = this.props, e = this.target, i = e.style, r = e._gsap, n, o;
    for (n = 0; n < t.length; n += 3)
        t[n + 1] ? e[t[n]] = t[n + 2] : t[n + 2] ? i[t[n]] = t[n + 2] : i.removeProperty(t[n].substr(0, 2) === "--" ? t[n] : t[n].replace(Jp, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            r[o] = this.tfm[o];
        r.svg && (r.renderTransform(),
        e.setAttribute("data-svg-origin", this.svgo || "")),
        n = Qp(),
        (!n || !n.isStart) && !i[he] && (vv(i),
        r.zOrigin && i[Di] && (i[Di] += " " + r.zOrigin + "px",
        r.zOrigin = 0,
        r.renderTransform()),
        r.uncache = 1)
    }
}, xv = function(t, e) {
    var i = {
        target: t,
        props: [],
        revert: XE,
        save: VE
    };
    return t._gsap || Ai.core.getCache(t),
    e && e.split(",").forEach(function(r) {
        return i.save(r)
    }),
    i
}, bv, df = function(t, e) {
    var i = Ns.createElementNS ? Ns.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Ns.createElement(t);
    return i && i.style ? i : Ns.createElement(t)
}, Kr = function s(t, e, i) {
    var r = getComputedStyle(t);
    return r[e] || r.getPropertyValue(e.replace(Jp, "-$1").toLowerCase()) || r.getPropertyValue(e) || !i && s(t, Ko(e) || e, 1) || ""
}, Fg = "O,Moz,ms,Ms,Webkit".split(","), Ko = function(t, e, i) {
    var r = e || Tn
      , n = r.style
      , o = 5;
    if (t in n && !i)
        return t;
    for (t = t.charAt(0).toUpperCase() + t.substr(1); o-- && !(Fg[o] + t in n); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? Fg[o] : "") + t
}, ff = function() {
    ME() && window.document && (Ig = window,
    Ns = Ig.document,
    Mo = Ns.documentElement,
    Tn = df("div") || {
        style: {}
    },
    df("div"),
    he = Ko(he),
    Di = he + "Origin",
    Tn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    bv = !!Ko("perspective"),
    Qp = Ai.core.reverting,
    Zp = 1)
}, jc = function s(t) {
    var e = df("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, r = this.nextSibling, n = this.style.cssText, o;
    if (Mo.appendChild(e),
    e.appendChild(this),
    this.style.display = "block",
    t)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = s
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return i && (r ? i.insertBefore(this, r) : i.appendChild(this)),
    Mo.removeChild(e),
    this.style.cssText = n,
    o
}, Bg = function(t, e) {
    for (var i = e.length; i--; )
        if (t.hasAttribute(e[i]))
            return t.getAttribute(e[i])
}, wv = function(t) {
    var e;
    try {
        e = t.getBBox()
    } catch {
        e = jc.call(t, !0)
    }
    return e && (e.width || e.height) || t.getBBox === jc || (e = jc.call(t, !0)),
    e && !e.width && !e.x && !e.y ? {
        x: +Bg(t, ["x", "cx", "x1"]) || 0,
        y: +Bg(t, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : e
}, Ev = function(t) {
    return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && wv(t))
}, $n = function(t, e) {
    if (e) {
        var i = t.style, r;
        e in xs && e !== Di && (e = he),
        i.removeProperty ? (r = e.substr(0, 2),
        (r === "ms" || e.substr(0, 6) === "webkit") && (e = "-" + e),
        i.removeProperty(r === "--" ? e : e.replace(Jp, "-$1").toLowerCase())) : i.removeAttribute(e)
    }
}, Us = function(t, e, i, r, n, o) {
    var a = new Ti(t._pt,e,i,0,1,o ? yv : _v);
    return t._pt = a,
    a.b = r,
    a.e = n,
    t._props.push(i),
    a
}, Og = {
    deg: 1,
    rad: 1,
    turn: 1
}, WE = {
    grid: 1,
    flex: 1
}, Ks = function s(t, e, i, r) {
    var n = parseFloat(i) || 0, o = (i + "").trim().substr((n + "").length) || "px", a = Tn.style, l = FE.test(e), h = t.tagName.toLowerCase() === "svg", u = (h ? "client" : "offset") + (l ? "Width" : "Height"), c = 100, d = r === "px", f = r === "%", p, m, g, _;
    if (r === o || !n || Og[r] || Og[o])
        return n;
    if (o !== "px" && !d && (n = s(t, e, i, "px")),
    _ = t.getCTM && Ev(t),
    (f || o === "%") && (xs[e] || ~e.indexOf("adius")))
        return p = _ ? t.getBBox()[l ? "width" : "height"] : t[u],
        me(f ? n / p * c : n / 100 * p);
    if (a[l ? "width" : "height"] = c + (d ? o : r),
    m = ~e.indexOf("adius") || r === "em" && t.appendChild && !h ? t : t.parentNode,
    _ && (m = (t.ownerSVGElement || {}).parentNode),
    (!m || m === Ns || !m.appendChild) && (m = Ns.body),
    g = m._gsap,
    g && f && g.width && l && g.time === Li.time && !g.uncache)
        return me(n / g.width * c);
    if (f && (e === "height" || e === "width")) {
        var x = t.style[e];
        t.style[e] = c + r,
        p = t[u],
        x ? t.style[e] = x : $n(t, e)
    } else
        (f || o === "%") && !WE[Kr(m, "display")] && (a.position = Kr(t, "position")),
        m === t && (a.position = "static"),
        m.appendChild(Tn),
        p = Tn[u],
        m.removeChild(Tn),
        a.position = "absolute";
    return l && f && (g = Sn(m),
    g.time = Li.time,
    g.width = m[u]),
    me(d ? p * n / c : p && n ? c / p * n : 0)
}, hs = function(t, e, i, r) {
    var n;
    return Zp || ff(),
    e in Vr && e !== "transform" && (e = Vr[e],
    ~e.indexOf(",") && (e = e.split(",")[0])),
    xs[e] && e !== "transform" ? (n = El(t, r),
    n = e !== "transformOrigin" ? n[e] : n.svg ? n.origin : Cu(Kr(t, Di)) + " " + n.zOrigin + "px") : (n = t.style[e],
    (!n || n === "auto" || r || ~(n + "").indexOf("calc(")) && (n = Su[e] && Su[e](t, e, i) || Kr(t, e) || Uy(t, e) || (e === "opacity" ? 1 : 0))),
    i && !~(n + "").trim().indexOf(" ") ? Ks(t, e, n, i) + i : n
}, jE = function(t, e, i, r) {
    if (!i || i === "none") {
        var n = Ko(e, t, 1)
          , o = n && Kr(t, n, 1);
        o && o !== i ? (e = n,
        i = o) : e === "borderColor" && (i = Kr(t, "borderTopColor"))
    }
    var a = new Ti(this._pt,t.style,e,0,1,pv), l = 0, h = 0, u, c, d, f, p, m, g, _, x, y, v, E;
    if (a.b = i,
    a.e = r,
    i += "",
    r += "",
    r === "auto" && (m = t.style[e],
    t.style[e] = r,
    r = Kr(t, e) || r,
    m ? t.style[e] = m : $n(t, e)),
    u = [i, r],
    sv(u),
    i = u[0],
    r = u[1],
    d = i.match(bo) || [],
    E = r.match(bo) || [],
    E.length) {
        for (; c = bo.exec(r); )
            g = c[0],
            x = r.substring(l, c.index),
            p ? p = (p + 1) % 5 : (x.substr(-5) === "rgba(" || x.substr(-5) === "hsla(") && (p = 1),
            g !== (m = d[h++] || "") && (f = parseFloat(m) || 0,
            v = m.substr((f + "").length),
            g.charAt(1) === "=" && (g = Ro(f, g) + v),
            _ = parseFloat(g),
            y = g.substr((_ + "").length),
            l = bo.lastIndex - y.length,
            y || (y = y || $i.units[e] || v,
            l === r.length && (r += y,
            a.e += y)),
            v !== y && (f = Ks(t, e, m, y) || 0),
            a._pt = {
                _next: a._pt,
                p: x || h === 1 ? x : ",",
                s: f,
                c: _ - f,
                m: p && p < 4 || e === "zIndex" ? Math.round : 0
            });
        a.c = l < r.length ? r.substring(l, r.length) : ""
    } else
        a.r = e === "display" && r === "none" ? yv : _v;
    return Fy.test(r) && (a.e = 0),
    this._pt = a,
    a
}, kg = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, qE = function(t) {
    var e = t.split(" ")
      , i = e[0]
      , r = e[1] || "50%";
    return (i === "top" || i === "bottom" || r === "left" || r === "right") && (t = i,
    i = r,
    r = t),
    e[0] = kg[i] || i,
    e[1] = kg[r] || r,
    e.join(" ")
}, YE = function(t, e) {
    if (e.tween && e.tween._time === e.tween._dur) {
        var i = e.t, r = i.style, n = e.u, o = i._gsap, a, l, h;
        if (n === "all" || n === !0)
            r.cssText = "",
            l = 1;
        else
            for (n = n.split(","),
            h = n.length; --h > -1; )
                a = n[h],
                xs[a] && (l = 1,
                a = a === "transformOrigin" ? Di : he),
                $n(i, a);
        l && ($n(i, he),
        o && (o.svg && i.removeAttribute("transform"),
        El(i, 1),
        o.uncache = 1,
        vv(r)))
    }
}, Su = {
    clearProps: function(t, e, i, r, n) {
        if (n.data !== "isFromStart") {
            var o = t._pt = new Ti(t._pt,e,i,0,0,YE);
            return o.u = r,
            o.pr = -10,
            o.tween = n,
            t._props.push(i),
            1
        }
    }
}, wl = [1, 0, 0, 1, 0, 0], Tv = {}, Dv = function(t) {
    return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t
}, Lg = function(t) {
    var e = Kr(t, he);
    return Dv(e) ? wl : e.substr(7).match(My).map(me)
}, tm = function(t, e) {
    var i = t._gsap || Sn(t), r = t.style, n = Lg(t), o, a, l, h;
    return i.svg && t.getAttribute("transform") ? (l = t.transform.baseVal.consolidate().matrix,
    n = [l.a, l.b, l.c, l.d, l.e, l.f],
    n.join(",") === "1,0,0,1,0,0" ? wl : n) : (n === wl && !t.offsetParent && t !== Mo && !i.svg && (l = r.display,
    r.display = "block",
    o = t.parentNode,
    (!o || !t.offsetParent) && (h = 1,
    a = t.nextElementSibling,
    Mo.appendChild(t)),
    n = Lg(t),
    l ? r.display = l : $n(t, "display"),
    h && (a ? o.insertBefore(t, a) : o ? o.appendChild(t) : Mo.removeChild(t))),
    e && n.length > 6 ? [n[0], n[1], n[4], n[5], n[12], n[13]] : n)
}, pf = function(t, e, i, r, n, o) {
    var a = t._gsap, l = n || tm(t, !0), h = a.xOrigin || 0, u = a.yOrigin || 0, c = a.xOffset || 0, d = a.yOffset || 0, f = l[0], p = l[1], m = l[2], g = l[3], _ = l[4], x = l[5], y = e.split(" "), v = parseFloat(y[0]) || 0, E = parseFloat(y[1]) || 0, P, w, A, I;
    i ? l !== wl && (w = f * g - p * m) && (A = v * (g / w) + E * (-m / w) + (m * x - g * _) / w,
    I = v * (-p / w) + E * (f / w) - (f * x - p * _) / w,
    v = A,
    E = I) : (P = wv(t),
    v = P.x + (~y[0].indexOf("%") ? v / 100 * P.width : v),
    E = P.y + (~(y[1] || y[0]).indexOf("%") ? E / 100 * P.height : E),
    !("xOrigin"in a) && (v || E) && (v -= P.x,
    E -= P.y)),
    r || r !== !1 && a.smooth ? (_ = v - h,
    x = E - u,
    a.xOffset = c + (_ * f + x * m) - _,
    a.yOffset = d + (_ * p + x * g) - x) : a.xOffset = a.yOffset = 0,
    a.xOrigin = v,
    a.yOrigin = E,
    a.smooth = !!r,
    a.origin = e,
    a.originIsAbsolute = !!i,
    t.style[Di] = "0px 0px",
    o && (Us(o, a, "xOrigin", h, v),
    Us(o, a, "yOrigin", u, E),
    Us(o, a, "xOffset", c, a.xOffset),
    Us(o, a, "yOffset", d, a.yOffset)),
    t.setAttribute("data-svg-origin", v + " " + E)
}, El = function(t, e) {
    var i = t._gsap || new lv(t);
    if ("x"in i && !e && !i.uncache)
        return i;
    var r = t.style, n = i.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(t), h = Kr(t, Di) || "0", u, c, d, f, p, m, g, _, x, y, v, E, P, w, A, I, F, O, B, S, T, M, D, C, k, R, b, L, U, Y, $, z;
    return u = c = d = m = g = _ = x = y = v = 0,
    f = p = 1,
    i.svg = !!(t.getCTM && Ev(t)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[he] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[he] !== "none" ? l[he] : "")),
    r.scale = r.rotate = r.translate = "none"),
    w = tm(t, i.svg),
    i.svg && (i.uncache ? (k = t.getBBox(),
    h = i.xOrigin - k.x + "px " + (i.yOrigin - k.y) + "px",
    C = "") : C = !e && t.getAttribute("data-svg-origin"),
    pf(t, C || h, !!C || i.originIsAbsolute, i.smooth !== !1, w)),
    E = i.xOrigin || 0,
    P = i.yOrigin || 0,
    w !== wl && (O = w[0],
    B = w[1],
    S = w[2],
    T = w[3],
    u = M = w[4],
    c = D = w[5],
    w.length === 6 ? (f = Math.sqrt(O * O + B * B),
    p = Math.sqrt(T * T + S * S),
    m = O || B ? to(B, O) * dn : 0,
    x = S || T ? to(S, T) * dn + m : 0,
    x && (p *= Math.abs(Math.cos(x * Fo))),
    i.svg && (u -= E - (E * O + P * S),
    c -= P - (E * B + P * T))) : (z = w[6],
    Y = w[7],
    b = w[8],
    L = w[9],
    U = w[10],
    $ = w[11],
    u = w[12],
    c = w[13],
    d = w[14],
    A = to(z, U),
    g = A * dn,
    A && (I = Math.cos(-A),
    F = Math.sin(-A),
    C = M * I + b * F,
    k = D * I + L * F,
    R = z * I + U * F,
    b = M * -F + b * I,
    L = D * -F + L * I,
    U = z * -F + U * I,
    $ = Y * -F + $ * I,
    M = C,
    D = k,
    z = R),
    A = to(-S, U),
    _ = A * dn,
    A && (I = Math.cos(-A),
    F = Math.sin(-A),
    C = O * I - b * F,
    k = B * I - L * F,
    R = S * I - U * F,
    $ = T * F + $ * I,
    O = C,
    B = k,
    S = R),
    A = to(B, O),
    m = A * dn,
    A && (I = Math.cos(A),
    F = Math.sin(A),
    C = O * I + B * F,
    k = M * I + D * F,
    B = B * I - O * F,
    D = D * I - M * F,
    O = C,
    M = k),
    g && Math.abs(g) + Math.abs(m) > 359.9 && (g = m = 0,
    _ = 180 - _),
    f = me(Math.sqrt(O * O + B * B + S * S)),
    p = me(Math.sqrt(D * D + z * z)),
    A = to(M, D),
    x = Math.abs(A) > 2e-4 ? A * dn : 0,
    v = $ ? 1 / ($ < 0 ? -$ : $) : 0),
    i.svg && (C = t.getAttribute("transform"),
    i.forceCSS = t.setAttribute("transform", "") || !Dv(Kr(t, he)),
    C && t.setAttribute("transform", C))),
    Math.abs(x) > 90 && Math.abs(x) < 270 && (n ? (f *= -1,
    x += m <= 0 ? 180 : -180,
    m += m <= 0 ? 180 : -180) : (p *= -1,
    x += x <= 0 ? 180 : -180)),
    e = e || i.uncache,
    i.x = u - ((i.xPercent = u && (!e && i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + o,
    i.y = c - ((i.yPercent = c && (!e && i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-c) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + o,
    i.z = d + o,
    i.scaleX = me(f),
    i.scaleY = me(p),
    i.rotation = me(m) + a,
    i.rotationX = me(g) + a,
    i.rotationY = me(_) + a,
    i.skewX = x + a,
    i.skewY = y + a,
    i.transformPerspective = v + o,
    (i.zOrigin = parseFloat(h.split(" ")[2]) || !e && i.zOrigin || 0) && (r[Di] = Cu(h)),
    i.svg || (i.xOffset = i.yOffset = 0),
    i.force3D = $i.force3D,
    i.renderTransform = i.svg ? ZE : bv ? Av : KE,
    i.uncache = 0,
    i
}, Cu = function(t) {
    return (t = t.split(" "))[0] + " " + t[1]
}, qc = function(t, e, i) {
    var r = Qe(e);
    return me(parseFloat(e) + parseFloat(Ks(t, "x", i + "px", r))) + r
}, KE = function(t, e) {
    e.z = "0px",
    e.rotationY = e.rotationX = "0deg",
    e.force3D = 0,
    Av(t, e)
}, an = "0deg", da = "0px", ln = ") ", Av = function(t, e) {
    var i = e || this
      , r = i.xPercent
      , n = i.yPercent
      , o = i.x
      , a = i.y
      , l = i.z
      , h = i.rotation
      , u = i.rotationY
      , c = i.rotationX
      , d = i.skewX
      , f = i.skewY
      , p = i.scaleX
      , m = i.scaleY
      , g = i.transformPerspective
      , _ = i.force3D
      , x = i.target
      , y = i.zOrigin
      , v = ""
      , E = _ === "auto" && t && t !== 1 || _ === !0;
    if (y && (c !== an || u !== an)) {
        var P = parseFloat(u) * Fo, w = Math.sin(P), A = Math.cos(P), I;
        P = parseFloat(c) * Fo,
        I = Math.cos(P),
        o = qc(x, o, w * I * -y),
        a = qc(x, a, -Math.sin(P) * -y),
        l = qc(x, l, A * I * -y + y)
    }
    g !== da && (v += "perspective(" + g + ln),
    (r || n) && (v += "translate(" + r + "%, " + n + "%) "),
    (E || o !== da || a !== da || l !== da) && (v += l !== da || E ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + ln),
    h !== an && (v += "rotate(" + h + ln),
    u !== an && (v += "rotateY(" + u + ln),
    c !== an && (v += "rotateX(" + c + ln),
    (d !== an || f !== an) && (v += "skew(" + d + ", " + f + ln),
    (p !== 1 || m !== 1) && (v += "scale(" + p + ", " + m + ln),
    x.style[he] = v || "translate(0, 0)"
}, ZE = function(t, e) {
    var i = e || this, r = i.xPercent, n = i.yPercent, o = i.x, a = i.y, l = i.rotation, h = i.skewX, u = i.skewY, c = i.scaleX, d = i.scaleY, f = i.target, p = i.xOrigin, m = i.yOrigin, g = i.xOffset, _ = i.yOffset, x = i.forceCSS, y = parseFloat(o), v = parseFloat(a), E, P, w, A, I;
    l = parseFloat(l),
    h = parseFloat(h),
    u = parseFloat(u),
    u && (u = parseFloat(u),
    h += u,
    l += u),
    l || h ? (l *= Fo,
    h *= Fo,
    E = Math.cos(l) * c,
    P = Math.sin(l) * c,
    w = Math.sin(l - h) * -d,
    A = Math.cos(l - h) * d,
    h && (u *= Fo,
    I = Math.tan(h - u),
    I = Math.sqrt(1 + I * I),
    w *= I,
    A *= I,
    u && (I = Math.tan(u),
    I = Math.sqrt(1 + I * I),
    E *= I,
    P *= I)),
    E = me(E),
    P = me(P),
    w = me(w),
    A = me(A)) : (E = c,
    A = d,
    P = w = 0),
    (y && !~(o + "").indexOf("px") || v && !~(a + "").indexOf("px")) && (y = Ks(f, "x", o, "px"),
    v = Ks(f, "y", a, "px")),
    (p || m || g || _) && (y = me(y + p - (p * E + m * w) + g),
    v = me(v + m - (p * P + m * A) + _)),
    (r || n) && (I = f.getBBox(),
    y = me(y + r / 100 * I.width),
    v = me(v + n / 100 * I.height)),
    I = "matrix(" + E + "," + P + "," + w + "," + A + "," + y + "," + v + ")",
    f.setAttribute("transform", I),
    x && (f.style[he] = I)
}, QE = function(t, e, i, r, n) {
    var o = 360, a = Ge(n), l = parseFloat(n) * (a && ~n.indexOf("rad") ? dn : 1), h = l - r, u = r + h + "deg", c, d;
    return a && (c = n.split("_")[1],
    c === "short" && (h %= o,
    h !== h % (o / 2) && (h += h < 0 ? o : -o)),
    c === "cw" && h < 0 ? h = (h + o * Mg) % o - ~~(h / o) * o : c === "ccw" && h > 0 && (h = (h - o * Mg) % o - ~~(h / o) * o)),
    t._pt = d = new Ti(t._pt,e,i,r,h,OE),
    d.e = u,
    d.u = "deg",
    t._props.push(i),
    d
}, Ng = function(t, e) {
    for (var i in e)
        t[i] = e[i];
    return t
}, JE = function(t, e, i) {
    var r = Ng({}, i._gsap), n = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, l, h, u, c, d, f, p;
    r.svg ? (h = i.getAttribute("transform"),
    i.setAttribute("transform", ""),
    o[he] = e,
    a = El(i, 1),
    $n(i, he),
    i.setAttribute("transform", h)) : (h = getComputedStyle(i)[he],
    o[he] = e,
    a = El(i, 1),
    o[he] = h);
    for (l in xs)
        h = r[l],
        u = a[l],
        h !== u && n.indexOf(l) < 0 && (f = Qe(h),
        p = Qe(u),
        c = f !== p ? Ks(i, l, h, p) : parseFloat(h),
        d = parseFloat(u),
        t._pt = new Ti(t._pt,a,l,c,d - c,cf),
        t._pt.u = p || 0,
        t._props.push(l));
    Ng(a, r)
};
Ei("padding,margin,Width,Radius", function(s, t) {
    var e = "Top"
      , i = "Right"
      , r = "Bottom"
      , n = "Left"
      , o = (t < 3 ? [e, i, r, n] : [e + n, e + i, r + i, r + n]).map(function(a) {
        return t < 2 ? s + a : "border" + a + s
    });
    Su[t > 1 ? "border" + s : s] = function(a, l, h, u, c) {
        var d, f;
        if (arguments.length < 4)
            return d = o.map(function(p) {
                return hs(a, p, h)
            }),
            f = d.join(" "),
            f.split(d[0]).length === 5 ? d[0] : f;
        d = (u + "").split(" "),
        f = {},
        o.forEach(function(p, m) {
            return f[p] = d[m] = d[m] || d[(m - 1) / 2 | 0]
        }),
        a.init(l, f, c)
    }
});
var Sv = {
    name: "css",
    register: ff,
    targetTest: function(t) {
        return t.style && t.nodeType
    },
    init: function(t, e, i, r, n) {
        var o = this._props, a = t.style, l = i.vars.startAt, h, u, c, d, f, p, m, g, _, x, y, v, E, P, w, A;
        Zp || ff(),
        this.styles = this.styles || xv(t),
        A = this.styles.props,
        this.tween = i;
        for (m in e)
            if (m !== "autoRound" && (u = e[m],
            !(ki[m] && hv(m, e, i, r, t, n)))) {
                if (f = typeof u,
                p = Su[m],
                f === "function" && (u = u.call(i, r, t, n),
                f = typeof u),
                f === "string" && ~u.indexOf("random(") && (u = vl(u)),
                p)
                    p(this, t, m, u, i) && (w = 1);
                else if (m.substr(0, 2) === "--")
                    h = (getComputedStyle(t).getPropertyValue(m) + "").trim(),
                    u += "",
                    Xs.lastIndex = 0,
                    Xs.test(h) || (g = Qe(h),
                    _ = Qe(u)),
                    _ ? g !== _ && (h = Ks(t, m, h, _) + _) : g && (u += g),
                    this.add(a, "setProperty", h, u, r, n, 0, 0, m),
                    o.push(m),
                    A.push(m, 0, a[m]);
                else if (f !== "undefined") {
                    if (l && m in l ? (h = typeof l[m] == "function" ? l[m].call(i, r, t, n) : l[m],
                    Ge(h) && ~h.indexOf("random(") && (h = vl(h)),
                    Qe(h + "") || h === "auto" || (h += $i.units[m] || Qe(hs(t, m)) || ""),
                    (h + "").charAt(1) === "=" && (h = hs(t, m))) : h = hs(t, m),
                    d = parseFloat(h),
                    x = f === "string" && u.charAt(1) === "=" && u.substr(0, 2),
                    x && (u = u.substr(2)),
                    c = parseFloat(u),
                    m in Vr && (m === "autoAlpha" && (d === 1 && hs(t, "visibility") === "hidden" && c && (d = 0),
                    A.push("visibility", 0, a.visibility),
                    Us(this, a, "visibility", d ? "inherit" : "hidden", c ? "inherit" : "hidden", !c)),
                    m !== "scale" && m !== "transform" && (m = Vr[m],
                    ~m.indexOf(",") && (m = m.split(",")[0]))),
                    y = m in xs,
                    y) {
                        if (this.styles.save(m),
                        v || (E = t._gsap,
                        E.renderTransform && !e.parseTransform || El(t, e.parseTransform),
                        P = e.smoothOrigin !== !1 && E.smooth,
                        v = this._pt = new Ti(this._pt,a,he,0,1,E.renderTransform,E,0,-1),
                        v.dep = 1),
                        m === "scale")
                            this._pt = new Ti(this._pt,E,"scaleY",E.scaleY,(x ? Ro(E.scaleY, x + c) : c) - E.scaleY || 0,cf),
                            this._pt.u = 0,
                            o.push("scaleY", m),
                            m += "X";
                        else if (m === "transformOrigin") {
                            A.push(Di, 0, a[Di]),
                            u = qE(u),
                            E.svg ? pf(t, u, 0, P, 0, this) : (_ = parseFloat(u.split(" ")[2]) || 0,
                            _ !== E.zOrigin && Us(this, E, "zOrigin", E.zOrigin, _),
                            Us(this, a, m, Cu(h), Cu(u)));
                            continue
                        } else if (m === "svgOrigin") {
                            pf(t, u, 1, P, 0, this);
                            continue
                        } else if (m in Tv) {
                            QE(this, E, m, d, x ? Ro(d, x + u) : u);
                            continue
                        } else if (m === "smoothOrigin") {
                            Us(this, E, "smooth", E.smooth, u);
                            continue
                        } else if (m === "force3D") {
                            E[m] = u;
                            continue
                        } else if (m === "transform") {
                            JE(this, u, t);
                            continue
                        }
                    } else
                        m in a || (m = Ko(m) || m);
                    if (y || (c || c === 0) && (d || d === 0) && !BE.test(u) && m in a)
                        g = (h + "").substr((d + "").length),
                        c || (c = 0),
                        _ = Qe(u) || (m in $i.units ? $i.units[m] : g),
                        g !== _ && (d = Ks(t, m, h, _)),
                        this._pt = new Ti(this._pt,y ? E : a,m,d,(x ? Ro(d, x + c) : c) - d,!y && (_ === "px" || m === "zIndex") && e.autoRound !== !1 ? LE : cf),
                        this._pt.u = _ || 0,
                        g !== _ && _ !== "%" && (this._pt.b = h,
                        this._pt.r = kE);
                    else if (m in a)
                        jE.call(this, t, m, h, x ? x + u : u);
                    else if (m in t)
                        this.add(t, m, h || t[m], x ? x + u : u, r, n);
                    else if (m !== "parseTransform") {
                        $p(m, u);
                        continue
                    }
                    y || (m in a ? A.push(m, 0, a[m]) : A.push(m, 1, h || t[m])),
                    o.push(m)
                }
            }
        w && mv(this)
    },
    render: function(t, e) {
        if (e.tween._time || !Qp())
            for (var i = e._pt; i; )
                i.r(t, i.d),
                i = i._next;
        else
            e.styles.revert()
    },
    get: hs,
    aliases: Vr,
    getSetter: function(t, e, i) {
        var r = Vr[e];
        return r && r.indexOf(",") < 0 && (e = r),
        e in xs && e !== Di && (t._gsap.x || hs(t, "x")) ? i && Rg === i ? e === "scale" ? HE : GE : (Rg = i || {}) && (e === "scale" ? $E : zE) : t.style && !Up(t.style[e]) ? NE : ~e.indexOf("-") ? UE : Yp(t, e)
    },
    core: {
        _removeProperty: $n,
        _getMatrix: tm
    }
};
Ai.utils.checkPrefix = Ko;
Ai.core.getStyleSaver = xv;
(function(s, t, e, i) {
    var r = Ei(s + "," + t + "," + e, function(n) {
        xs[n] = 1
    });
    Ei(t, function(n) {
        $i.units[n] = "deg",
        Tv[n] = 1
    }),
    Vr[r[13]] = s + "," + t,
    Ei(i, function(n) {
        var o = n.split(":");
        Vr[o[1]] = r[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Ei("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(s) {
    $i.units[s] = "px"
});
Ai.registerPlugin(Sv);
var N = Ai.registerPlugin(Sv) || Ai;
N.core.Tween;
/*!
 * strings: 3.12.3
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var tT = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
function Cv(s) {
    var t = s.nodeType
      , e = "";
    if (t === 1 || t === 9 || t === 11) {
        if (typeof s.textContent == "string")
            return s.textContent;
        for (s = s.firstChild; s; s = s.nextSibling)
            e += Cv(s)
    } else if (t === 3 || t === 4)
        return s.nodeValue;
    return e
}
/*!
 * SplitText: 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Eo, mf, Pv, fa, Iv, yc, eT = /(?:\r|\n|\t\t)/g, iT = /(?:\s\s+)/g, rT = String.fromCharCode(160), Rv = function(t) {
    Eo = document,
    mf = window,
    fa = fa || t || mf.gsap || console.warn("Please gsap.registerPlugin(SplitText)"),
    fa && (yc = fa.utils.toArray,
    Iv = fa.core.context || function() {}
    ,
    Pv = 1)
}, Mv = function(t) {
    return mf.getComputedStyle(t)
}, em = function(t) {
    return t.position === "absolute" || t.absolute === !0
}, sT = function(t, e) {
    for (var i = e.length, r; --i > -1; )
        if (r = e[i],
        t.substr(0, r.length) === r)
            return r.length
}, nT = " style='position:relative;display:inline-block;'", Ug = function(t, e) {
    t === void 0 && (t = "");
    var i = ~t.indexOf("++")
      , r = 1;
    return i && (t = t.split("++").join("")),
    function() {
        return "<" + e + nT + (t ? " class='" + t + (i ? r++ : "") + "'>" : ">")
    }
}, Fv = function s(t, e, i) {
    var r = t.nodeType;
    if (r === 1 || r === 9 || r === 11)
        for (t = t.firstChild; t; t = t.nextSibling)
            s(t, e, i);
    else
        (r === 3 || r === 4) && (t.nodeValue = t.nodeValue.split(e).join(i))
}, Yc = function(t, e) {
    for (var i = e.length; --i > -1; )
        t.push(e[i])
}, Gg = function(t, e, i) {
    for (var r; t && t !== e; ) {
        if (r = t._next || t.nextSibling,
        r)
            return r.textContent.charAt(0) === i;
        t = t.parentNode || t._parent
    }
}, oT = function s(t) {
    var e = yc(t.childNodes), i = e.length, r, n;
    for (r = 0; r < i; r++)
        n = e[r],
        n._isSplit ? s(n) : r && n.previousSibling && n.previousSibling.nodeType === 3 ? (n.previousSibling.nodeValue += n.nodeType === 3 ? n.nodeValue : n.firstChild.nodeValue,
        t.removeChild(n)) : n.nodeType !== 3 && (t.insertBefore(n.firstChild, n),
        t.removeChild(n))
}, Mr = function(t, e) {
    return parseFloat(e[t]) || 0
}, aT = function(t, e, i, r, n, o, a) {
    var l = Mv(t), h = Mr("paddingLeft", l), u = -999, c = Mr("borderBottomWidth", l) + Mr("borderTopWidth", l), d = Mr("borderLeftWidth", l) + Mr("borderRightWidth", l), f = Mr("paddingTop", l) + Mr("paddingBottom", l), p = Mr("paddingLeft", l) + Mr("paddingRight", l), m = Mr("fontSize", l) * (e.lineThreshold || .2), g = l.textAlign, _ = [], x = [], y = [], v = e.wordDelimiter || " ", E = e.tag ? e.tag : e.span ? "span" : "div", P = e.type || e.split || "chars,words,lines", w = n && ~P.indexOf("lines") ? [] : null, A = ~P.indexOf("words"), I = ~P.indexOf("chars"), F = em(e), O = e.linesClass, B = ~(O || "").indexOf("++"), S = [], T = l.display === "flex", M = t.style.display, D, C, k, R, b, L, U, Y, $, z, j, W;
    for (B && (O = O.split("++").join("")),
    T && (t.style.display = "block"),
    C = t.getElementsByTagName("*"),
    k = C.length,
    b = [],
    D = 0; D < k; D++)
        b[D] = C[D];
    if (w || F)
        for (D = 0; D < k; D++)
            R = b[D],
            L = R.parentNode === t,
            (L || F || I && !A) && (W = R.offsetTop,
            w && L && Math.abs(W - u) > m && (R.nodeName !== "BR" || D === 0) && (U = [],
            w.push(U),
            u = W),
            F && (R._x = R.offsetLeft,
            R._y = W,
            R._w = R.offsetWidth,
            R._h = R.offsetHeight),
            w && ((R._isSplit && L || !I && L || A && L || !A && R.parentNode.parentNode === t && !R.parentNode._isSplit) && (U.push(R),
            R._x -= h,
            Gg(R, t, v) && (R._wordEnd = !0)),
            R.nodeName === "BR" && (R.nextSibling && R.nextSibling.nodeName === "BR" || D === 0) && w.push([])));
    for (D = 0; D < k; D++) {
        if (R = b[D],
        L = R.parentNode === t,
        R.nodeName === "BR") {
            w || F ? (R.parentNode && R.parentNode.removeChild(R),
            b.splice(D--, 1),
            k--) : A || t.appendChild(R);
            continue
        }
        if (F && ($ = R.style,
        !A && !L && (R._x += R.parentNode._x,
        R._y += R.parentNode._y),
        $.left = R._x + "px",
        $.top = R._y + "px",
        $.position = "absolute",
        $.display = "block",
        $.width = R._w + 1 + "px",
        $.height = R._h + "px"),
        !A && I)
            if (R._isSplit)
                for (R._next = C = R.nextSibling,
                R.parentNode.appendChild(R); C && C.nodeType === 3 && C.textContent === " "; )
                    R._next = C.nextSibling,
                    R.parentNode.appendChild(C),
                    C = C.nextSibling;
            else
                R.parentNode._isSplit ? (R._parent = R.parentNode,
                !R.previousSibling && R.firstChild && (R.firstChild._isFirst = !0),
                R.nextSibling && R.nextSibling.textContent === " " && !R.nextSibling.nextSibling && S.push(R.nextSibling),
                R._next = R.nextSibling && R.nextSibling._isFirst ? null : R.nextSibling,
                R.parentNode.removeChild(R),
                b.splice(D--, 1),
                k--) : L || (W = !R.nextSibling && Gg(R.parentNode, t, v),
                R.parentNode._parent && R.parentNode._parent.appendChild(R),
                W && R.parentNode.appendChild(Eo.createTextNode(" ")),
                E === "span" && (R.style.display = "inline"),
                _.push(R));
        else
            R.parentNode._isSplit && !R._isSplit && R.innerHTML !== "" ? x.push(R) : I && !R._isSplit && (E === "span" && (R.style.display = "inline"),
            _.push(R))
    }
    for (D = S.length; --D > -1; )
        S[D].parentNode.removeChild(S[D]);
    if (w) {
        for (F && (z = Eo.createElement(E),
        t.appendChild(z),
        j = z.offsetWidth + "px",
        W = z.offsetParent === t ? 0 : t.offsetLeft,
        t.removeChild(z)),
        $ = t.style.cssText,
        t.style.cssText = "display:none;"; t.firstChild; )
            t.removeChild(t.firstChild);
        for (Y = v === " " && (!F || !A && !I),
        D = 0; D < w.length; D++) {
            for (U = w[D],
            z = Eo.createElement(E),
            z.style.cssText = "display:block;text-align:" + g + ";position:" + (F ? "absolute;" : "relative;"),
            O && (z.className = O + (B ? D + 1 : "")),
            y.push(z),
            k = U.length,
            C = 0; C < k; C++)
                U[C].nodeName !== "BR" && (R = U[C],
                z.appendChild(R),
                Y && R._wordEnd && z.appendChild(Eo.createTextNode(" ")),
                F && (C === 0 && (z.style.top = R._y + "px",
                z.style.left = h + W + "px"),
                R.style.top = "0px",
                W && (R.style.left = R._x - W + "px")));
            k === 0 ? z.innerHTML = "&nbsp;" : !A && !I && (oT(z),
            Fv(z, String.fromCharCode(160), " ")),
            F && (z.style.width = j,
            z.style.height = R._h + "px"),
            t.appendChild(z)
        }
        t.style.cssText = $
    }
    F && (a > t.clientHeight && (t.style.height = a - f + "px",
    t.clientHeight < a && (t.style.height = a + c + "px")),
    o > t.clientWidth && (t.style.width = o - p + "px",
    t.clientWidth < o && (t.style.width = o + d + "px"))),
    T && (M ? t.style.display = M : t.style.removeProperty("display")),
    Yc(i, _),
    A && Yc(r, x),
    Yc(n, y)
}, lT = function(t, e, i, r) {
    var n = e.tag ? e.tag : e.span ? "span" : "div", o = e.type || e.split || "chars,words,lines", a = ~o.indexOf("chars"), l = em(e), h = e.wordDelimiter || " ", u = function(F) {
        return F === h || F === rT && h === " "
    }, c = h !== " " ? "" : l ? "&#173; " : " ", d = "</" + n + ">", f = 1, p = e.specialChars ? typeof e.specialChars == "function" ? e.specialChars : sT : null, m, g, _, x, y, v, E, P, w = Eo.createElement("div"), A = t.parentNode;
    for (A.insertBefore(w, t),
    w.textContent = t.nodeValue,
    A.removeChild(t),
    t = w,
    m = Cv(t),
    E = m.indexOf("<") !== -1,
    e.reduceWhiteSpace !== !1 && (m = m.replace(iT, " ").replace(eT, "")),
    E && (m = m.split("<").join("{{LT}}")),
    y = m.length,
    g = (m.charAt(0) === " " ? c : "") + i(),
    _ = 0; _ < y; _++)
        if (v = m.charAt(_),
        p && (P = p(m.substr(_), e.specialChars)))
            v = m.substr(_, P || 1),
            g += a && v !== " " ? r() + v + "</" + n + ">" : v,
            _ += P - 1;
        else if (u(v) && !u(m.charAt(_ - 1)) && _) {
            for (g += f ? d : "",
            f = 0; u(m.charAt(_ + 1)); )
                g += c,
                _++;
            _ === y - 1 ? g += c : m.charAt(_ + 1) !== ")" && (g += c + i(),
            f = 1)
        } else
            v === "{" && m.substr(_, 6) === "{{LT}}" ? (g += a ? r() + "{{LT}}</" + n + ">" : "{{LT}}",
            _ += 5) : v.charCodeAt(0) >= 55296 && v.charCodeAt(0) <= 56319 || m.charCodeAt(_ + 1) >= 65024 && m.charCodeAt(_ + 1) <= 65039 ? (x = ((m.substr(_, 12).split(tT) || [])[1] || "").length || 2,
            g += a && v !== " " ? r() + m.substr(_, x) + "</" + n + ">" : m.substr(_, x),
            _ += x - 1) : g += a && v !== " " ? r() + v + "</" + n + ">" : v;
    t.outerHTML = g + (f ? d : ""),
    E && Fv(A, "{{LT}}", "<")
}, hT = function s(t, e, i, r) {
    var n = yc(t.childNodes), o = n.length, a = em(e), l, h;
    if (t.nodeType !== 3 || o > 1) {
        for (e.absolute = !1,
        l = 0; l < o; l++)
            h = n[l],
            h._next = h._isFirst = h._parent = h._wordEnd = null,
            (h.nodeType !== 3 || /\S+/.test(h.nodeValue)) && (a && h.nodeType !== 3 && Mv(h).display === "inline" && (h.style.display = "inline-block",
            h.style.position = "relative"),
            h._isSplit = !0,
            s(h, e, i, r));
        e.absolute = a,
        t._isSplit = !0;
        return
    }
    lT(t, e, i, r)
}, Tl = function() {
    function s(e, i) {
        Pv || Rv(),
        this.elements = yc(e),
        this.chars = [],
        this.words = [],
        this.lines = [],
        this._originals = [],
        this.vars = i || {},
        Iv(this),
        this.split(i)
    }
    var t = s.prototype;
    return t.split = function(i) {
        this.isSplit && this.revert(),
        this.vars = i = i || this.vars,
        this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
        for (var r = this.elements.length, n = i.tag ? i.tag : i.span ? "span" : "div", o = Ug(i.wordsClass, n), a = Ug(i.charsClass, n), l, h, u; --r > -1; )
            u = this.elements[r],
            this._originals[r] = {
                html: u.innerHTML,
                style: u.getAttribute("style")
            },
            l = u.clientHeight,
            h = u.clientWidth,
            hT(u, i, o, a),
            aT(u, i, this.chars, this.words, this.lines, h, l);
        return this.chars.reverse(),
        this.words.reverse(),
        this.lines.reverse(),
        this.isSplit = !0,
        this
    }
    ,
    t.revert = function() {
        var i = this._originals;
        if (!i)
            throw "revert() call wasn't scoped properly.";
        return this.elements.forEach(function(r, n) {
            r.innerHTML = i[n].html,
            r.setAttribute("style", i[n].style)
        }),
        this.chars = [],
        this.words = [],
        this.lines = [],
        this.isSplit = !1,
        this
    }
    ,
    s.create = function(i, r) {
        return new s(i,r)
    }
    ,
    s
}();
Tl.version = "3.12.3";
Tl.register = Rv;
function Hg(s, t) {
    for (var e = 0; e < t.length; e++) {
        var i = t[e];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(s, i.key, i)
    }
}
function uT(s, t, e) {
    return t && Hg(s.prototype, t),
    e && Hg(s, e),
    s
}
/*!
 * Observer 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var ze, Jh, Ni, Gs, Hs, Bo, Bv, fn, Ya, Ov, fs, pr, kv, Lv = function() {
    return ze || typeof window < "u" && (ze = window.gsap) && ze.registerPlugin && ze
}, Nv = 1, To = [], Ot = [], Zr = [], Ka = Date.now, gf = function(t, e) {
    return e
}, cT = function() {
    var t = Ya.core
      , e = t.bridge || {}
      , i = t._scrollers
      , r = t._proxies;
    i.push.apply(i, Ot),
    r.push.apply(r, Zr),
    Ot = i,
    Zr = r,
    gf = function(o, a) {
        return e[o](a)
    }
}, Ws = function(t, e) {
    return ~Zr.indexOf(t) && Zr[Zr.indexOf(t) + 1][e]
}, Za = function(t) {
    return !!~Ov.indexOf(t)
}, ai = function(t, e, i, r, n) {
    return t.addEventListener(e, i, {
        passive: !r,
        capture: !!n
    })
}, oi = function(t, e, i, r) {
    return t.removeEventListener(e, i, !!r)
}, oh = "scrollLeft", ah = "scrollTop", _f = function() {
    return fs && fs.isPressed || Ot.cache++
}, Pu = function(t, e) {
    var i = function r(n) {
        if (n || n === 0) {
            Nv && (Ni.history.scrollRestoration = "manual");
            var o = fs && fs.isPressed;
            n = r.v = Math.round(n) || (fs && fs.iOS ? 1 : 0),
            t(n),
            r.cacheID = Ot.cache,
            o && gf("ss", n)
        } else
            (e || Ot.cache !== r.cacheID || gf("ref")) && (r.cacheID = Ot.cache,
            r.v = t());
        return r.v + r.offset
    };
    return i.offset = 0,
    t && i
}, mi = {
    s: oh,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: Pu(function(s) {
        return arguments.length ? Ni.scrollTo(s, De.sc()) : Ni.pageXOffset || Gs[oh] || Hs[oh] || Bo[oh] || 0
    })
}, De = {
    s: ah,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: mi,
    sc: Pu(function(s) {
        return arguments.length ? Ni.scrollTo(mi.sc(), s) : Ni.pageYOffset || Gs[ah] || Hs[ah] || Bo[ah] || 0
    })
}, bi = function(t, e) {
    return (e && e._ctx && e._ctx.selector || ze.utils.toArray)(t)[0] || (typeof t == "string" && ze.config().nullTargetWarn !== !1 ? console.warn("Element not found:", t) : null)
}, Zs = function(t, e) {
    var i = e.s
      , r = e.sc;
    Za(t) && (t = Gs.scrollingElement || Hs);
    var n = Ot.indexOf(t)
      , o = r === De.sc ? 1 : 2;
    !~n && (n = Ot.push(t) - 1),
    Ot[n + o] || ai(t, "scroll", _f);
    var a = Ot[n + o]
      , l = a || (Ot[n + o] = Pu(Ws(t, i), !0) || (Za(t) ? r : Pu(function(h) {
        return arguments.length ? t[i] = h : t[i]
    })));
    return l.target = t,
    a || (l.smooth = ze.getProperty(t, "scrollBehavior") === "smooth"),
    l
}, yf = function(t, e, i) {
    var r = t
      , n = t
      , o = Ka()
      , a = o
      , l = e || 50
      , h = Math.max(500, l * 3)
      , u = function(p, m) {
        var g = Ka();
        m || g - o > l ? (n = r,
        r = p,
        a = o,
        o = g) : i ? r += p : r = n + (p - n) / (g - a) * (o - a)
    }
      , c = function() {
        n = r = i ? 0 : r,
        a = o = 0
    }
      , d = function(p) {
        var m = a
          , g = n
          , _ = Ka();
        return (p || p === 0) && p !== r && u(p),
        o === a || _ - a > h ? 0 : (r + (i ? g : -g)) / ((i ? _ : o) - m) * 1e3
    };
    return {
        update: u,
        reset: c,
        getVelocity: d
    }
}, pa = function(t, e) {
    return e && !t._gsapAllow && t.preventDefault(),
    t.changedTouches ? t.changedTouches[0] : t
}, $g = function(t) {
    var e = Math.max.apply(Math, t)
      , i = Math.min.apply(Math, t);
    return Math.abs(e) >= Math.abs(i) ? e : i
}, Uv = function() {
    Ya = ze.core.globals().ScrollTrigger,
    Ya && Ya.core && cT()
}, Gv = function(t) {
    return ze = t || Lv(),
    !Jh && ze && typeof document < "u" && document.body && (Ni = window,
    Gs = document,
    Hs = Gs.documentElement,
    Bo = Gs.body,
    Ov = [Ni, Gs, Hs, Bo],
    ze.utils.clamp,
    kv = ze.core.context || function() {}
    ,
    fn = "onpointerenter"in Bo ? "pointer" : "mouse",
    Bv = we.isTouch = Ni.matchMedia && Ni.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart"in Ni || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0,
    pr = we.eventTypes = ("ontouchstart"in Hs ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown"in Hs ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","),
    setTimeout(function() {
        return Nv = 0
    }, 500),
    Uv(),
    Jh = 1),
    Jh
};
mi.op = De;
Ot.cache = 0;
var we = function() {
    function s(e) {
        this.init(e)
    }
    var t = s.prototype;
    return t.init = function(i) {
        Jh || Gv(ze) || console.warn("Please gsap.registerPlugin(Observer)"),
        Ya || Uv();
        var r = i.tolerance
          , n = i.dragMinimum
          , o = i.type
          , a = i.target
          , l = i.lineHeight
          , h = i.debounce
          , u = i.preventDefault
          , c = i.onStop
          , d = i.onStopDelay
          , f = i.ignore
          , p = i.wheelSpeed
          , m = i.event
          , g = i.onDragStart
          , _ = i.onDragEnd
          , x = i.onDrag
          , y = i.onPress
          , v = i.onRelease
          , E = i.onRight
          , P = i.onLeft
          , w = i.onUp
          , A = i.onDown
          , I = i.onChangeX
          , F = i.onChangeY
          , O = i.onChange
          , B = i.onToggleX
          , S = i.onToggleY
          , T = i.onHover
          , M = i.onHoverEnd
          , D = i.onMove
          , C = i.ignoreCheck
          , k = i.isNormalizer
          , R = i.onGestureStart
          , b = i.onGestureEnd
          , L = i.onWheel
          , U = i.onEnable
          , Y = i.onDisable
          , $ = i.onClick
          , z = i.scrollSpeed
          , j = i.capture
          , W = i.allowClicks
          , X = i.lockAxis
          , et = i.onLockAxis;
        this.target = a = bi(a) || Hs,
        this.vars = i,
        f && (f = ze.utils.toArray(f)),
        r = r || 1e-9,
        n = n || 0,
        p = p || 1,
        z = z || 1,
        o = o || "wheel,touch,pointer",
        h = h !== !1,
        l || (l = parseFloat(Ni.getComputedStyle(Bo).lineHeight) || 22);
        var Q, q, tt, Z, ot, vt, It, H = this, Ct = 0, K = 0, G = Zs(a, mi), V = Zs(a, De), ut = G(), xt = V(), yt = ~o.indexOf("touch") && !~o.indexOf("pointer") && pr[0] === "pointerdown", bt = Za(a), Rt = a.ownerDocument || Gs, kt = [0, 0, 0], Wt = [0, 0, 0], jt = 0, Tt = function() {
            return jt = Ka()
        }, qt = function(gt, Ht) {
            return (H.event = gt) && f && ~f.indexOf(gt.target) || Ht && yt && gt.pointerType !== "touch" || C && C(gt, Ht)
        }, at = function() {
            H._vx.reset(),
            H._vy.reset(),
            q.pause(),
            c && c(H)
        }, Ve = function() {
            var gt = H.deltaX = $g(kt)
              , Ht = H.deltaY = $g(Wt)
              , ye = Math.abs(gt) >= r
              , lt = Math.abs(Ht) >= r;
            O && (ye || lt) && O(H, gt, Ht, kt, Wt),
            ye && (E && H.deltaX > 0 && E(H),
            P && H.deltaX < 0 && P(H),
            I && I(H),
            B && H.deltaX < 0 != Ct < 0 && B(H),
            Ct = H.deltaX,
            kt[0] = kt[1] = kt[2] = 0),
            lt && (A && H.deltaY > 0 && A(H),
            w && H.deltaY < 0 && w(H),
            F && F(H),
            S && H.deltaY < 0 != K < 0 && S(H),
            K = H.deltaY,
            Wt[0] = Wt[1] = Wt[2] = 0),
            (Z || tt) && (D && D(H),
            tt && (x(H),
            tt = !1),
            Z = !1),
            vt && !(vt = !1) && et && et(H),
            ot && (L(H),
            ot = !1),
            Q = 0
        }, Xe = function(gt, Ht, ye) {
            kt[ye] += gt,
            Wt[ye] += Ht,
            H._vx.update(gt),
            H._vy.update(Ht),
            h ? Q || (Q = requestAnimationFrame(Ve)) : Ve()
        }, si = function(gt, Ht) {
            X && !It && (H.axis = It = Math.abs(gt) > Math.abs(Ht) ? "x" : "y",
            vt = !0),
            It !== "y" && (kt[2] += gt,
            H._vx.update(gt, !0)),
            It !== "x" && (Wt[2] += Ht,
            H._vy.update(Ht, !0)),
            h ? Q || (Q = requestAnimationFrame(Ve)) : Ve()
        }, Wi = function(gt) {
            if (!qt(gt, 1)) {
                gt = pa(gt, u);
                var Ht = gt.clientX
                  , ye = gt.clientY
                  , lt = Ht - H.x
                  , Ft = ye - H.y
                  , Dt = H.isDragging;
                H.x = Ht,
                H.y = ye,
                (Dt || Math.abs(H.startX - Ht) >= n || Math.abs(H.startY - ye) >= n) && (x && (tt = !0),
                Dt || (H.isDragging = !0),
                si(lt, Ft),
                Dt || g && g(H))
            }
        }, yi = H.onPress = function(wt) {
            qt(wt, 1) || wt && wt.button || (H.axis = It = null,
            q.pause(),
            H.isPressed = !0,
            wt = pa(wt),
            Ct = K = 0,
            H.startX = H.x = wt.clientX,
            H.startY = H.y = wt.clientY,
            H._vx.reset(),
            H._vy.reset(),
            ai(k ? a : Rt, pr[1], Wi, u, !0),
            H.deltaX = H.deltaY = 0,
            y && y(H))
        }
        , vi = H.onRelease = function(wt) {
            if (!qt(wt, 1)) {
                oi(k ? a : Rt, pr[1], Wi, !0);
                var gt = !isNaN(H.y - H.startY)
                  , Ht = H.isDragging
                  , ye = Ht && (Math.abs(H.x - H.startX) > 3 || Math.abs(H.y - H.startY) > 3)
                  , lt = pa(wt);
                !ye && gt && (H._vx.reset(),
                H._vy.reset(),
                u && W && ze.delayedCall(.08, function() {
                    if (Ka() - jt > 300 && !wt.defaultPrevented) {
                        if (wt.target.click)
                            wt.target.click();
                        else if (Rt.createEvent) {
                            var Ft = Rt.createEvent("MouseEvents");
                            Ft.initMouseEvent("click", !0, !0, Ni, 1, lt.screenX, lt.screenY, lt.clientX, lt.clientY, !1, !1, !1, !1, 0, null),
                            wt.target.dispatchEvent(Ft)
                        }
                    }
                })),
                H.isDragging = H.isGesturing = H.isPressed = !1,
                c && Ht && !k && q.restart(!0),
                _ && Ht && _(H),
                v && v(H, ye)
            }
        }
        , pt = function(gt) {
            return gt.touches && gt.touches.length > 1 && (H.isGesturing = !0) && R(gt, H.isDragging)
        }, Cr = function() {
            return (H.isGesturing = !1) || b(H)
        }, Ae = function(gt) {
            if (!qt(gt)) {
                var Ht = G()
                  , ye = V();
                Xe((Ht - ut) * z, (ye - xt) * z, 1),
                ut = Ht,
                xt = ye,
                c && q.restart(!0)
            }
        }, Xt = function(gt) {
            if (!qt(gt)) {
                gt = pa(gt, u),
                L && (ot = !0);
                var Ht = (gt.deltaMode === 1 ? l : gt.deltaMode === 2 ? Ni.innerHeight : 1) * p;
                Xe(gt.deltaX * Ht, gt.deltaY * Ht, 0),
                c && !k && q.restart(!0)
            }
        }, ee = function(gt) {
            if (!qt(gt)) {
                var Ht = gt.clientX
                  , ye = gt.clientY
                  , lt = Ht - H.x
                  , Ft = ye - H.y;
                H.x = Ht,
                H.y = ye,
                Z = !0,
                c && q.restart(!0),
                (lt || Ft) && si(lt, Ft)
            }
        }, Ci = function(gt) {
            H.event = gt,
            T(H)
        }, ur = function(gt) {
            H.event = gt,
            M(H)
        }, _e = function(gt) {
            return qt(gt) || pa(gt, u) && $(H)
        };
        q = H._dc = ze.delayedCall(d || .25, at).pause(),
        H.deltaX = H.deltaY = 0,
        H._vx = yf(0, 50, !0),
        H._vy = yf(0, 50, !0),
        H.scrollX = G,
        H.scrollY = V,
        H.isDragging = H.isGesturing = H.isPressed = !1,
        kv(this),
        H.enable = function(wt) {
            return H.isEnabled || (ai(bt ? Rt : a, "scroll", _f),
            o.indexOf("scroll") >= 0 && ai(bt ? Rt : a, "scroll", Ae, u, j),
            o.indexOf("wheel") >= 0 && ai(a, "wheel", Xt, u, j),
            (o.indexOf("touch") >= 0 && Bv || o.indexOf("pointer") >= 0) && (ai(a, pr[0], yi, u, j),
            ai(Rt, pr[2], vi),
            ai(Rt, pr[3], vi),
            W && ai(a, "click", Tt, !1, !0),
            $ && ai(a, "click", _e),
            R && ai(Rt, "gesturestart", pt),
            b && ai(Rt, "gestureend", Cr),
            T && ai(a, fn + "enter", Ci),
            M && ai(a, fn + "leave", ur),
            D && ai(a, fn + "move", ee)),
            H.isEnabled = !0,
            wt && wt.type && yi(wt),
            U && U(H)),
            H
        }
        ,
        H.disable = function() {
            H.isEnabled && (To.filter(function(wt) {
                return wt !== H && Za(wt.target)
            }).length || oi(bt ? Rt : a, "scroll", _f),
            H.isPressed && (H._vx.reset(),
            H._vy.reset(),
            oi(k ? a : Rt, pr[1], Wi, !0)),
            oi(bt ? Rt : a, "scroll", Ae, j),
            oi(a, "wheel", Xt, j),
            oi(a, pr[0], yi, j),
            oi(Rt, pr[2], vi),
            oi(Rt, pr[3], vi),
            oi(a, "click", Tt, !0),
            oi(a, "click", _e),
            oi(Rt, "gesturestart", pt),
            oi(Rt, "gestureend", Cr),
            oi(a, fn + "enter", Ci),
            oi(a, fn + "leave", ur),
            oi(a, fn + "move", ee),
            H.isEnabled = H.isPressed = H.isDragging = !1,
            Y && Y(H))
        }
        ,
        H.kill = H.revert = function() {
            H.disable();
            var wt = To.indexOf(H);
            wt >= 0 && To.splice(wt, 1),
            fs === H && (fs = 0)
        }
        ,
        To.push(H),
        k && Za(a) && (fs = H),
        H.enable(m)
    }
    ,
    uT(s, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]),
    s
}();
we.version = "3.12.3";
we.create = function(s) {
    return new we(s)
}
;
we.register = Gv;
we.getAll = function() {
    return To.slice()
}
;
we.getById = function(s) {
    return To.filter(function(t) {
        return t.vars.id === s
    })[0]
}
;
Lv() && ze.registerPlugin(we);
/*!
 * ScrollTrigger 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var ht, ho, Ut, oe, gr, Jt, Hv, Iu, Dl, Do, tu, lh, qe, vc, vf, hi, zg, Vg, uo, $v, Kc, zv, li, Vv, Xv, Wv, Ss, xf, im, Oo, rm, sm, bf, Zc, hh = 1, fi = Date.now, Qc = fi(), or = 0, Ia = 0, Xg = function(t, e, i) {
    var r = Fi(t) && (t.substr(0, 6) === "clamp(" || t.indexOf("max") > -1);
    return i["_" + e + "Clamp"] = r,
    r ? t.substr(6, t.length - 7) : t
}, Wg = function(t, e) {
    return e && (!Fi(t) || t.substr(0, 6) !== "clamp(") ? "clamp(" + t + ")" : t
}, dT = function s() {
    return Ia && requestAnimationFrame(s)
}, jg = function() {
    return vc = 1
}, qg = function() {
    return vc = 0
}, Gr = function(t) {
    return t
}, Ra = function(t) {
    return Math.round(t * 1e5) / 1e5 || 0
}, jv = function() {
    return typeof window < "u"
}, qv = function() {
    return ht || jv() && (ht = window.gsap) && ht.registerPlugin && ht
}, zn = function(t) {
    return !!~Hv.indexOf(t)
}, Yv = function(t) {
    return (t === "Height" ? rm : Ut["inner" + t]) || gr["client" + t] || Jt["client" + t]
}, Kv = function(t) {
    return Ws(t, "getBoundingClientRect") || (zn(t) ? function() {
        return ou.width = Ut.innerWidth,
        ou.height = rm,
        ou
    }
    : function() {
        return ds(t)
    }
    )
}, fT = function(t, e, i) {
    var r = i.d
      , n = i.d2
      , o = i.a;
    return (o = Ws(t, "getBoundingClientRect")) ? function() {
        return o()[r]
    }
    : function() {
        return (e ? Yv(n) : t["client" + n]) || 0
    }
}, pT = function(t, e) {
    return !e || ~Zr.indexOf(t) ? Kv(t) : function() {
        return ou
    }
}, Xr = function(t, e) {
    var i = e.s
      , r = e.d2
      , n = e.d
      , o = e.a;
    return Math.max(0, (i = "scroll" + r) && (o = Ws(t, i)) ? o() - Kv(t)()[n] : zn(t) ? (gr[i] || Jt[i]) - Yv(r) : t[i] - t["offset" + r])
}, uh = function(t, e) {
    for (var i = 0; i < uo.length; i += 3)
        (!e || ~e.indexOf(uo[i + 1])) && t(uo[i], uo[i + 1], uo[i + 2])
}, Fi = function(t) {
    return typeof t == "string"
}, gi = function(t) {
    return typeof t == "function"
}, eu = function(t) {
    return typeof t == "number"
}, pn = function(t) {
    return typeof t == "object"
}, ma = function(t, e, i) {
    return t && t.progress(e ? 0 : 1) && i && t.pause()
}, Jc = function(t, e) {
    if (t.enabled) {
        var i = t._ctx ? t._ctx.add(function() {
            return e(t)
        }) : e(t);
        i && i.totalTime && (t.callbackAnimation = i)
    }
}, eo = Math.abs, Zv = "left", Qv = "top", nm = "right", om = "bottom", Rn = "width", Mn = "height", Qa = "Right", Ja = "Left", tl = "Top", el = "Bottom", xe = "padding", tr = "margin", Zo = "Width", am = "Height", Ie = "px", er = function(t) {
    return Ut.getComputedStyle(t)
}, mT = function(t) {
    var e = er(t).position;
    t.style.position = e === "absolute" || e === "fixed" ? e : "relative"
}, Yg = function(t, e) {
    for (var i in e)
        i in t || (t[i] = e[i]);
    return t
}, ds = function(t, e) {
    var i = e && er(t)[vf] !== "matrix(1, 0, 0, 1, 0, 0)" && ht.to(t, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
    }).progress(1)
      , r = t.getBoundingClientRect();
    return i && i.progress(0).kill(),
    r
}, wf = function(t, e) {
    var i = e.d2;
    return t["offset" + i] || t["client" + i] || 0
}, Jv = function(t) {
    var e = [], i = t.labels, r = t.duration(), n;
    for (n in i)
        e.push(i[n] / r);
    return e
}, gT = function(t) {
    return function(e) {
        return ht.utils.snap(Jv(t), e)
    }
}, lm = function(t) {
    var e = ht.utils.snap(t)
      , i = Array.isArray(t) && t.slice(0).sort(function(r, n) {
        return r - n
    });
    return i ? function(r, n, o) {
        o === void 0 && (o = .001);
        var a;
        if (!n)
            return e(r);
        if (n > 0) {
            for (r -= o,
            a = 0; a < i.length; a++)
                if (i[a] >= r)
                    return i[a];
            return i[a - 1]
        } else
            for (a = i.length,
            r += o; a--; )
                if (i[a] <= r)
                    return i[a];
        return i[0]
    }
    : function(r, n, o) {
        o === void 0 && (o = .001);
        var a = e(r);
        return !n || Math.abs(a - r) < o || a - r < 0 == n < 0 ? a : e(n < 0 ? r - t : r + t)
    }
}, _T = function(t) {
    return function(e, i) {
        return lm(Jv(t))(e, i.direction)
    }
}, ch = function(t, e, i, r) {
    return i.split(",").forEach(function(n) {
        return t(e, n, r)
    })
}, Be = function(t, e, i, r, n) {
    return t.addEventListener(e, i, {
        passive: !r,
        capture: !!n
    })
}, Re = function(t, e, i, r) {
    return t.removeEventListener(e, i, !!r)
}, dh = function(t, e, i) {
    i = i && i.wheelHandler,
    i && (t(e, "wheel", i),
    t(e, "touchmove", i))
}, Kg = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
}, fh = {
    toggleActions: "play",
    anticipatePin: 0
}, Ru = {
    top: 0,
    left: 0,
    center: .5,
    bottom: 1,
    right: 1
}, iu = function(t, e) {
    if (Fi(t)) {
        var i = t.indexOf("=")
          , r = ~i ? +(t.charAt(i - 1) + 1) * parseFloat(t.substr(i + 1)) : 0;
        ~i && (t.indexOf("%") > i && (r *= e / 100),
        t = t.substr(0, i - 1)),
        t = r + (t in Ru ? Ru[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
    }
    return t
}, ph = function(t, e, i, r, n, o, a, l) {
    var h = n.startColor
      , u = n.endColor
      , c = n.fontSize
      , d = n.indent
      , f = n.fontWeight
      , p = oe.createElement("div")
      , m = zn(i) || Ws(i, "pinType") === "fixed"
      , g = t.indexOf("scroller") !== -1
      , _ = m ? Jt : i
      , x = t.indexOf("start") !== -1
      , y = x ? h : u
      , v = "border-color:" + y + ";font-size:" + c + ";color:" + y + ";font-weight:" + f + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return v += "position:" + ((g || l) && m ? "fixed;" : "absolute;"),
    (g || l || !m) && (v += (r === De ? nm : om) + ":" + (o + parseFloat(d)) + "px;"),
    a && (v += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"),
    p._isStart = x,
    p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
    p.style.cssText = v,
    p.innerText = e || e === 0 ? t + "-" + e : t,
    _.children[0] ? _.insertBefore(p, _.children[0]) : _.appendChild(p),
    p._offset = p["offset" + r.op.d2],
    ru(p, 0, r, x),
    p
}, ru = function(t, e, i, r) {
    var n = {
        display: "block"
    }
      , o = i[r ? "os2" : "p2"]
      , a = i[r ? "p2" : "os2"];
    t._isFlipped = r,
    n[i.a + "Percent"] = r ? -100 : 0,
    n[i.a] = r ? "1px" : 0,
    n["border" + o + Zo] = 1,
    n["border" + a + Zo] = 0,
    n[i.p] = e + "px",
    ht.set(t, n)
}, Mt = [], Ef = {}, Al, Zg = function() {
    return fi() - or > 34 && (Al || (Al = requestAnimationFrame(ys)))
}, io = function() {
    (!li || !li.isPressed || li.startX > Jt.clientWidth) && (Ot.cache++,
    li ? Al || (Al = requestAnimationFrame(ys)) : ys(),
    or || Xn("scrollStart"),
    or = fi())
}, td = function() {
    Wv = Ut.innerWidth,
    Xv = Ut.innerHeight
}, Ma = function() {
    Ot.cache++,
    !qe && !zv && !oe.fullscreenElement && !oe.webkitFullscreenElement && (!Vv || Wv !== Ut.innerWidth || Math.abs(Ut.innerHeight - Xv) > Ut.innerHeight * .25) && Iu.restart(!0)
}, Vn = {}, yT = [], tx = function s() {
    return Re(mt, "scrollEnd", s) || Dn(!0)
}, Xn = function(t) {
    return Vn[t] && Vn[t].map(function(e) {
        return e()
    }) || yT
}, Mi = [], ex = function(t) {
    for (var e = 0; e < Mi.length; e += 5)
        (!t || Mi[e + 4] && Mi[e + 4].query === t) && (Mi[e].style.cssText = Mi[e + 1],
        Mi[e].getBBox && Mi[e].setAttribute("transform", Mi[e + 2] || ""),
        Mi[e + 3].uncache = 1)
}, hm = function(t, e) {
    var i;
    for (hi = 0; hi < Mt.length; hi++)
        i = Mt[hi],
        i && (!e || i._ctx === e) && (t ? i.kill(1) : i.revert(!0, !0));
    sm = !0,
    e && ex(e),
    e || Xn("revert")
}, ix = function(t, e) {
    Ot.cache++,
    (e || !ui) && Ot.forEach(function(i) {
        return gi(i) && i.cacheID++ && (i.rec = 0)
    }),
    Fi(t) && (Ut.history.scrollRestoration = im = t)
}, ui, Fn = 0, Qg, vT = function() {
    if (Qg !== Fn) {
        var t = Qg = Fn;
        requestAnimationFrame(function() {
            return t === Fn && Dn(!0)
        })
    }
}, rx = function() {
    Jt.appendChild(Oo),
    rm = !li && Oo.offsetHeight || Ut.innerHeight,
    Jt.removeChild(Oo)
}, Jg = function(t) {
    return Dl(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(e) {
        return e.style.display = t ? "none" : "block"
    })
}, Dn = function(t, e) {
    if (or && !t) {
        Be(mt, "scrollEnd", tx);
        return
    }
    rx(),
    ui = mt.isRefreshing = !0,
    Ot.forEach(function(r) {
        return gi(r) && ++r.cacheID && (r.rec = r())
    });
    var i = Xn("refreshInit");
    $v && mt.sort(),
    e || hm(),
    Ot.forEach(function(r) {
        gi(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"),
        r(0))
    }),
    Mt.slice(0).forEach(function(r) {
        return r.refresh()
    }),
    sm = !1,
    Mt.forEach(function(r) {
        if (r._subPinOffset && r.pin) {
            var n = r.vars.horizontal ? "offsetWidth" : "offsetHeight"
              , o = r.pin[n];
            r.revert(!0, 1),
            r.adjustPinSpacing(r.pin[n] - o),
            r.refresh()
        }
    }),
    bf = 1,
    Jg(!0),
    Mt.forEach(function(r) {
        var n = Xr(r.scroller, r._dir)
          , o = r.vars.end === "max" || r._endClamp && r.end > n
          , a = r._startClamp && r.start >= n;
        (o || a) && r.setPositions(a ? n - 1 : r.start, o ? Math.max(a ? n : r.start + 1, n) : r.end, !0)
    }),
    Jg(!1),
    bf = 0,
    i.forEach(function(r) {
        return r && r.render && r.render(-1)
    }),
    Ot.forEach(function(r) {
        gi(r) && (r.smooth && requestAnimationFrame(function() {
            return r.target.style.scrollBehavior = "smooth"
        }),
        r.rec && r(r.rec))
    }),
    ix(im, 1),
    Iu.pause(),
    Fn++,
    ui = 2,
    ys(2),
    Mt.forEach(function(r) {
        return gi(r.vars.onRefresh) && r.vars.onRefresh(r)
    }),
    ui = mt.isRefreshing = !1,
    Xn("refresh")
}, Tf = 0, su = 1, il, ys = function(t) {
    if (t === 2 || !ui && !sm) {
        mt.isUpdating = !0,
        il && il.update(0);
        var e = Mt.length
          , i = fi()
          , r = i - Qc >= 50
          , n = e && Mt[0].scroll();
        if (su = Tf > n ? -1 : 1,
        ui || (Tf = n),
        r && (or && !vc && i - or > 200 && (or = 0,
        Xn("scrollEnd")),
        tu = Qc,
        Qc = i),
        su < 0) {
            for (hi = e; hi-- > 0; )
                Mt[hi] && Mt[hi].update(0, r);
            su = 1
        } else
            for (hi = 0; hi < e; hi++)
                Mt[hi] && Mt[hi].update(0, r);
        mt.isUpdating = !1
    }
    Al = 0
}, Df = [Zv, Qv, om, nm, tr + el, tr + Qa, tr + tl, tr + Ja, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], nu = Df.concat([Rn, Mn, "boxSizing", "max" + Zo, "max" + am, "position", tr, xe, xe + tl, xe + Qa, xe + el, xe + Ja]), xT = function(t, e, i) {
    ko(i);
    var r = t._gsap;
    if (r.spacerIsNative)
        ko(r.spacerState);
    else if (t._gsap.swappedIn) {
        var n = e.parentNode;
        n && (n.insertBefore(t, e),
        n.removeChild(e))
    }
    t._gsap.swappedIn = !1
}, ed = function(t, e, i, r) {
    if (!t._gsap.swappedIn) {
        for (var n = Df.length, o = e.style, a = t.style, l; n--; )
            l = Df[n],
            o[l] = i[l];
        o.position = i.position === "absolute" ? "absolute" : "relative",
        i.display === "inline" && (o.display = "inline-block"),
        a[om] = a[nm] = "auto",
        o.flexBasis = i.flexBasis || "auto",
        o.overflow = "visible",
        o.boxSizing = "border-box",
        o[Rn] = wf(t, mi) + Ie,
        o[Mn] = wf(t, De) + Ie,
        o[xe] = a[tr] = a[Qv] = a[Zv] = "0",
        ko(r),
        a[Rn] = a["max" + Zo] = i[Rn],
        a[Mn] = a["max" + am] = i[Mn],
        a[xe] = i[xe],
        t.parentNode !== e && (t.parentNode.insertBefore(e, t),
        e.appendChild(t)),
        t._gsap.swappedIn = !0
    }
}, bT = /([A-Z])/g, ko = function(t) {
    if (t) {
        var e = t.t.style, i = t.length, r = 0, n, o;
        for ((t.t._gsap || ht.core.getCache(t.t)).uncache = 1; r < i; r += 2)
            o = t[r + 1],
            n = t[r],
            o ? e[n] = o : e[n] && e.removeProperty(n.replace(bT, "-$1").toLowerCase())
    }
}, mh = function(t) {
    for (var e = nu.length, i = t.style, r = [], n = 0; n < e; n++)
        r.push(nu[n], i[nu[n]]);
    return r.t = t,
    r
}, wT = function(t, e, i) {
    for (var r = [], n = t.length, o = i ? 8 : 0, a; o < n; o += 2)
        a = t[o],
        r.push(a, a in e ? e[a] : t[o + 1]);
    return r.t = t.t,
    r
}, ou = {
    left: 0,
    top: 0
}, t0 = function(t, e, i, r, n, o, a, l, h, u, c, d, f, p) {
    gi(t) && (t = t(l)),
    Fi(t) && t.substr(0, 3) === "max" && (t = d + (t.charAt(4) === "=" ? iu("0" + t.substr(3), i) : 0));
    var m = f ? f.time() : 0, g, _, x;
    if (f && f.seek(0),
    isNaN(t) || (t = +t),
    eu(t))
        f && (t = ht.utils.mapRange(f.scrollTrigger.start, f.scrollTrigger.end, 0, d, t)),
        a && ru(a, i, r, !0);
    else {
        gi(e) && (e = e(l));
        var y = (t || "0").split(" "), v, E, P, w;
        x = bi(e, l) || Jt,
        v = ds(x) || {},
        (!v || !v.left && !v.top) && er(x).display === "none" && (w = x.style.display,
        x.style.display = "block",
        v = ds(x),
        w ? x.style.display = w : x.style.removeProperty("display")),
        E = iu(y[0], v[r.d]),
        P = iu(y[1] || "0", i),
        t = v[r.p] - h[r.p] - u + E + n - P,
        a && ru(a, P, r, i - P < 20 || a._isStart && P > 20),
        i -= i - P
    }
    if (p && (l[p] = t || -.001,
    t < 0 && (t = 0)),
    o) {
        var A = t + i
          , I = o._isStart;
        g = "scroll" + r.d2,
        ru(o, A, r, I && A > 20 || !I && (c ? Math.max(Jt[g], gr[g]) : o.parentNode[g]) <= A + 1),
        c && (h = ds(a),
        c && (o.style[r.op.p] = h[r.op.p] - r.op.m - o._offset + Ie))
    }
    return f && x && (g = ds(x),
    f.seek(d),
    _ = ds(x),
    f._caScrollDist = g[r.p] - _[r.p],
    t = t / f._caScrollDist * d),
    f && f.seek(m),
    f ? t : Math.round(t)
}, ET = /(webkit|moz|length|cssText|inset)/i, e0 = function(t, e, i, r) {
    if (t.parentNode !== e) {
        var n = t.style, o, a;
        if (e === Jt) {
            t._stOrig = n.cssText,
            a = er(t);
            for (o in a)
                !+o && !ET.test(o) && a[o] && typeof n[o] == "string" && o !== "0" && (n[o] = a[o]);
            n.top = i,
            n.left = r
        } else
            n.cssText = t._stOrig;
        ht.core.getCache(t).uncache = 1,
        e.appendChild(t)
    }
}, sx = function(t, e, i) {
    var r = e
      , n = r;
    return function(o) {
        var a = Math.round(t());
        return a !== r && a !== n && Math.abs(a - r) > 3 && Math.abs(a - n) > 3 && (o = a,
        i && i()),
        n = r,
        r = o,
        o
    }
}, gh = function(t, e, i) {
    var r = {};
    r[e.p] = "+=" + i,
    ht.set(t, r)
}, i0 = function(t, e) {
    var i = Zs(t, e)
      , r = "_scroll" + e.p2
      , n = function o(a, l, h, u, c) {
        var d = o.tween
          , f = l.onComplete
          , p = {};
        h = h || i();
        var m = sx(i, h, function() {
            d.kill(),
            o.tween = 0
        });
        return c = u && c || 0,
        u = u || a - h,
        d && d.kill(),
        l[r] = a,
        l.modifiers = p,
        p[r] = function() {
            return m(h + u * d.ratio + c * d.ratio * d.ratio)
        }
        ,
        l.onUpdate = function() {
            Ot.cache++,
            o.tween && ys()
        }
        ,
        l.onComplete = function() {
            o.tween = 0,
            f && f.call(d)
        }
        ,
        d = o.tween = ht.to(t, l),
        d
    };
    return t[r] = i,
    i.wheelHandler = function() {
        return n.tween && n.tween.kill() && (n.tween = 0)
    }
    ,
    Be(t, "wheel", i.wheelHandler),
    mt.isTouch && Be(t, "touchmove", i.wheelHandler),
    n
}, mt = function() {
    function s(e, i) {
        ho || s.register(ht) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
        xf(this),
        this.init(e, i)
    }
    var t = s.prototype;
    return t.init = function(i, r) {
        if (this.progress = this.start = 0,
        this.vars && this.kill(!0, !0),
        !Ia) {
            this.update = this.refresh = this.kill = Gr;
            return
        }
        i = Yg(Fi(i) || eu(i) || i.nodeType ? {
            trigger: i
        } : i, fh);
        var n = i, o = n.onUpdate, a = n.toggleClass, l = n.id, h = n.onToggle, u = n.onRefresh, c = n.scrub, d = n.trigger, f = n.pin, p = n.pinSpacing, m = n.invalidateOnRefresh, g = n.anticipatePin, _ = n.onScrubComplete, x = n.onSnapComplete, y = n.once, v = n.snap, E = n.pinReparent, P = n.pinSpacer, w = n.containerAnimation, A = n.fastScrollEnd, I = n.preventOverlaps, F = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? mi : De, O = !c && c !== 0, B = bi(i.scroller || Ut), S = ht.core.getCache(B), T = zn(B), M = ("pinType"in i ? i.pinType : Ws(B, "pinType") || T && "fixed") === "fixed", D = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], C = O && i.toggleActions.split(" "), k = "markers"in i ? i.markers : fh.markers, R = T ? 0 : parseFloat(er(B)["border" + F.p2 + Zo]) || 0, b = this, L = i.onRefreshInit && function() {
            return i.onRefreshInit(b)
        }
        , U = fT(B, T, F), Y = pT(B, T), $ = 0, z = 0, j = 0, W = Zs(B, F), X, et, Q, q, tt, Z, ot, vt, It, H, Ct, K, G, V, ut, xt, yt, bt, Rt, kt, Wt, jt, Tt, qt, at, Ve, Xe, si, Wi, yi, vi, pt, Cr, Ae, Xt, ee, Ci, ur, _e;
        if (b._startClamp = b._endClamp = !1,
        b._dir = F,
        g *= 45,
        b.scroller = B,
        b.scroll = w ? w.time.bind(w) : W,
        q = W(),
        b.vars = i,
        r = r || i.animation,
        "refreshPriority"in i && ($v = 1,
        i.refreshPriority === -9999 && (il = b)),
        S.tweenScroll = S.tweenScroll || {
            top: i0(B, De),
            left: i0(B, mi)
        },
        b.tweenTo = X = S.tweenScroll[F.p],
        b.scrubDuration = function(lt) {
            Cr = eu(lt) && lt,
            Cr ? pt ? pt.duration(lt) : pt = ht.to(r, {
                ease: "expo",
                totalProgress: "+=0",
                duration: Cr,
                paused: !0,
                onComplete: function() {
                    return _ && _(b)
                }
            }) : (pt && pt.progress(1).kill(),
            pt = 0)
        }
        ,
        r && (r.vars.lazy = !1,
        r._initted && !b.isReverted || r.vars.immediateRender !== !1 && i.immediateRender !== !1 && r.duration() && r.render(0, !0, !0),
        b.animation = r.pause(),
        r.scrollTrigger = b,
        b.scrubDuration(c),
        yi = 0,
        l || (l = r.vars.id)),
        v && ((!pn(v) || v.push) && (v = {
            snapTo: v
        }),
        "scrollBehavior"in Jt.style && ht.set(T ? [Jt, gr] : B, {
            scrollBehavior: "auto"
        }),
        Ot.forEach(function(lt) {
            return gi(lt) && lt.target === (T ? oe.scrollingElement || gr : B) && (lt.smooth = !1)
        }),
        Q = gi(v.snapTo) ? v.snapTo : v.snapTo === "labels" ? gT(r) : v.snapTo === "labelsDirectional" ? _T(r) : v.directional !== !1 ? function(lt, Ft) {
            return lm(v.snapTo)(lt, fi() - z < 500 ? 0 : Ft.direction)
        }
        : ht.utils.snap(v.snapTo),
        Ae = v.duration || {
            min: .1,
            max: 2
        },
        Ae = pn(Ae) ? Do(Ae.min, Ae.max) : Do(Ae, Ae),
        Xt = ht.delayedCall(v.delay || Cr / 2 || .1, function() {
            var lt = W()
              , Ft = fi() - z < 500
              , Dt = X.tween;
            if ((Ft || Math.abs(b.getVelocity()) < 10) && !Dt && !vc && $ !== lt) {
                var Bt = (lt - Z) / V
                  , Se = r && !O ? r.totalProgress() : Bt
                  , $t = Ft ? 0 : (Se - vi) / (fi() - tu) * 1e3 || 0
                  , pe = ht.utils.clamp(-Bt, 1 - Bt, eo($t / 2) * $t / .185)
                  , ni = Bt + (v.inertia === !1 ? 0 : pe)
                  , Ce = Do(0, 1, Q(ni, b))
                  , se = Math.round(Z + Ce * V)
                  , Yt = v
                  , cr = Yt.onStart
                  , ne = Yt.onInterrupt
                  , Pi = Yt.onComplete;
                if (lt <= ot && lt >= Z && se !== lt) {
                    if (Dt && !Dt._initted && Dt.data <= eo(se - lt))
                        return;
                    v.inertia === !1 && (pe = Ce - Bt),
                    X(se, {
                        duration: Ae(eo(Math.max(eo(ni - Se), eo(Ce - Se)) * .185 / $t / .05 || 0)),
                        ease: v.ease || "power3",
                        data: eo(se - lt),
                        onInterrupt: function() {
                            return Xt.restart(!0) && ne && ne(b)
                        },
                        onComplete: function() {
                            b.update(),
                            $ = W(),
                            pt && r && r.progress(Ce),
                            yi = vi = r && !O ? r.totalProgress() : b.progress,
                            x && x(b),
                            Pi && Pi(b)
                        }
                    }, lt, pe * V, se - lt - pe * V),
                    cr && cr(b, X.tween)
                }
            } else
                b.isActive && $ !== lt && Xt.restart(!0)
        }).pause()),
        l && (Ef[l] = b),
        d = b.trigger = bi(d || f !== !0 && f),
        _e = d && d._gsap && d._gsap.stRevert,
        _e && (_e = _e(b)),
        f = f === !0 ? d : bi(f),
        Fi(a) && (a = {
            targets: d,
            className: a
        }),
        f && (p === !1 || p === tr || (p = !p && f.parentNode && f.parentNode.style && er(f.parentNode).display === "flex" ? !1 : xe),
        b.pin = f,
        et = ht.core.getCache(f),
        et.spacer ? ut = et.pinState : (P && (P = bi(P),
        P && !P.nodeType && (P = P.current || P.nativeElement),
        et.spacerIsNative = !!P,
        P && (et.spacerState = mh(P))),
        et.spacer = bt = P || oe.createElement("div"),
        bt.classList.add("pin-spacer"),
        l && bt.classList.add("pin-spacer-" + l),
        et.pinState = ut = mh(f)),
        i.force3D !== !1 && ht.set(f, {
            force3D: !0
        }),
        b.spacer = bt = et.spacer,
        Wi = er(f),
        qt = Wi[p + F.os2],
        kt = ht.getProperty(f),
        Wt = ht.quickSetter(f, F.a, Ie),
        ed(f, bt, Wi),
        yt = mh(f)),
        k) {
            K = pn(k) ? Yg(k, Kg) : Kg,
            H = ph("scroller-start", l, B, F, K, 0),
            Ct = ph("scroller-end", l, B, F, K, 0, H),
            Rt = H["offset" + F.op.d2];
            var wt = bi(Ws(B, "content") || B);
            vt = this.markerStart = ph("start", l, wt, F, K, Rt, 0, w),
            It = this.markerEnd = ph("end", l, wt, F, K, Rt, 0, w),
            w && (ur = ht.quickSetter([vt, It], F.a, Ie)),
            !M && !(Zr.length && Ws(B, "fixedMarkers") === !0) && (mT(T ? Jt : B),
            ht.set([H, Ct], {
                force3D: !0
            }),
            Ve = ht.quickSetter(H, F.a, Ie),
            si = ht.quickSetter(Ct, F.a, Ie))
        }
        if (w) {
            var gt = w.vars.onUpdate
              , Ht = w.vars.onUpdateParams;
            w.eventCallback("onUpdate", function() {
                b.update(0, 0, 1),
                gt && gt.apply(w, Ht || [])
            })
        }
        if (b.previous = function() {
            return Mt[Mt.indexOf(b) - 1]
        }
        ,
        b.next = function() {
            return Mt[Mt.indexOf(b) + 1]
        }
        ,
        b.revert = function(lt, Ft) {
            if (!Ft)
                return b.kill(!0);
            var Dt = lt !== !1 || !b.enabled
              , Bt = qe;
            Dt !== b.isReverted && (Dt && (ee = Math.max(W(), b.scroll.rec || 0),
            j = b.progress,
            Ci = r && r.progress()),
            vt && [vt, It, H, Ct].forEach(function(Se) {
                return Se.style.display = Dt ? "none" : "block"
            }),
            Dt && (qe = b,
            b.update(Dt)),
            f && (!E || !b.isActive) && (Dt ? xT(f, bt, ut) : ed(f, bt, er(f), at)),
            Dt || b.update(Dt),
            qe = Bt,
            b.isReverted = Dt)
        }
        ,
        b.refresh = function(lt, Ft, Dt, Bt) {
            if (!((qe || !b.enabled) && !Ft)) {
                if (f && lt && or) {
                    Be(s, "scrollEnd", tx);
                    return
                }
                !ui && L && L(b),
                qe = b,
                X.tween && !Dt && (X.tween.kill(),
                X.tween = 0),
                pt && pt.pause(),
                m && r && r.revert({
                    kill: !1
                }).invalidate(),
                b.isReverted || b.revert(!0, !0),
                b._subPinOffset = !1;
                var Se = U(), $t = Y(), pe = w ? w.duration() : Xr(B, F), ni = V <= .01, Ce = 0, se = Bt || 0, Yt = pn(Dt) ? Dt.end : i.end, cr = i.endTrigger || d, ne = pn(Dt) ? Dt.start : i.start || (i.start === 0 || !d ? 0 : f ? "0 0" : "0 100%"), Pi = b.pinnedContainer = i.pinnedContainer && bi(i.pinnedContainer, b), Pr = d && Math.max(0, Mt.indexOf(b)) || 0, xi = Pr, He, We, on, rh, je, Te, Ir, Nc, xg, ha, Rr, ua, sh;
                for (k && pn(Dt) && (ua = ht.getProperty(H, F.p),
                sh = ht.getProperty(Ct, F.p)); xi--; )
                    Te = Mt[xi],
                    Te.end || Te.refresh(0, 1) || (qe = b),
                    Ir = Te.pin,
                    Ir && (Ir === d || Ir === f || Ir === Pi) && !Te.isReverted && (ha || (ha = []),
                    ha.unshift(Te),
                    Te.revert(!0, !0)),
                    Te !== Mt[xi] && (Pr--,
                    xi--);
                for (gi(ne) && (ne = ne(b)),
                ne = Xg(ne, "start", b),
                Z = t0(ne, d, Se, F, W(), vt, H, b, $t, R, M, pe, w, b._startClamp && "_startClamp") || (f ? -.001 : 0),
                gi(Yt) && (Yt = Yt(b)),
                Fi(Yt) && !Yt.indexOf("+=") && (~Yt.indexOf(" ") ? Yt = (Fi(ne) ? ne.split(" ")[0] : "") + Yt : (Ce = iu(Yt.substr(2), Se),
                Yt = Fi(ne) ? ne : (w ? ht.utils.mapRange(0, w.duration(), w.scrollTrigger.start, w.scrollTrigger.end, Z) : Z) + Ce,
                cr = d)),
                Yt = Xg(Yt, "end", b),
                ot = Math.max(Z, t0(Yt || (cr ? "100% 0" : pe), cr, Se, F, W() + Ce, It, Ct, b, $t, R, M, pe, w, b._endClamp && "_endClamp")) || -.001,
                Ce = 0,
                xi = Pr; xi--; )
                    Te = Mt[xi],
                    Ir = Te.pin,
                    Ir && Te.start - Te._pinPush <= Z && !w && Te.end > 0 && (He = Te.end - (b._startClamp ? Math.max(0, Te.start) : Te.start),
                    (Ir === d && Te.start - Te._pinPush < Z || Ir === Pi) && isNaN(ne) && (Ce += He * (1 - Te.progress)),
                    Ir === f && (se += He));
                if (Z += Ce,
                ot += Ce,
                b._startClamp && (b._startClamp += Ce),
                b._endClamp && !ui && (b._endClamp = ot || -.001,
                ot = Math.min(ot, Xr(B, F))),
                V = ot - Z || (Z -= .01) && .001,
                ni && (j = ht.utils.clamp(0, 1, ht.utils.normalize(Z, ot, ee))),
                b._pinPush = se,
                vt && Ce && (He = {},
                He[F.a] = "+=" + Ce,
                Pi && (He[F.p] = "-=" + W()),
                ht.set([vt, It], He)),
                f && !(bf && b.end >= Xr(B, F)))
                    He = er(f),
                    rh = F === De,
                    on = W(),
                    jt = parseFloat(kt(F.a)) + se,
                    !pe && ot > 1 && (Rr = (T ? oe.scrollingElement || gr : B).style,
                    Rr = {
                        style: Rr,
                        value: Rr["overflow" + F.a.toUpperCase()]
                    },
                    T && er(Jt)["overflow" + F.a.toUpperCase()] !== "scroll" && (Rr.style["overflow" + F.a.toUpperCase()] = "scroll")),
                    ed(f, bt, He),
                    yt = mh(f),
                    We = ds(f, !0),
                    Nc = M && Zs(B, rh ? mi : De)(),
                    p && (at = [p + F.os2, V + se + Ie],
                    at.t = bt,
                    xi = p === xe ? wf(f, F) + V + se : 0,
                    xi && (at.push(F.d, xi + Ie),
                    bt.style.flexBasis !== "auto" && (bt.style.flexBasis = xi + Ie)),
                    ko(at),
                    Pi && Mt.forEach(function(ca) {
                        ca.pin === Pi && ca.vars.pinSpacing !== !1 && (ca._subPinOffset = !0)
                    }),
                    M && W(ee)),
                    M && (je = {
                        top: We.top + (rh ? on - Z : Nc) + Ie,
                        left: We.left + (rh ? Nc : on - Z) + Ie,
                        boxSizing: "border-box",
                        position: "fixed"
                    },
                    je[Rn] = je["max" + Zo] = Math.ceil(We.width) + Ie,
                    je[Mn] = je["max" + am] = Math.ceil(We.height) + Ie,
                    je[tr] = je[tr + tl] = je[tr + Qa] = je[tr + el] = je[tr + Ja] = "0",
                    je[xe] = He[xe],
                    je[xe + tl] = He[xe + tl],
                    je[xe + Qa] = He[xe + Qa],
                    je[xe + el] = He[xe + el],
                    je[xe + Ja] = He[xe + Ja],
                    xt = wT(ut, je, E),
                    ui && W(0)),
                    r ? (xg = r._initted,
                    Kc(1),
                    r.render(r.duration(), !0, !0),
                    Tt = kt(F.a) - jt + V + se,
                    Xe = Math.abs(V - Tt) > 1,
                    M && Xe && xt.splice(xt.length - 2, 2),
                    r.render(0, !0, !0),
                    xg || r.invalidate(!0),
                    r.parent || r.totalTime(r.totalTime()),
                    Kc(0)) : Tt = V,
                    Rr && (Rr.value ? Rr.style["overflow" + F.a.toUpperCase()] = Rr.value : Rr.style.removeProperty("overflow-" + F.a));
                else if (d && W() && !w)
                    for (We = d.parentNode; We && We !== Jt; )
                        We._pinOffset && (Z -= We._pinOffset,
                        ot -= We._pinOffset),
                        We = We.parentNode;
                ha && ha.forEach(function(ca) {
                    return ca.revert(!1, !0)
                }),
                b.start = Z,
                b.end = ot,
                q = tt = ui ? ee : W(),
                !w && !ui && (q < ee && W(ee),
                b.scroll.rec = 0),
                b.revert(!1, !0),
                z = fi(),
                Xt && ($ = -1,
                Xt.restart(!0)),
                qe = 0,
                r && O && (r._initted || Ci) && r.progress() !== Ci && r.progress(Ci || 0, !0).render(r.time(), !0, !0),
                (ni || j !== b.progress || w) && (r && !O && r.totalProgress(w && Z < -.001 && !j ? ht.utils.normalize(Z, ot, 0) : j, !0),
                b.progress = ni || (q - Z) / V === j ? 0 : j),
                f && p && (bt._pinOffset = Math.round(b.progress * Tt)),
                pt && pt.invalidate(),
                isNaN(ua) || (ua -= ht.getProperty(H, F.p),
                sh -= ht.getProperty(Ct, F.p),
                gh(H, F, ua),
                gh(vt, F, ua - (Bt || 0)),
                gh(Ct, F, sh),
                gh(It, F, sh - (Bt || 0))),
                ni && !ui && b.update(),
                u && !ui && !G && (G = !0,
                u(b),
                G = !1)
            }
        }
        ,
        b.getVelocity = function() {
            return (W() - tt) / (fi() - tu) * 1e3 || 0
        }
        ,
        b.endAnimation = function() {
            ma(b.callbackAnimation),
            r && (pt ? pt.progress(1) : r.paused() ? O || ma(r, b.direction < 0, 1) : ma(r, r.reversed()))
        }
        ,
        b.labelToScroll = function(lt) {
            return r && r.labels && (Z || b.refresh() || Z) + r.labels[lt] / r.duration() * V || 0
        }
        ,
        b.getTrailing = function(lt) {
            var Ft = Mt.indexOf(b)
              , Dt = b.direction > 0 ? Mt.slice(0, Ft).reverse() : Mt.slice(Ft + 1);
            return (Fi(lt) ? Dt.filter(function(Bt) {
                return Bt.vars.preventOverlaps === lt
            }) : Dt).filter(function(Bt) {
                return b.direction > 0 ? Bt.end <= Z : Bt.start >= ot
            })
        }
        ,
        b.update = function(lt, Ft, Dt) {
            if (!(w && !Dt && !lt)) {
                var Bt = ui === !0 ? ee : b.scroll(), Se = lt ? 0 : (Bt - Z) / V, $t = Se < 0 ? 0 : Se > 1 ? 1 : Se || 0, pe = b.progress, ni, Ce, se, Yt, cr, ne, Pi, Pr;
                if (Ft && (tt = q,
                q = w ? W() : Bt,
                v && (vi = yi,
                yi = r && !O ? r.totalProgress() : $t)),
                g && !$t && f && !qe && !hh && or && Z < Bt + (Bt - tt) / (fi() - tu) * g && ($t = 1e-4),
                $t !== pe && b.enabled) {
                    if (ni = b.isActive = !!$t && $t < 1,
                    Ce = !!pe && pe < 1,
                    ne = ni !== Ce,
                    cr = ne || !!$t != !!pe,
                    b.direction = $t > pe ? 1 : -1,
                    b.progress = $t,
                    cr && !qe && (se = $t && !pe ? 0 : $t === 1 ? 1 : pe === 1 ? 2 : 3,
                    O && (Yt = !ne && C[se + 1] !== "none" && C[se + 1] || C[se],
                    Pr = r && (Yt === "complete" || Yt === "reset" || Yt in r))),
                    I && (ne || Pr) && (Pr || c || !r) && (gi(I) ? I(b) : b.getTrailing(I).forEach(function(on) {
                        return on.endAnimation()
                    })),
                    O || (pt && !qe && !hh ? (pt._dp._time - pt._start !== pt._time && pt.render(pt._dp._time - pt._start),
                    pt.resetTo ? pt.resetTo("totalProgress", $t, r._tTime / r._tDur) : (pt.vars.totalProgress = $t,
                    pt.invalidate().restart())) : r && r.totalProgress($t, !!(qe && (z || lt)))),
                    f) {
                        if (lt && p && (bt.style[p + F.os2] = qt),
                        !M)
                            Wt(Ra(jt + Tt * $t));
                        else if (cr) {
                            if (Pi = !lt && $t > pe && ot + 1 > Bt && Bt + 1 >= Xr(B, F),
                            E)
                                if (!lt && (ni || Pi)) {
                                    var xi = ds(f, !0)
                                      , He = Bt - Z;
                                    e0(f, Jt, xi.top + (F === De ? He : 0) + Ie, xi.left + (F === De ? 0 : He) + Ie)
                                } else
                                    e0(f, bt);
                            ko(ni || Pi ? xt : yt),
                            Xe && $t < 1 && ni || Wt(jt + ($t === 1 && !Pi ? Tt : 0))
                        }
                    }
                    v && !X.tween && !qe && !hh && Xt.restart(!0),
                    a && (ne || y && $t && ($t < 1 || !Zc)) && Dl(a.targets).forEach(function(on) {
                        return on.classList[ni || y ? "add" : "remove"](a.className)
                    }),
                    o && !O && !lt && o(b),
                    cr && !qe ? (O && (Pr && (Yt === "complete" ? r.pause().totalProgress(1) : Yt === "reset" ? r.restart(!0).pause() : Yt === "restart" ? r.restart(!0) : r[Yt]()),
                    o && o(b)),
                    (ne || !Zc) && (h && ne && Jc(b, h),
                    D[se] && Jc(b, D[se]),
                    y && ($t === 1 ? b.kill(!1, 1) : D[se] = 0),
                    ne || (se = $t === 1 ? 1 : 3,
                    D[se] && Jc(b, D[se]))),
                    A && !ni && Math.abs(b.getVelocity()) > (eu(A) ? A : 2500) && (ma(b.callbackAnimation),
                    pt ? pt.progress(1) : ma(r, Yt === "reverse" ? 1 : !$t, 1))) : O && o && !qe && o(b)
                }
                if (si) {
                    var We = w ? Bt / w.duration() * (w._caScrollDist || 0) : Bt;
                    Ve(We + (H._isFlipped ? 1 : 0)),
                    si(We)
                }
                ur && ur(-Bt / w.duration() * (w._caScrollDist || 0))
            }
        }
        ,
        b.enable = function(lt, Ft) {
            b.enabled || (b.enabled = !0,
            Be(B, "resize", Ma),
            T || Be(B, "scroll", io),
            L && Be(s, "refreshInit", L),
            lt !== !1 && (b.progress = j = 0,
            q = tt = $ = W()),
            Ft !== !1 && b.refresh())
        }
        ,
        b.getTween = function(lt) {
            return lt && X ? X.tween : pt
        }
        ,
        b.setPositions = function(lt, Ft, Dt, Bt) {
            if (w) {
                var Se = w.scrollTrigger
                  , $t = w.duration()
                  , pe = Se.end - Se.start;
                lt = Se.start + pe * lt / $t,
                Ft = Se.start + pe * Ft / $t
            }
            b.refresh(!1, !1, {
                start: Wg(lt, Dt && !!b._startClamp),
                end: Wg(Ft, Dt && !!b._endClamp)
            }, Bt),
            b.update()
        }
        ,
        b.adjustPinSpacing = function(lt) {
            if (at && lt) {
                var Ft = at.indexOf(F.d) + 1;
                at[Ft] = parseFloat(at[Ft]) + lt + Ie,
                at[1] = parseFloat(at[1]) + lt + Ie,
                ko(at)
            }
        }
        ,
        b.disable = function(lt, Ft) {
            if (b.enabled && (lt !== !1 && b.revert(!0, !0),
            b.enabled = b.isActive = !1,
            Ft || pt && pt.pause(),
            ee = 0,
            et && (et.uncache = 1),
            L && Re(s, "refreshInit", L),
            Xt && (Xt.pause(),
            X.tween && X.tween.kill() && (X.tween = 0)),
            !T)) {
                for (var Dt = Mt.length; Dt--; )
                    if (Mt[Dt].scroller === B && Mt[Dt] !== b)
                        return;
                Re(B, "resize", Ma),
                T || Re(B, "scroll", io)
            }
        }
        ,
        b.kill = function(lt, Ft) {
            b.disable(lt, Ft),
            pt && !Ft && pt.kill(),
            l && delete Ef[l];
            var Dt = Mt.indexOf(b);
            Dt >= 0 && Mt.splice(Dt, 1),
            Dt === hi && su > 0 && hi--,
            Dt = 0,
            Mt.forEach(function(Bt) {
                return Bt.scroller === b.scroller && (Dt = 1)
            }),
            Dt || ui || (b.scroll.rec = 0),
            r && (r.scrollTrigger = null,
            lt && r.revert({
                kill: !1
            }),
            Ft || r.kill()),
            vt && [vt, It, H, Ct].forEach(function(Bt) {
                return Bt.parentNode && Bt.parentNode.removeChild(Bt)
            }),
            il === b && (il = 0),
            f && (et && (et.uncache = 1),
            Dt = 0,
            Mt.forEach(function(Bt) {
                return Bt.pin === f && Dt++
            }),
            Dt || (et.spacer = 0)),
            i.onKill && i.onKill(b)
        }
        ,
        Mt.push(b),
        b.enable(!1, !1),
        _e && _e(b),
        r && r.add && !V) {
            var ye = b.update;
            b.update = function() {
                b.update = ye,
                Z || ot || b.refresh()
            }
            ,
            ht.delayedCall(.01, b.update),
            V = .01,
            Z = ot = 0
        } else
            b.refresh();
        f && vT()
    }
    ,
    s.register = function(i) {
        return ho || (ht = i || qv(),
        jv() && window.document && s.enable(),
        ho = Ia),
        ho
    }
    ,
    s.defaults = function(i) {
        if (i)
            for (var r in i)
                fh[r] = i[r];
        return fh
    }
    ,
    s.disable = function(i, r) {
        Ia = 0,
        Mt.forEach(function(o) {
            return o[r ? "kill" : "disable"](i)
        }),
        Re(Ut, "wheel", io),
        Re(oe, "scroll", io),
        clearInterval(lh),
        Re(oe, "touchcancel", Gr),
        Re(Jt, "touchstart", Gr),
        ch(Re, oe, "pointerdown,touchstart,mousedown", jg),
        ch(Re, oe, "pointerup,touchend,mouseup", qg),
        Iu.kill(),
        uh(Re);
        for (var n = 0; n < Ot.length; n += 3)
            dh(Re, Ot[n], Ot[n + 1]),
            dh(Re, Ot[n], Ot[n + 2])
    }
    ,
    s.enable = function() {
        if (Ut = window,
        oe = document,
        gr = oe.documentElement,
        Jt = oe.body,
        ht && (Dl = ht.utils.toArray,
        Do = ht.utils.clamp,
        xf = ht.core.context || Gr,
        Kc = ht.core.suppressOverwrites || Gr,
        im = Ut.history.scrollRestoration || "auto",
        Tf = Ut.pageYOffset,
        ht.core.globals("ScrollTrigger", s),
        Jt)) {
            Ia = 1,
            Oo = document.createElement("div"),
            Oo.style.height = "100vh",
            Oo.style.position = "absolute",
            rx(),
            dT(),
            we.register(ht),
            s.isTouch = we.isTouch,
            Ss = we.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent),
            Be(Ut, "wheel", io),
            Hv = [Ut, oe, gr, Jt],
            ht.matchMedia ? (s.matchMedia = function(l) {
                var h = ht.matchMedia(), u;
                for (u in l)
                    h.add(u, l[u]);
                return h
            }
            ,
            ht.addEventListener("matchMediaInit", function() {
                return hm()
            }),
            ht.addEventListener("matchMediaRevert", function() {
                return ex()
            }),
            ht.addEventListener("matchMedia", function() {
                Dn(0, 1),
                Xn("matchMedia")
            }),
            ht.matchMedia("(orientation: portrait)", function() {
                return td(),
                td
            })) : console.warn("Requires GSAP 3.11.0 or later"),
            td(),
            Be(oe, "scroll", io);
            var i = Jt.style, r = i.borderTopStyle, n = ht.core.Animation.prototype, o, a;
            for (n.revert || Object.defineProperty(n, "revert", {
                value: function() {
                    return this.time(-.01, !0)
                }
            }),
            i.borderTopStyle = "solid",
            o = ds(Jt),
            De.m = Math.round(o.top + De.sc()) || 0,
            mi.m = Math.round(o.left + mi.sc()) || 0,
            r ? i.borderTopStyle = r : i.removeProperty("border-top-style"),
            lh = setInterval(Zg, 250),
            ht.delayedCall(.5, function() {
                return hh = 0
            }),
            Be(oe, "touchcancel", Gr),
            Be(Jt, "touchstart", Gr),
            ch(Be, oe, "pointerdown,touchstart,mousedown", jg),
            ch(Be, oe, "pointerup,touchend,mouseup", qg),
            vf = ht.utils.checkPrefix("transform"),
            nu.push(vf),
            ho = fi(),
            Iu = ht.delayedCall(.2, Dn).pause(),
            uo = [oe, "visibilitychange", function() {
                var l = Ut.innerWidth
                  , h = Ut.innerHeight;
                oe.hidden ? (zg = l,
                Vg = h) : (zg !== l || Vg !== h) && Ma()
            }
            , oe, "DOMContentLoaded", Dn, Ut, "load", Dn, Ut, "resize", Ma],
            uh(Be),
            Mt.forEach(function(l) {
                return l.enable(0, 1)
            }),
            a = 0; a < Ot.length; a += 3)
                dh(Re, Ot[a], Ot[a + 1]),
                dh(Re, Ot[a], Ot[a + 2])
        }
    }
    ,
    s.config = function(i) {
        "limitCallbacks"in i && (Zc = !!i.limitCallbacks);
        var r = i.syncInterval;
        r && clearInterval(lh) || (lh = r) && setInterval(Zg, r),
        "ignoreMobileResize"in i && (Vv = s.isTouch === 1 && i.ignoreMobileResize),
        "autoRefreshEvents"in i && (uh(Re) || uh(Be, i.autoRefreshEvents || "none"),
        zv = (i.autoRefreshEvents + "").indexOf("resize") === -1)
    }
    ,
    s.scrollerProxy = function(i, r) {
        var n = bi(i)
          , o = Ot.indexOf(n)
          , a = zn(n);
        ~o && Ot.splice(o, a ? 6 : 2),
        r && (a ? Zr.unshift(Ut, r, Jt, r, gr, r) : Zr.unshift(n, r))
    }
    ,
    s.clearMatchMedia = function(i) {
        Mt.forEach(function(r) {
            return r._ctx && r._ctx.query === i && r._ctx.kill(!0, !0)
        })
    }
    ,
    s.isInViewport = function(i, r, n) {
        var o = (Fi(i) ? bi(i) : i).getBoundingClientRect()
          , a = o[n ? Rn : Mn] * r || 0;
        return n ? o.right - a > 0 && o.left + a < Ut.innerWidth : o.bottom - a > 0 && o.top + a < Ut.innerHeight
    }
    ,
    s.positionInViewport = function(i, r, n) {
        Fi(i) && (i = bi(i));
        var o = i.getBoundingClientRect()
          , a = o[n ? Rn : Mn]
          , l = r == null ? a / 2 : r in Ru ? Ru[r] * a : ~r.indexOf("%") ? parseFloat(r) * a / 100 : parseFloat(r) || 0;
        return n ? (o.left + l) / Ut.innerWidth : (o.top + l) / Ut.innerHeight
    }
    ,
    s.killAll = function(i) {
        if (Mt.slice(0).forEach(function(n) {
            return n.vars.id !== "ScrollSmoother" && n.kill()
        }),
        i !== !0) {
            var r = Vn.killAll || [];
            Vn = {},
            r.forEach(function(n) {
                return n()
            })
        }
    }
    ,
    s
}();
mt.version = "3.12.3";
mt.saveStyles = function(s) {
    return s ? Dl(s).forEach(function(t) {
        if (t && t.style) {
            var e = Mi.indexOf(t);
            e >= 0 && Mi.splice(e, 5),
            Mi.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), ht.core.getCache(t), xf())
        }
    }) : Mi
}
;
mt.revert = function(s, t) {
    return hm(!s, t)
}
;
mt.create = function(s, t) {
    return new mt(s,t)
}
;
mt.refresh = function(s) {
    return s ? Ma() : (ho || mt.register()) && Dn(!0)
}
;
mt.update = function(s) {
    return ++Ot.cache && ys(s === !0 ? 2 : 0)
}
;
mt.clearScrollMemory = ix;
mt.maxScroll = function(s, t) {
    return Xr(s, t ? mi : De)
}
;
mt.getScrollFunc = function(s, t) {
    return Zs(bi(s), t ? mi : De)
}
;
mt.getById = function(s) {
    return Ef[s]
}
;
mt.getAll = function() {
    return Mt.filter(function(s) {
        return s.vars.id !== "ScrollSmoother"
    })
}
;
mt.isScrolling = function() {
    return !!or
}
;
mt.snapDirectional = lm;
mt.addEventListener = function(s, t) {
    var e = Vn[s] || (Vn[s] = []);
    ~e.indexOf(t) || e.push(t)
}
;
mt.removeEventListener = function(s, t) {
    var e = Vn[s]
      , i = e && e.indexOf(t);
    i >= 0 && e.splice(i, 1)
}
;
mt.batch = function(s, t) {
    var e = [], i = {}, r = t.interval || .016, n = t.batchMax || 1e9, o = function(h, u) {
        var c = []
          , d = []
          , f = ht.delayedCall(r, function() {
            u(c, d),
            c = [],
            d = []
        }).pause();
        return function(p) {
            c.length || f.restart(!0),
            c.push(p.trigger),
            d.push(p),
            n <= c.length && f.progress(1)
        }
    }, a;
    for (a in t)
        i[a] = a.substr(0, 2) === "on" && gi(t[a]) && a !== "onRefreshInit" ? o(a, t[a]) : t[a];
    return gi(n) && (n = n(),
    Be(mt, "refresh", function() {
        return n = t.batchMax()
    })),
    Dl(s).forEach(function(l) {
        var h = {};
        for (a in i)
            h[a] = i[a];
        h.trigger = l,
        e.push(mt.create(h))
    }),
    e
}
;
var r0 = function(t, e, i, r) {
    return e > r ? t(r) : e < 0 && t(0),
    i > r ? (r - e) / (i - e) : i < 0 ? e / (e - i) : 1
}, id = function s(t, e) {
    e === !0 ? t.style.removeProperty("touch-action") : t.style.touchAction = e === !0 ? "auto" : e ? "pan-" + e + (we.isTouch ? " pinch-zoom" : "") : "none",
    t === gr && s(Jt, e)
}, _h = {
    auto: 1,
    scroll: 1
}, TT = function(t) {
    var e = t.event, i = t.target, r = t.axis, n = (e.changedTouches ? e.changedTouches[0] : e).target, o = n._gsap || ht.core.getCache(n), a = fi(), l;
    if (!o._isScrollT || a - o._isScrollT > 2e3) {
        for (; n && n !== Jt && (n.scrollHeight <= n.clientHeight && n.scrollWidth <= n.clientWidth || !(_h[(l = er(n)).overflowY] || _h[l.overflowX])); )
            n = n.parentNode;
        o._isScroll = n && n !== i && !zn(n) && (_h[(l = er(n)).overflowY] || _h[l.overflowX]),
        o._isScrollT = a
    }
    (o._isScroll || r === "x") && (e.stopPropagation(),
    e._gsapAllow = !0)
}, nx = function(t, e, i, r) {
    return we.create({
        target: t,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: e,
        onWheel: r = r && TT,
        onPress: r,
        onDrag: r,
        onScroll: r,
        onEnable: function() {
            return i && Be(oe, we.eventTypes[0], n0, !1, !0)
        },
        onDisable: function() {
            return Re(oe, we.eventTypes[0], n0, !0)
        }
    })
}, DT = /(input|label|select|textarea)/i, s0, n0 = function(t) {
    var e = DT.test(t.target.tagName);
    (e || s0) && (t._gsapAllow = !0,
    s0 = e)
}, AT = function(t) {
    pn(t) || (t = {}),
    t.preventDefault = t.isNormalizer = t.allowClicks = !0,
    t.type || (t.type = "wheel,touch"),
    t.debounce = !!t.debounce,
    t.id = t.id || "normalizer";
    var e = t, i = e.normalizeScrollX, r = e.momentum, n = e.allowNestedScroll, o = e.onRelease, a, l, h = bi(t.target) || gr, u = ht.core.globals().ScrollSmoother, c = u && u.get(), d = Ss && (t.content && bi(t.content) || c && t.content !== !1 && !c.smooth() && c.content()), f = Zs(h, De), p = Zs(h, mi), m = 1, g = (we.isTouch && Ut.visualViewport ? Ut.visualViewport.scale * Ut.visualViewport.width : Ut.outerWidth) / Ut.innerWidth, _ = 0, x = gi(r) ? function() {
        return r(a)
    }
    : function() {
        return r || 2.8
    }
    , y, v, E = nx(h, t.type, !0, n), P = function() {
        return v = !1
    }, w = Gr, A = Gr, I = function() {
        l = Xr(h, De),
        A = Do(Ss ? 1 : 0, l),
        i && (w = Do(0, Xr(h, mi))),
        y = Fn
    }, F = function() {
        d._gsap.y = Ra(parseFloat(d._gsap.y) + f.offset) + "px",
        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)",
        f.offset = f.cacheID = 0
    }, O = function() {
        if (v) {
            requestAnimationFrame(P);
            var k = Ra(a.deltaY / 2)
              , R = A(f.v - k);
            if (d && R !== f.v + f.offset) {
                f.offset = R - f.v;
                var b = Ra((parseFloat(d && d._gsap.y) || 0) - f.offset);
                d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + b + ", 0, 1)",
                d._gsap.y = b + "px",
                f.cacheID = Ot.cache,
                ys()
            }
            return !0
        }
        f.offset && F(),
        v = !0
    }, B, S, T, M, D = function() {
        I(),
        B.isActive() && B.vars.scrollY > l && (f() > l ? B.progress(1) && f(l) : B.resetTo("scrollY", l))
    };
    return d && ht.set(d, {
        y: "+=0"
    }),
    t.ignoreCheck = function(C) {
        return Ss && C.type === "touchmove" && O() || m > 1.05 && C.type !== "touchstart" || a.isGesturing || C.touches && C.touches.length > 1
    }
    ,
    t.onPress = function() {
        v = !1;
        var C = m;
        m = Ra((Ut.visualViewport && Ut.visualViewport.scale || 1) / g),
        B.pause(),
        C !== m && id(h, m > 1.01 ? !0 : i ? !1 : "x"),
        S = p(),
        T = f(),
        I(),
        y = Fn
    }
    ,
    t.onRelease = t.onGestureStart = function(C, k) {
        if (f.offset && F(),
        !k)
            M.restart(!0);
        else {
            Ot.cache++;
            var R = x(), b, L;
            i && (b = p(),
            L = b + R * .05 * -C.velocityX / .227,
            R *= r0(p, b, L, Xr(h, mi)),
            B.vars.scrollX = w(L)),
            b = f(),
            L = b + R * .05 * -C.velocityY / .227,
            R *= r0(f, b, L, Xr(h, De)),
            B.vars.scrollY = A(L),
            B.invalidate().duration(R).play(.01),
            (Ss && B.vars.scrollY >= l || b >= l - 1) && ht.to({}, {
                onUpdate: D,
                duration: R
            })
        }
        o && o(C)
    }
    ,
    t.onWheel = function() {
        B._ts && B.pause(),
        fi() - _ > 1e3 && (y = 0,
        _ = fi())
    }
    ,
    t.onChange = function(C, k, R, b, L) {
        if (Fn !== y && I(),
        k && i && p(w(b[2] === k ? S + (C.startX - C.x) : p() + k - b[1])),
        R) {
            f.offset && F();
            var U = L[2] === R
              , Y = U ? T + C.startY - C.y : f() + R - L[1]
              , $ = A(Y);
            U && Y !== $ && (T += $ - Y),
            f($)
        }
        (R || k) && ys()
    }
    ,
    t.onEnable = function() {
        id(h, i ? !1 : "x"),
        mt.addEventListener("refresh", D),
        Be(Ut, "resize", D),
        f.smooth && (f.target.style.scrollBehavior = "auto",
        f.smooth = p.smooth = !1),
        E.enable()
    }
    ,
    t.onDisable = function() {
        id(h, !0),
        Re(Ut, "resize", D),
        mt.removeEventListener("refresh", D),
        E.kill()
    }
    ,
    t.lockAxis = t.lockAxis !== !1,
    a = new we(t),
    a.iOS = Ss,
    Ss && !f() && f(1),
    Ss && ht.ticker.add(Gr),
    M = a._dc,
    B = ht.to(a, {
        ease: "power4",
        paused: !0,
        scrollX: i ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: {
            scrollY: sx(f, f(), function() {
                return B.pause()
            })
        },
        onUpdate: ys,
        onComplete: M.vars.onComplete
    }),
    a
};
mt.sort = function(s) {
    return Mt.sort(s || function(t, e) {
        return (t.vars.refreshPriority || 0) * -1e6 + t.start - (e.start + (e.vars.refreshPriority || 0) * -1e6)
    }
    )
}
;
mt.observe = function(s) {
    return new we(s)
}
;
mt.normalizeScroll = function(s) {
    if (typeof s > "u")
        return li;
    if (s === !0 && li)
        return li.enable();
    if (s === !1) {
        li && li.kill(),
        li = s;
        return
    }
    var t = s instanceof we ? s : AT(s);
    return li && li.target === t.target && li.kill(),
    zn(t.target) && (li = t),
    t
}
;
mt.core = {
    _getVelocityProp: yf,
    _inputObserver: nx,
    _scrollers: Ot,
    _proxies: Zr,
    bridge: {
        ss: function() {
            or || Xn("scrollStart"),
            or = fi()
        },
        ref: function() {
            return qe
        }
    }
};
qv() && ht.registerPlugin(mt);
function o0(s, t) {
    for (var e = 0; e < t.length; e++) {
        var i = t[e];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(s, i.key, i)
    }
}
function ST(s, t, e) {
    return t && o0(s.prototype, t),
    e && o0(s, e),
    s
}
/*!
 * ScrollSmoother 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Vt, yh, Ye, Ao, Fa, Fr, mn, a0, Pt, Hr, vh, l0, h0, u0, c0, ox = function() {
    return typeof window < "u"
}, ax = function() {
    return Vt || ox() && (Vt = window.gsap) && Vt.registerPlugin && Vt
}, CT = function(t) {
    return Math.round(t * 1e5) / 1e5 || 0
}, As = function(t) {
    return Pt.maxScroll(t || Ye)
}, PT = function(t, e) {
    var i = t.parentNode || Fa, r = t.getBoundingClientRect(), n = i.getBoundingClientRect(), o = n.top - r.top, a = n.bottom - r.bottom, l = (Math.abs(o) > Math.abs(a) ? o : a) / (1 - e), h = -l * e, u, c;
    return l > 0 && (u = n.height / (Ye.innerHeight + n.height),
    c = u === .5 ? n.height * 2 : Math.min(n.height, Math.abs(-l * u / (2 * u - 1))) * 2 * (e || 1),
    h += e ? -c * e : -c / 2,
    l += c),
    {
        change: l,
        offset: h
    }
}, IT = function(t) {
    var e = Ao.querySelector(".ScrollSmoother-wrapper");
    return e || (e = Ao.createElement("div"),
    e.classList.add("ScrollSmoother-wrapper"),
    t.parentNode.insertBefore(e, t),
    e.appendChild(t)),
    e
}, Qs = function() {
    function s(t) {
        var e = this;
        yh || s.register(Vt) || console.warn("Please gsap.registerPlugin(ScrollSmoother)"),
        t = this.vars = t || {},
        Hr && Hr.kill(),
        Hr = this,
        u0(this);
        var i = t, r = i.smoothTouch, n = i.onUpdate, o = i.onStop, a = i.smooth, l = i.onFocusIn, h = i.normalizeScroll, u = i.wholePixels, c, d, f, p, m, g, _, x, y, v, E, P, w, A, I = this, F = t.effectsPrefix || "", O = Pt.getScrollFunc(Ye), B = Pt.isTouch === 1 ? r === !0 ? .8 : parseFloat(r) || 0 : a === 0 || a === !1 ? 0 : parseFloat(a) || .8, S = B && +t.speed || 1, T = 0, M = 0, D = 1, C = l0(0), k = function() {
            return C.update(-T)
        }, R = {
            y: 0
        }, b = function() {
            return c.style.overflow = "visible"
        }, L, U = function(G) {
            G.update();
            var V = G.getTween();
            V && (V.pause(),
            V._time = V._dur,
            V._tTime = V._tDur),
            L = !1,
            G.animation.progress(G.progress, !0)
        }, Y = function(G, V) {
            (G !== T && !v || V) && (u && (G = Math.round(G)),
            B && (c.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + G + ", 0, 1)",
            c._gsap.y = G + "px"),
            M = G - T,
            T = G,
            Pt.isUpdating || s.isRefreshing || Pt.update())
        }, $ = function(G) {
            return arguments.length ? (G < 0 && (G = 0),
            R.y = -G,
            L = !0,
            v ? T = -G : Y(-G),
            Pt.isRefreshing ? p.update() : O(G / S),
            this) : -T
        }, z = typeof ResizeObserver < "u" && t.autoResize !== !1 && new ResizeObserver(function() {
            if (!Pt.isRefreshing) {
                var K = As(d) * S;
                K < -T && $(K),
                c0.restart(!0)
            }
        }
        ), j, W = function(G) {
            d.scrollTop = 0,
            !(G.target.contains && G.target.contains(d) || l && l(e, G) === !1) && (Pt.isInViewport(G.target) || G.target === j || e.scrollTo(G.target, !1, "center center"),
            j = G.target)
        }, X = function(G, V) {
            if (G < V.start)
                return G;
            var ut = isNaN(V.ratio) ? 1 : V.ratio
              , xt = V.end - V.start
              , yt = G - V.start
              , bt = V.offset || 0
              , Rt = V.pins || []
              , kt = Rt.offset || 0
              , Wt = V._startClamp && V.start <= 0 || V.pins && V.pins.offset ? 0 : V._endClamp && V.end === As() ? 1 : .5;
            return Rt.forEach(function(jt) {
                xt -= jt.distance,
                jt.nativeStart <= G && (yt -= jt.distance)
            }),
            kt && (yt *= (xt - kt / ut) / xt),
            G + (yt - bt * Wt) / ut - yt
        }, et = function K(G, V, ut) {
            ut || (G.pins.length = G.pins.offset = 0);
            var xt = G.pins, yt = G.markers, bt, Rt, kt, Wt, jt, Tt, qt, at;
            for (qt = 0; qt < V.length; qt++)
                if (at = V[qt],
                G.trigger && at.trigger && G !== at && (at.trigger === G.trigger || at.pinnedContainer === G.trigger || G.trigger.contains(at.trigger)) && (jt = at._startNative || at._startClamp || at.start,
                Tt = at._endNative || at._endClamp || at.end,
                kt = X(jt, G),
                Wt = at.pin && Tt > 0 ? kt + (Tt - jt) : X(Tt, G),
                at.setPositions(kt, Wt, !0, (at._startClamp ? Math.max(0, kt) : kt) - jt),
                at.markerStart && yt.push(Vt.quickSetter([at.markerStart, at.markerEnd], "y", "px")),
                at.pin && at.end > 0 && !ut)) {
                    if (bt = at.end - at.start,
                    Rt = G._startClamp && at.start < 0,
                    Rt) {
                        if (G.start > 0) {
                            G.setPositions(0, G.end + (G._startNative - G.start), !0),
                            K(G, V);
                            return
                        }
                        bt += at.start,
                        xt.offset = -at.start
                    }
                    xt.push({
                        start: at.start,
                        nativeStart: jt,
                        end: at.end,
                        distance: bt,
                        trig: at
                    }),
                    G.setPositions(G.start, G.end + (Rt ? -at.start : bt), !0)
                }
        }, Q = function(G, V) {
            m.forEach(function(ut) {
                return et(ut, G, V)
            })
        }, q = function() {
            b(),
            requestAnimationFrame(b),
            m && (Pt.getAll().forEach(function(G) {
                G._startNative = G.start,
                G._endNative = G.end
            }),
            m.forEach(function(G) {
                var V = G._startClamp || G.start
                  , ut = G.autoSpeed ? Math.min(As(), G.end) : V + Math.abs((G.end - V) / G.ratio)
                  , xt = ut - G.end;
                if (V -= xt / 2,
                ut -= xt / 2,
                V > ut) {
                    var yt = V;
                    V = ut,
                    ut = yt
                }
                G._startClamp && V < 0 ? (ut = G.ratio < 0 ? As() : G.end / G.ratio,
                xt = ut - G.end,
                V = 0) : (G.ratio < 0 || G._endClamp && ut >= As()) && (ut = As(),
                V = G.ratio < 0 || G.ratio > 1 ? 0 : ut - (ut - G.start) / G.ratio,
                xt = (ut - V) * G.ratio - (G.end - G.start)),
                G.offset = xt || 1e-4,
                G.pins.length = G.pins.offset = 0,
                G.setPositions(V, ut, !0)
            }),
            Q(Pt.sort())),
            C.reset()
        }, tt = function() {
            return Pt.addEventListener("refresh", q)
        }, Z = function() {
            return m && m.forEach(function(G) {
                return G.vars.onRefresh(G)
            })
        }, ot = function() {
            return m && m.forEach(function(G) {
                return G.vars.onRefreshInit(G)
            }),
            Z
        }, vt = function(G, V, ut, xt) {
            return function() {
                var yt = typeof V == "function" ? V(ut, xt) : V;
                yt || yt === 0 || (yt = xt.getAttribute("data-" + F + G) || (G === "speed" ? 1 : 0)),
                xt.setAttribute("data-" + F + G, yt);
                var bt = (yt + "").substr(0, 6) === "clamp(";
                return {
                    clamp: bt,
                    value: bt ? yt.substr(6, yt.length - 7) : yt
                }
            }
        }, It = function(G, V, ut, xt, yt) {
            yt = (typeof yt == "function" ? yt(xt, G) : yt) || 0;
            var bt = vt("speed", V, xt, G), Rt = vt("lag", ut, xt, G), kt = Vt.getProperty(G, "y"), Wt = G._gsap, jt, Tt, qt, at, Ve, Xe, si = [], Wi = function() {
                V = bt(),
                ut = parseFloat(Rt().value),
                jt = parseFloat(V.value) || 1,
                qt = V.value === "auto",
                Ve = qt || Tt && Tt._startClamp && Tt.start <= 0 || si.offset ? 0 : Tt && Tt._endClamp && Tt.end === As() ? 1 : .5,
                at && at.kill(),
                at = ut && Vt.to(G, {
                    ease: vh,
                    overwrite: !1,
                    y: "+=0",
                    duration: ut
                }),
                Tt && (Tt.ratio = jt,
                Tt.autoSpeed = qt)
            }, yi = function() {
                Wt.y = kt + "px",
                Wt.renderTransform(1),
                Wi()
            }, vi = [], pt = 0, Cr = function(Xt) {
                if (qt) {
                    yi();
                    var ee = PT(G, a0(0, 1, -Xt.start / (Xt.end - Xt.start)));
                    pt = ee.change,
                    Xe = ee.offset
                } else
                    Xe = si.offset || 0,
                    pt = (Xt.end - Xt.start - Xe) * (1 - jt);
                si.forEach(function(Ci) {
                    return pt -= Ci.distance * (1 - jt)
                }),
                Xt.offset = pt || .001,
                Xt.vars.onUpdate(Xt),
                at && at.progress(1)
            };
            return Wi(),
            (jt !== 1 || qt || at) && (Tt = Pt.create({
                trigger: qt ? G.parentNode : G,
                start: function() {
                    return V.clamp ? "clamp(top bottom+=" + yt + ")" : "top bottom+=" + yt
                },
                end: function() {
                    return V.value < 0 ? "max" : V.clamp ? "clamp(bottom top-=" + yt + ")" : "bottom top-=" + yt
                },
                scroller: d,
                scrub: !0,
                refreshPriority: -999,
                onRefreshInit: yi,
                onRefresh: Cr,
                onKill: function(Xt) {
                    var ee = m.indexOf(Xt);
                    ee >= 0 && m.splice(ee, 1),
                    yi()
                },
                onUpdate: function(Xt) {
                    var ee = kt + pt * (Xt.progress - Ve), Ci = si.length, ur = 0, _e, wt, gt;
                    if (Xt.offset) {
                        if (Ci) {
                            for (wt = -T,
                            gt = Xt.end; Ci--; ) {
                                if (_e = si[Ci],
                                _e.trig.isActive || wt >= _e.start && wt <= _e.end) {
                                    at && (_e.trig.progress += _e.trig.direction < 0 ? .001 : -.001,
                                    _e.trig.update(0, 0, 1),
                                    at.resetTo("y", parseFloat(Wt.y), -M, !0),
                                    D && at.progress(1));
                                    return
                                }
                                wt > _e.end && (ur += _e.distance),
                                gt -= _e.distance
                            }
                            ee = kt + ur + pt * ((Vt.utils.clamp(Xt.start, Xt.end, wt) - Xt.start - ur) / (gt - Xt.start) - Ve)
                        }
                        vi.length && !qt && vi.forEach(function(Ht) {
                            return Ht(ee - ur)
                        }),
                        ee = CT(ee + Xe),
                        at ? (at.resetTo("y", ee, -M, !0),
                        D && at.progress(1)) : (Wt.y = ee + "px",
                        Wt.renderTransform(1))
                    }
                }
            }),
            Cr(Tt),
            Vt.core.getCache(Tt.trigger).stRevert = ot,
            Tt.startY = kt,
            Tt.pins = si,
            Tt.markers = vi,
            Tt.ratio = jt,
            Tt.autoSpeed = qt,
            G.style.willChange = "transform"),
            Tt
        };
        tt(),
        Pt.addEventListener("killAll", tt),
        Vt.delayedCall(.5, function() {
            return D = 0
        }),
        this.scrollTop = $,
        this.scrollTo = function(K, G, V) {
            var ut = Vt.utils.clamp(0, As(), isNaN(K) ? e.offset(K, V, !!G && !v) : +K);
            G ? v ? Vt.to(e, {
                duration: B,
                scrollTop: ut,
                overwrite: "auto",
                ease: vh
            }) : O(ut) : $(ut)
        }
        ,
        this.offset = function(K, G, V) {
            K = mn(K)[0];
            var ut = K.style.cssText, xt = Pt.create({
                trigger: K,
                start: G || "top top"
            }), yt;
            return m && (D ? Pt.refresh() : Q([xt], !0)),
            yt = xt.start / (V ? S : 1),
            xt.kill(!1),
            K.style.cssText = ut,
            Vt.core.getCache(K).uncache = 1,
            yt
        }
        ;
        function H() {
            return f = c.clientHeight,
            c.style.overflow = "visible",
            Fr.style.height = Ye.innerHeight + (f - Ye.innerHeight) / S + "px",
            f - Ye.innerHeight
        }
        this.content = function(K) {
            if (arguments.length) {
                var G = mn(K || "#smooth-content")[0] || console.warn("ScrollSmoother needs a valid content element.") || Fr.children[0];
                return G !== c && (c = G,
                y = c.getAttribute("style") || "",
                z && z.observe(c),
                Vt.set(c, {
                    overflow: "visible",
                    width: "100%",
                    boxSizing: "border-box",
                    y: "+=0"
                }),
                B || Vt.set(c, {
                    clearProps: "transform"
                })),
                this
            }
            return c
        }
        ,
        this.wrapper = function(K) {
            return arguments.length ? (d = mn(K || "#smooth-wrapper")[0] || IT(c),
            x = d.getAttribute("style") || "",
            H(),
            Vt.set(d, B ? {
                overflow: "hidden",
                position: "fixed",
                height: "100%",
                width: "100%",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0
            } : {
                overflow: "visible",
                position: "relative",
                width: "100%",
                height: "auto",
                top: "auto",
                bottom: "auto",
                left: "auto",
                right: "auto"
            }),
            this) : d
        }
        ,
        this.effects = function(K, G) {
            var V;
            if (m || (m = []),
            !K)
                return m.slice(0);
            K = mn(K),
            K.forEach(function(jt) {
                for (var Tt = m.length; Tt--; )
                    m[Tt].trigger === jt && m[Tt].kill()
            }),
            G = G || {};
            var ut = G, xt = ut.speed, yt = ut.lag, bt = ut.effectsPadding, Rt = [], kt, Wt;
            for (kt = 0; kt < K.length; kt++)
                Wt = It(K[kt], xt, yt, kt, bt),
                Wt && Rt.push(Wt);
            return (V = m).push.apply(V, Rt),
            Rt
        }
        ,
        this.sections = function(K, G) {
            var V;
            if (g || (g = []),
            !K)
                return g.slice(0);
            var ut = mn(K).map(function(xt) {
                return Pt.create({
                    trigger: xt,
                    start: "top 120%",
                    end: "bottom -20%",
                    onToggle: function(bt) {
                        xt.style.opacity = bt.isActive ? "1" : "0",
                        xt.style.pointerEvents = bt.isActive ? "all" : "none"
                    }
                })
            });
            return G && G.add ? (V = g).push.apply(V, ut) : g = ut.slice(0),
            ut
        }
        ,
        this.content(t.content),
        this.wrapper(t.wrapper),
        this.render = function(K) {
            return Y(K || K === 0 ? K : T)
        }
        ,
        this.getVelocity = function() {
            return C.getVelocity(-T)
        }
        ,
        Pt.scrollerProxy(d, {
            scrollTop: $,
            scrollHeight: function() {
                return H() && Fr.scrollHeight
            },
            fixedMarkers: t.fixedMarkers !== !1 && !!B,
            content: c,
            getBoundingClientRect: function() {
                return {
                    top: 0,
                    left: 0,
                    width: Ye.innerWidth,
                    height: Ye.innerHeight
                }
            }
        }),
        Pt.defaults({
            scroller: d
        });
        var Ct = Pt.getAll().filter(function(K) {
            return K.scroller === Ye || K.scroller === d
        });
        Ct.forEach(function(K) {
            return K.revert(!0, !0)
        }),
        p = Pt.create({
            animation: Vt.fromTo(R, {
                y: function() {
                    return A = 0,
                    0
                }
            }, {
                y: function() {
                    return A = 1,
                    -H()
                },
                immediateRender: !1,
                ease: "none",
                data: "ScrollSmoother",
                duration: 100,
                onUpdate: function() {
                    if (A) {
                        var G = L;
                        G && (U(p),
                        R.y = T),
                        Y(R.y, G),
                        k(),
                        n && !v && n(I)
                    }
                }
            }),
            onRefreshInit: function(G) {
                if (!s.isRefreshing) {
                    if (s.isRefreshing = !0,
                    m) {
                        var V = Pt.getAll().filter(function(xt) {
                            return !!xt.pin
                        });
                        m.forEach(function(xt) {
                            xt.vars.pinnedContainer || V.forEach(function(yt) {
                                if (yt.pin.contains(xt.trigger)) {
                                    var bt = xt.vars;
                                    bt.pinnedContainer = yt.pin,
                                    xt.vars = null,
                                    xt.init(bt, xt.animation)
                                }
                            })
                        })
                    }
                    var ut = G.getTween();
                    w = ut && ut._end > ut._dp._time,
                    P = T,
                    R.y = 0,
                    B && (Pt.isTouch === 1 && (d.style.position = "absolute"),
                    d.scrollTop = 0,
                    Pt.isTouch === 1 && (d.style.position = "fixed"))
                }
            },
            onRefresh: function(G) {
                G.animation.invalidate(),
                G.setPositions(G.start, H() / S),
                w || U(G),
                R.y = -O() * S,
                Y(R.y),
                D || (w && (L = !1),
                G.animation.progress(Vt.utils.clamp(0, 1, P / S / -G.end))),
                w && (G.progress -= .001,
                G.update()),
                s.isRefreshing = !1
            },
            id: "ScrollSmoother",
            scroller: Ye,
            invalidateOnRefresh: !0,
            start: 0,
            refreshPriority: -9999,
            end: function() {
                return H() / S
            },
            onScrubComplete: function() {
                C.reset(),
                o && o(e)
            },
            scrub: B || !0
        }),
        this.smooth = function(K) {
            return arguments.length && (B = K || 0,
            S = B && +t.speed || 1,
            p.scrubDuration(K)),
            p.getTween() ? p.getTween().duration() : 0
        }
        ,
        p.getTween() && (p.getTween().vars.ease = t.ease || vh),
        this.scrollTrigger = p,
        t.effects && this.effects(t.effects === !0 ? "[data-" + F + "speed], [data-" + F + "lag]" : t.effects, {
            effectsPadding: t.effectsPadding
        }),
        t.sections && this.sections(t.sections === !0 ? "[data-section]" : t.sections),
        Ct.forEach(function(K) {
            K.vars.scroller = d,
            K.revert(!1, !0),
            K.init(K.vars, K.animation)
        }),
        this.paused = function(K, G) {
            return arguments.length ? (!!v !== K && (K ? (p.getTween() && p.getTween().pause(),
            O(-T / S),
            C.reset(),
            E = Pt.normalizeScroll(),
            E && E.disable(),
            v = Pt.observe({
                preventDefault: !0,
                type: "wheel,touch,scroll",
                debounce: !1,
                allowClicks: !0,
                onChangeY: function() {
                    return $(-T)
                }
            }),
            v.nested = h0(Fa, "wheel,touch,scroll", !0, G !== !1)) : (v.nested.kill(),
            v.kill(),
            v = 0,
            E && E.enable(),
            p.progress = (-T / S - p.start) / (p.end - p.start),
            U(p))),
            this) : !!v
        }
        ,
        this.kill = this.revert = function() {
            e.paused(!1),
            U(p),
            p.kill();
            for (var K = (m || []).concat(g || []), G = K.length; G--; )
                K[G].kill();
            Pt.scrollerProxy(d),
            Pt.removeEventListener("killAll", tt),
            Pt.removeEventListener("refresh", q),
            d.style.cssText = x,
            c.style.cssText = y;
            var V = Pt.defaults({});
            V && V.scroller === d && Pt.defaults({
                scroller: Ye
            }),
            e.normalizer && Pt.normalizeScroll(!1),
            clearInterval(_),
            Hr = null,
            z && z.disconnect(),
            Fr.style.removeProperty("height"),
            Ye.removeEventListener("focusin", W)
        }
        ,
        this.refresh = function(K, G) {
            return p.refresh(K, G)
        }
        ,
        h && (this.normalizer = Pt.normalizeScroll(h === !0 ? {
            debounce: !0,
            content: !B && c
        } : h)),
        Pt.config(t),
        "overscrollBehavior"in Ye.getComputedStyle(Fr) && Vt.set([Fr, Fa], {
            overscrollBehavior: "none"
        }),
        "scrollBehavior"in Ye.getComputedStyle(Fr) && Vt.set([Fr, Fa], {
            scrollBehavior: "auto"
        }),
        Ye.addEventListener("focusin", W),
        _ = setInterval(k, 250),
        Ao.readyState === "loading" || requestAnimationFrame(function() {
            return Pt.refresh()
        })
    }
    return s.register = function(e) {
        return yh || (Vt = e || ax(),
        ox() && window.document && (Ye = window,
        Ao = document,
        Fa = Ao.documentElement,
        Fr = Ao.body),
        Vt && (mn = Vt.utils.toArray,
        a0 = Vt.utils.clamp,
        vh = Vt.parseEase("expo"),
        u0 = Vt.core.context || function() {}
        ,
        Pt = Vt.core.globals().ScrollTrigger,
        Vt.core.globals("ScrollSmoother", s),
        Fr && Pt && (c0 = Vt.delayedCall(.2, function() {
            return Pt.isRefreshing || Hr && Hr.refresh()
        }).pause(),
        l0 = Pt.core._getVelocityProp,
        h0 = Pt.core._inputObserver,
        s.refresh = Pt.refresh,
        yh = 1))),
        yh
    }
    ,
    ST(s, [{
        key: "progress",
        get: function() {
            return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0
        }
    }]),
    s
}();
Qs.version = "3.12.3";
Qs.create = function(s) {
    return Hr && s && Hr.content() === mn(s.content)[0] ? Hr : new Qs(s)
}
;
Qs.get = function() {
    return Hr
}
;
ax() && Vt.registerPlugin(Qs);
var rl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function um(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}
function RT(s) {
    if (s.__esModule)
        return s;
    var t = s.default;
    if (typeof t == "function") {
        var e = function i() {
            return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        e.prototype = t.prototype
    } else
        e = {};
    return Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    Object.keys(s).forEach(function(i) {
        var r = Object.getOwnPropertyDescriptor(s, i);
        Object.defineProperty(e, i, r.get ? r : {
            enumerable: !0,
            get: function() {
                return s[i]
            }
        })
    }),
    e
}
var Af = {
    exports: {}
};
(function(s, t) {
    (function(e, i) {
        i(t)
    }
    )(rl, function(e) {
        var i = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
          , r = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
          , n = Math.PI / 180
          , o = Math.sin
          , a = Math.cos
          , l = Math.abs
          , h = Math.sqrt
          , u = function(T) {
            return typeof T == "number"
        }
          , c = 1e5
          , d = function(T) {
            return Math.round(T * c) / c || 0
        };
        function f(S, T, M, D, C, k, R) {
            for (var b = S.length, L, U, Y, $, z; --b > -1; )
                for (L = S[b],
                U = L.length,
                Y = 0; Y < U; Y += 2)
                    $ = L[Y],
                    z = L[Y + 1],
                    L[Y] = $ * T + z * D + k,
                    L[Y + 1] = $ * M + z * C + R;
            return S._dirty = 1,
            S
        }
        function p(S, T, M, D, C, k, R, b, L) {
            if (!(S === b && T === L)) {
                M = l(M),
                D = l(D);
                var U = C % 360 * n
                  , Y = a(U)
                  , $ = o(U)
                  , z = Math.PI
                  , j = z * 2
                  , W = (S - b) / 2
                  , X = (T - L) / 2
                  , et = Y * W + $ * X
                  , Q = -$ * W + Y * X
                  , q = et * et
                  , tt = Q * Q
                  , Z = q / (M * M) + tt / (D * D);
                Z > 1 && (M = h(Z) * M,
                D = h(Z) * D);
                var ot = M * M
                  , vt = D * D
                  , It = (ot * vt - ot * tt - vt * q) / (ot * tt + vt * q);
                It < 0 && (It = 0);
                var H = (k === R ? -1 : 1) * h(It)
                  , Ct = H * (M * Q / D)
                  , K = H * -(D * et / M)
                  , G = (S + b) / 2
                  , V = (T + L) / 2
                  , ut = G + (Y * Ct - $ * K)
                  , xt = V + ($ * Ct + Y * K)
                  , yt = (et - Ct) / M
                  , bt = (Q - K) / D
                  , Rt = (-et - Ct) / M
                  , kt = (-Q - K) / D
                  , Wt = yt * yt + bt * bt
                  , jt = (bt < 0 ? -1 : 1) * Math.acos(yt / h(Wt))
                  , Tt = (yt * kt - bt * Rt < 0 ? -1 : 1) * Math.acos((yt * Rt + bt * kt) / h(Wt * (Rt * Rt + kt * kt)));
                isNaN(Tt) && (Tt = z),
                !R && Tt > 0 ? Tt -= j : R && Tt < 0 && (Tt += j),
                jt %= j,
                Tt %= j;
                var qt = Math.ceil(l(Tt) / (j / 4)), at = [], Ve = Tt / qt, Xe = 4 / 3 * o(Ve / 2) / (1 + a(Ve / 2)), si = Y * M, Wi = $ * M, yi = $ * -D, vi = Y * D, pt;
                for (pt = 0; pt < qt; pt++)
                    C = jt + pt * Ve,
                    et = a(C),
                    Q = o(C),
                    yt = a(C += Ve),
                    bt = o(C),
                    at.push(et - Xe * Q, Q + Xe * et, yt + Xe * bt, bt - Xe * yt, yt, bt);
                for (pt = 0; pt < at.length; pt += 2)
                    et = at[pt],
                    Q = at[pt + 1],
                    at[pt] = et * si + Q * yi + ut,
                    at[pt + 1] = et * Wi + Q * vi + xt;
                return at[pt - 2] = b,
                at[pt - 1] = L,
                at
            }
        }
        function m(S) {
            var T = (S + "").replace(r, function(Ct) {
                var K = +Ct;
                return K < 1e-4 && K > -1e-4 ? 0 : K
            }).match(i) || [], M = [], D = 0, C = 0, k = 2 / 3, R = T.length, b = 0, L = "ERROR: malformed path: " + S, U, Y, $, z, j, W, X, et, Q, q, tt, Z, ot, vt, It, H = function(K, G, V, ut) {
                q = (V - K) / 3,
                tt = (ut - G) / 3,
                X.push(K + q, G + tt, V - q, ut - tt, V, ut)
            };
            if (!S || !isNaN(T[0]) || isNaN(T[1]))
                return console.log(L),
                M;
            for (U = 0; U < R; U++)
                if (ot = j,
                isNaN(T[U]) ? (j = T[U].toUpperCase(),
                W = j !== T[U]) : U--,
                $ = +T[U + 1],
                z = +T[U + 2],
                W && ($ += D,
                z += C),
                U || (et = $,
                Q = z),
                j === "M")
                    X && (X.length < 8 ? M.length -= 1 : b += X.length),
                    D = et = $,
                    C = Q = z,
                    X = [$, z],
                    M.push(X),
                    U += 2,
                    j = "L";
                else if (j === "C")
                    X || (X = [0, 0]),
                    W || (D = C = 0),
                    X.push($, z, D + T[U + 3] * 1, C + T[U + 4] * 1, D += T[U + 5] * 1, C += T[U + 6] * 1),
                    U += 6;
                else if (j === "S")
                    q = D,
                    tt = C,
                    (ot === "C" || ot === "S") && (q += D - X[X.length - 4],
                    tt += C - X[X.length - 3]),
                    W || (D = C = 0),
                    X.push(q, tt, $, z, D += T[U + 3] * 1, C += T[U + 4] * 1),
                    U += 4;
                else if (j === "Q")
                    q = D + ($ - D) * k,
                    tt = C + (z - C) * k,
                    W || (D = C = 0),
                    D += T[U + 3] * 1,
                    C += T[U + 4] * 1,
                    X.push(q, tt, D + ($ - D) * k, C + (z - C) * k, D, C),
                    U += 4;
                else if (j === "T")
                    q = D - X[X.length - 4],
                    tt = C - X[X.length - 3],
                    X.push(D + q, C + tt, $ + (D + q * 1.5 - $) * k, z + (C + tt * 1.5 - z) * k, D = $, C = z),
                    U += 2;
                else if (j === "H")
                    H(D, C, D = $, C),
                    U += 1;
                else if (j === "V")
                    H(D, C, D, C = $ + (W ? C - D : 0)),
                    U += 1;
                else if (j === "L" || j === "Z")
                    j === "Z" && ($ = et,
                    z = Q,
                    X.closed = !0),
                    (j === "L" || l(D - $) > .5 || l(C - z) > .5) && (H(D, C, $, z),
                    j === "L" && (U += 2)),
                    D = $,
                    C = z;
                else if (j === "A") {
                    if (vt = T[U + 4],
                    It = T[U + 5],
                    q = T[U + 6],
                    tt = T[U + 7],
                    Y = 7,
                    vt.length > 1 && (vt.length < 3 ? (tt = q,
                    q = It,
                    Y--) : (tt = It,
                    q = vt.substr(2),
                    Y -= 2),
                    It = vt.charAt(1),
                    vt = vt.charAt(0)),
                    Z = p(D, C, +T[U + 1], +T[U + 2], +T[U + 3], +vt, +It, (W ? D : 0) + q * 1, (W ? C : 0) + tt * 1),
                    U += Y,
                    Z)
                        for (Y = 0; Y < Z.length; Y++)
                            X.push(Z[Y]);
                    D = X[X.length - 2],
                    C = X[X.length - 1]
                } else
                    console.log(L);
            return U = X.length,
            U < 6 ? (M.pop(),
            U = 0) : X[0] === X[U - 2] && X[1] === X[U - 1] && (X.closed = !0),
            M.totalPoints = b + U,
            M
        }
        function g(S) {
            u(S[0]) && (S = [S]);
            var T = "", M = S.length, D, C, k, R;
            for (C = 0; C < M; C++) {
                for (R = S[C],
                T += "M" + d(R[0]) + "," + d(R[1]) + " C",
                D = R.length,
                k = 2; k < D; k++)
                    T += d(R[k++]) + "," + d(R[k++]) + " " + d(R[k++]) + "," + d(R[k++]) + " " + d(R[k++]) + "," + d(R[k]) + " ";
                R.closed && (T += "z")
            }
            return T
        }
        /*!
 * CustomEase 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
        var _, x, y = function() {
            return _ || typeof window < "u" && (_ = window.gsap) && _.registerPlugin && _
        }, v = function() {
            _ = y(),
            _ ? (_.registerEase("_CE", B.create),
            x = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
        }, E = 1e20, P = function(T) {
            return ~~(T * 1e3 + (T < 0 ? -.5 : .5)) / 1e3
        }, w = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, A = /[cLlsSaAhHvVtTqQ]/g, I = function(T) {
            var M = T.length, D = E, C;
            for (C = 1; C < M; C += 6)
                +T[C] < D && (D = +T[C]);
            return D
        }, F = function(T, M, D) {
            !D && D !== 0 && (D = Math.max(+T[T.length - 1], +T[1]));
            var C = +T[0] * -1, k = -D, R = T.length, b = 1 / (+T[R - 2] + C), L = -M || (Math.abs(+T[R - 1] - +T[1]) < .01 * (+T[R - 2] - +T[0]) ? I(T) + k : +T[R - 1] + k), U;
            for (L ? L = 1 / L : L = -b,
            U = 0; U < R; U += 2)
                T[U] = (+T[U] + C) * b,
                T[U + 1] = (+T[U + 1] + k) * L
        }, O = function S(T, M, D, C, k, R, b, L, U, Y, $) {
            var z = (T + D) / 2, j = (M + C) / 2, W = (D + k) / 2, X = (C + R) / 2, et = (k + b) / 2, Q = (R + L) / 2, q = (z + W) / 2, tt = (j + X) / 2, Z = (W + et) / 2, ot = (X + Q) / 2, vt = (q + Z) / 2, It = (tt + ot) / 2, H = b - T, Ct = L - M, K = Math.abs((D - b) * Ct - (C - L) * H), G = Math.abs((k - b) * Ct - (R - L) * H), V;
            return Y || (Y = [{
                x: T,
                y: M
            }, {
                x: b,
                y: L
            }],
            $ = 1),
            Y.splice($ || Y.length - 1, 0, {
                x: vt,
                y: It
            }),
            (K + G) * (K + G) > U * (H * H + Ct * Ct) && (V = Y.length,
            S(T, M, z, j, q, tt, vt, It, U, Y, $),
            S(vt, It, Z, ot, et, Q, b, L, U, Y, $ + 1 + (Y.length - V))),
            Y
        }, B = function() {
            function S(M, D, C) {
                x || v(),
                this.id = M,
                this.setData(D, C)
            }
            var T = S.prototype;
            return T.setData = function(D, C) {
                C = C || {},
                D = D || "0,0,1,1";
                var k = D.match(w), R = 1, b = [], L = [], U = C.precision || 1, Y = U <= 1, $, z, j, W, X, et, Q, q, tt;
                if (this.data = D,
                (A.test(D) || ~D.indexOf("M") && D.indexOf("C") < 0) && (k = m(D)[0]),
                $ = k.length,
                $ === 4)
                    k.unshift(0, 0),
                    k.push(1, 1),
                    $ = 8;
                else if (($ - 2) % 6)
                    throw "Invalid CustomEase";
                for ((+k[0] != 0 || +k[$ - 2] != 1) && F(k, C.height, C.originY),
                this.segment = k,
                W = 2; W < $; W += 6)
                    z = {
                        x: +k[W - 2],
                        y: +k[W - 1]
                    },
                    j = {
                        x: +k[W + 4],
                        y: +k[W + 5]
                    },
                    b.push(z, j),
                    O(z.x, z.y, +k[W], +k[W + 1], +k[W + 2], +k[W + 3], j.x, j.y, 1 / (U * 2e5), b, b.length - 1);
                for ($ = b.length,
                W = 0; W < $; W++)
                    Q = b[W],
                    q = b[W - 1] || Q,
                    (Q.x > q.x || q.y !== Q.y && q.x === Q.x || Q === q) && Q.x <= 1 ? (q.cx = Q.x - q.x,
                    q.cy = Q.y - q.y,
                    q.n = Q,
                    q.nx = Q.x,
                    Y && W > 1 && Math.abs(q.cy / q.cx - b[W - 2].cy / b[W - 2].cx) > 2 && (Y = 0),
                    q.cx < R && (q.cx ? R = q.cx : (q.cx = .001,
                    W === $ - 1 && (q.x -= .001,
                    R = Math.min(R, .001),
                    Y = 0)))) : (b.splice(W--, 1),
                    $--);
                if ($ = 1 / R + 1 | 0,
                X = 1 / $,
                et = 0,
                Q = b[0],
                Y) {
                    for (W = 0; W < $; W++)
                        tt = W * X,
                        Q.nx < tt && (Q = b[++et]),
                        z = Q.y + (tt - Q.x) / Q.cx * Q.cy,
                        L[W] = {
                            x: tt,
                            cx: X,
                            y: z,
                            cy: 0,
                            nx: 9
                        },
                        W && (L[W - 1].cy = z - L[W - 1].y);
                    L[$ - 1].cy = b[b.length - 1].y - z
                } else {
                    for (W = 0; W < $; W++)
                        Q.nx < W * X && (Q = b[++et]),
                        L[W] = Q;
                    et < b.length - 1 && (L[W - 1] = b[b.length - 2])
                }
                return this.ease = function(Z) {
                    var ot = L[Z * $ | 0] || L[$ - 1];
                    return ot.nx < Z && (ot = ot.n),
                    ot.y + (Z - ot.x) / ot.cx * ot.cy
                }
                ,
                this.ease.custom = this,
                this.id && _ && _.registerEase(this.id, this.ease),
                this
            }
            ,
            T.getSVGData = function(D) {
                return S.getSVGData(this, D)
            }
            ,
            S.create = function(D, C, k) {
                return new S(D,C,k).ease
            }
            ,
            S.register = function(D) {
                _ = D,
                v()
            }
            ,
            S.get = function(D) {
                return _.parseEase(D)
            }
            ,
            S.getSVGData = function(D, C) {
                C = C || {};
                var k = C.width || 100, R = C.height || 100, b = C.x || 0, L = (C.y || 0) + R, U = _.utils.toArray(C.path)[0], Y, $, z, j, W, X, et, Q, q, tt;
                if (C.invert && (R = -R,
                L = 0),
                typeof D == "string" && (D = _.parseEase(D)),
                D.custom && (D = D.custom),
                D instanceof S)
                    Y = g(f([D.segment], k, 0, 0, -R, b, L));
                else {
                    for (Y = [b, L],
                    et = Math.max(5, (C.precision || 1) * 200),
                    j = 1 / et,
                    et += 2,
                    Q = 5 / et,
                    q = P(b + j * k),
                    tt = P(L + D(j) * -R),
                    $ = (tt - L) / (q - b),
                    z = 2; z < et; z++)
                        W = P(b + z * j * k),
                        X = P(L + D(z * j) * -R),
                        (Math.abs((X - tt) / (W - q) - $) > Q || z === et - 1) && (Y.push(q, tt),
                        $ = (X - tt) / (W - q)),
                        q = W,
                        tt = X;
                    Y = "M" + Y.join(",")
                }
                return U && U.setAttribute("d", Y),
                Y
            }
            ,
            S
        }();
        y() && _.registerPlugin(B),
        B.version = "3.12.3",
        e.CustomEase = B,
        e.default = B,
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    })
}
)(Af, Af.exports);
var MT = Af.exports;
const Sf = um(MT);

var $s, d0, Mu, Ui, sl, lx, Cf, hx = function() {
    return typeof window < "u"
}, ux = function() {
    return $s || hx() && ($s = window.gsap) && $s.registerPlugin && $s
}, Pf = function(t) {
    return typeof t == "function"
}, cx = function(t) {
    return console.warn(t)
}, FT = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], Zi = .212671, Qi = .71516, Ji = .072169, dx = function(t) {
    return Pf(Ui[t]) ? Ui[t] : Ui.filters[t]
}, xc = function(t, e) {
    var i = [], r = 0, n = 0, o, a;
    for (o = 0; o < 4; o++) {
        for (a = 0; a < 5; a++)
            n = a === 4 ? t[r + 4] : 0,
            i[r + a] = t[r] * e[a] + t[r + 1] * e[a + 5] + t[r + 2] * e[a + 10] + t[r + 3] * e[a + 15] + n;
        r += 5
    }
    return i
}, f0 = function(t, e) {
    var i = 1 - e
      , r = i * Zi
      , n = i * Qi
      , o = i * Ji;
    return xc([r + e, n, o, 0, 0, r, n + e, o, 0, 0, r, n, o + e, 0, 0, 0, 0, 0, 1, 0], t)
}, p0 = function(t, e, i) {
    var r = Mu(e)
      , n = r[0] / 255
      , o = r[1] / 255
      , a = r[2] / 255
      , l = 1 - i;
    return xc([l + i * n * Zi, i * n * Qi, i * n * Ji, 0, 0, i * o * Zi, l + i * o * Qi, i * o * Ji, 0, 0, i * a * Zi, i * a * Qi, l + i * a * Ji, 0, 0, 0, 0, 0, 1, 0], t)
}, m0 = function(t, e) {
    e *= Math.PI / 180;
    var i = Math.cos(e)
      , r = Math.sin(e);
    return xc([Zi + i * (1 - Zi) + r * -Zi, Qi + i * -Qi + r * -Qi, Ji + i * -Ji + r * (1 - Ji), 0, 0, Zi + i * -Zi + r * .143, Qi + i * (1 - Qi) + r * .14, Ji + i * -Ji + r * -.283, 0, 0, Zi + i * -Zi + r * -(1 - Zi), Qi + i * -Qi + r * Qi, Ji + i * (1 - Ji) + r * Ji, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], t)
}, g0 = function(t, e) {
    return xc([e, 0, 0, 0, .5 * (1 - e), 0, e, 0, 0, .5 * (1 - e), 0, 0, e, 0, .5 * (1 - e), 0, 0, 0, 1, 0], t)
}, fx = function(t, e) {
    var i = dx(e), r = t.filters || [], n = r.length, o;
    for (i || cx(e + " not found. PixiPlugin.registerPIXI(PIXI)"); --n > -1; )
        if (r[n]instanceof i)
            return r[n];
    return o = new i,
    e === "BlurFilter" && (o.blur = 0),
    r.push(o),
    t.filters = r,
    o
}, Pe = function(t, e, i, r) {
    e.add(i, t, i[t], r[t]),
    e._props.push(t)
}, _0 = function(t, e) {
    var i = dx("ColorMatrixFilter")
      , r = new i;
    return r.matrix = e,
    r.brightness(t, !0),
    r.matrix
}, BT = function(t) {
    var e = {}, i;
    for (i in t)
        e[i] = t[i];
    return e
}, Ii = {
    contrast: 1,
    saturation: 1,
    colorizeAmount: 0,
    colorize: "rgb(255,255,255)",
    hue: 0,
    brightness: 1
}, OT = function(t, e, i) {
    var r = fx(t, "ColorMatrixFilter"), n = t._gsColorMatrixFilter = t._gsColorMatrixFilter || BT(Ii), o = e.combineCMF && !("colorMatrixFilter"in e && !e.colorMatrixFilter), a, l, h;
    for (h = r.matrix,
    e.resolution && (r.resolution = e.resolution),
    e.matrix && e.matrix.length === h.length ? (l = e.matrix,
    n.contrast !== 1 && Pe("contrast", i, n, Ii),
    n.hue && Pe("hue", i, n, Ii),
    n.brightness !== 1 && Pe("brightness", i, n, Ii),
    n.colorizeAmount && (Pe("colorize", i, n, Ii),
    Pe("colorizeAmount", i, n, Ii)),
    n.saturation !== 1 && Pe("saturation", i, n, Ii)) : (l = FT.slice(),
    e.contrast != null ? (l = g0(l, +e.contrast),
    Pe("contrast", i, n, e)) : n.contrast !== 1 && (o ? l = g0(l, n.contrast) : Pe("contrast", i, n, Ii)),
    e.hue != null ? (l = m0(l, +e.hue),
    Pe("hue", i, n, e)) : n.hue && (o ? l = m0(l, n.hue) : Pe("hue", i, n, Ii)),
    e.brightness != null ? (l = _0(+e.brightness, l),
    Pe("brightness", i, n, e)) : n.brightness !== 1 && (o ? l = _0(n.brightness, l) : Pe("brightness", i, n, Ii)),
    e.colorize != null ? (e.colorizeAmount = "colorizeAmount"in e ? +e.colorizeAmount : 1,
    l = p0(l, e.colorize, e.colorizeAmount),
    Pe("colorize", i, n, e),
    Pe("colorizeAmount", i, n, e)) : n.colorizeAmount && (o ? l = p0(l, n.colorize, n.colorizeAmount) : (Pe("colorize", i, n, Ii),
    Pe("colorizeAmount", i, n, Ii))),
    e.saturation != null ? (l = f0(l, +e.saturation),
    Pe("saturation", i, n, e)) : n.saturation !== 1 && (o ? l = f0(l, n.saturation) : Pe("saturation", i, n, Ii))),
    a = l.length; --a > -1; )
        l[a] !== h[a] && i.add(h, a, h[a], l[a], "colorMatrixFilter");
    i._props.push("colorMatrixFilter")
}, kT = function(t, e) {
    var i = e.t
      , r = e.p
      , n = e.color
      , o = e.set;
    o(i, r, n[0] << 16 | n[1] << 8 | n[2])
}, LT = function(t, e) {
    var i = e.g;
    i && (i.dirty++,
    i.clearDirty++)
}, NT = function(t, e) {
    e.t.visible = !!e.t.alpha
}, y0 = function(t, e, i, r) {
    var n = t[e]
      , o = Mu(Pf(n) ? t[e.indexOf("set") || !Pf(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)]() : n)
      , a = Mu(i);
    r._pt = new sl(r._pt,t,e,0,0,kT,{
        t,
        p: e,
        color: o,
        set: lx(t, e)
    }),
    r.add(o, 0, o[0], a[0]),
    r.add(o, 1, o[1], a[1]),
    r.add(o, 2, o[2], a[2])
}, UT = {
    tint: 1,
    lineColor: 1,
    fillColor: 1
}, v0 = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","), If = {
    x: "position",
    y: "position",
    tileX: "tilePosition",
    tileY: "tilePosition"
}, GT = {
    colorMatrixFilter: 1,
    saturation: 1,
    contrast: 1,
    hue: 1,
    colorize: 1,
    colorizeAmount: 1,
    brightness: 1,
    combineCMF: 1
}, Fu = Math.PI / 180, px = function(t) {
    return typeof t == "string"
}, HT = function(t) {
    return px(t) && t.charAt(1) === "=" ? t.substr(0, 2) + parseFloat(t.substr(2)) * Fu : t * Fu
}, $T = function(t, e) {
    return e.set(e.t, e.p, t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e5) / 1e5, e)
}, zT = function(t, e, i, r, n, o) {
    var a = 360 * (o ? Fu : 1), l = px(n), h = l && n.charAt(1) === "=" ? +(n.charAt(0) + "1") : 0, u = parseFloat(h ? n.substr(2) : n) * (o ? Fu : 1), c = h ? u * h : u - r, d = r + c, f, p;
    return l && (f = n.split("_")[1],
    f === "short" && (c %= a,
    c !== c % (a / 2) && (c += c < 0 ? a : -a)),
    f === "cw" && c < 0 ? c = (c + a * 1e10) % a - ~~(c / a) * a : f === "ccw" && c > 0 && (c = (c - a * 1e10) % a - ~~(c / a) * a)),
    t._pt = p = new sl(t._pt,e,i,r,c,$T),
    p.e = d,
    p
}, x0 = function() {
    hx() && (d0 = window,
    $s = ux(),
    Ui = Ui || d0.PIXI,
    Cf = Ui && Ui.VERSION && Ui.VERSION.charAt(0) === "4",
    Mu = function(e) {
        return $s.utils.splitColor((e + "").substr(0, 2) === "0x" ? "#" + e.substr(2) : e)
    }
    )
}, xh, ga;
for (xh = 0; xh < v0.length; xh++)
    ga = v0[xh],
    If[ga + "X"] = ga,
    If[ga + "Y"] = ga;
var cm = {
    version: "3.12.3",
    name: "pixi",
    register: function(t, e, i) {
        $s = t,
        sl = i,
        lx = e.getSetter,
        x0()
    },
    registerPIXI: function(t) {
        Ui = t
    },
    init: function(t, e, i, r, n) {
        if (Ui || x0(),
        !Ui || !(t instanceof Ui.DisplayObject))
            return cx(t),
            !1;
        var o, a, l, h, u, c, d, f, p;
        for (c in e) {
            if (o = If[c],
            l = e[c],
            o)
                a = ~c.charAt(c.length - 1).toLowerCase().indexOf("x") ? "x" : "y",
                this.add(t[o], a, t[o][a], o === "skew" ? HT(l) : l, 0, 0, 0, 0, 0, 1);
            else if (c === "scale" || c === "anchor" || c === "pivot" || c === "tileScale")
                this.add(t[c], "x", t[c].x, l),
                this.add(t[c], "y", t[c].y, l);
            else if (c === "rotation" || c === "angle")
                zT(this, t, c, t[c], l, c === "rotation");
            else if (GT[c])
                h || (OT(t, e.colorMatrixFilter || e, this),
                h = !0);
            else if (c === "blur" || c === "blurX" || c === "blurY" || c === "blurPadding") {
                if (u = fx(t, "BlurFilter"),
                this.add(u, c, u[c], l),
                e.blurPadding !== 0)
                    for (d = e.blurPadding || Math.max(u[c], l) * 2,
                    f = t.filters.length; --f > -1; )
                        t.filters[f].padding = Math.max(t.filters[f].padding, d)
            } else if (UT[c])
                if ((c === "lineColor" || c === "fillColor") && t instanceof Ui.Graphics)
                    for (p = (t.geometry || t).graphicsData,
                    this._pt = new sl(this._pt,t,c,0,0,LT,{
                        g: t.geometry || t
                    }),
                    f = p.length; --f > -1; )
                        y0(Cf ? p[f] : p[f][c.substr(0, 4) + "Style"], Cf ? c : "color", l, this);
                else
                    y0(t, c, l, this);
            else
                c === "autoAlpha" ? (this._pt = new sl(this._pt,t,"visible",0,0,NT),
                this.add(t, "alpha", t.alpha, l),
                this._props.push("alpha", "visible")) : c !== "resolution" && this.add(t, c, "get", l);
            this._props.push(c)
        }
    }
};
ux() && $s.registerPlugin(cm);

var ps, Bn, dm, bc, Ba, au, Bu, nl, vr = "transform", Rf = vr + "Origin", mx, fm = function(t) {
    var e = t.ownerDocument || t;
    for (!(vr in t.style) && ("msTransform"in t.style) && (vr = "msTransform",
    Rf = vr + "Origin"); e.parentNode && (e = e.parentNode); )
        ;
    if (Bn = window,
    Bu = new Wn,
    e) {
        ps = e,
        dm = e.documentElement,
        bc = e.body,
        nl = ps.createElementNS("http://www.w3.org/2000/svg", "g"),
        nl.style.transform = "none";
        var i = e.createElement("div")
          , r = e.createElement("div")
          , n = e && (e.body || e.firstElementChild);
        n && n.appendChild && (n.appendChild(i),
        i.appendChild(r),
        i.setAttribute("style", "position:static;transform:translate3d(0,0,1px)"),
        mx = r.offsetParent !== i,
        n.removeChild(i))
    }
    return e
}, VT = function(t) {
    for (var e, i; t && t !== bc; )
        i = t._gsap,
        i && i.uncache && i.get(t, "x"),
        i && !i.scaleX && !i.scaleY && i.renderTransform && (i.scaleX = i.scaleY = 1e-4,
        i.renderTransform(1, i),
        e ? e.push(i) : e = [i]),
        t = t.parentNode;
    return e
}, gx = [], _x = [], pm = function() {
    return Bn.pageYOffset || ps.scrollTop || dm.scrollTop || bc.scrollTop || 0
}, mm = function() {
    return Bn.pageXOffset || ps.scrollLeft || dm.scrollLeft || bc.scrollLeft || 0
}, gm = function(t) {
    return t.ownerSVGElement || ((t.tagName + "").toLowerCase() === "svg" ? t : null)
}, XT = function s(t) {
    if (Bn.getComputedStyle(t).position === "fixed")
        return !0;
    if (t = t.parentNode,
    t && t.nodeType === 1)
        return s(t)
}, rd = function s(t, e) {
    if (t.parentNode && (ps || fm(t))) {
        var i = gm(t)
          , r = i ? i.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml"
          , n = i ? e ? "rect" : "g" : "div"
          , o = e !== 2 ? 0 : 100
          , a = e === 3 ? 100 : 0
          , l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;"
          , h = ps.createElementNS ? ps.createElementNS(r.replace(/^https/, "http"), n) : ps.createElement(n);
        return e && (i ? (au || (au = s(t)),
        h.setAttribute("width", .01),
        h.setAttribute("height", .01),
        h.setAttribute("transform", "translate(" + o + "," + a + ")"),
        au.appendChild(h)) : (Ba || (Ba = s(t),
        Ba.style.cssText = l),
        h.style.cssText = l + "width:0.1px;height:0.1px;top:" + a + "px;left:" + o + "px",
        Ba.appendChild(h))),
        h
    }
    throw "Need document and parent."
}, WT = function(t) {
    for (var e = new Wn, i = 0; i < t.numberOfItems; i++)
        e.multiply(t.getItem(i).matrix);
    return e
}, yx = function(t) {
    var e = t.getCTM(), i;
    return e || (i = t.style[vr],
    t.style[vr] = "none",
    t.appendChild(nl),
    e = nl.getCTM(),
    t.removeChild(nl),
    i ? t.style[vr] = i : t.style.removeProperty(vr.replace(/([A-Z])/g, "-$1").toLowerCase())),
    e || Bu.clone()
}, jT = function(t, e) {
    var i = gm(t), r = t === i, n = i ? gx : _x, o = t.parentNode, a, l, h, u, c, d;
    if (t === Bn)
        return t;
    if (n.length || n.push(rd(t, 1), rd(t, 2), rd(t, 3)),
    a = i ? au : Ba,
    i)
        r ? (h = yx(t),
        u = -h.e / h.a,
        c = -h.f / h.d,
        l = Bu) : t.getBBox ? (h = t.getBBox(),
        l = t.transform ? t.transform.baseVal : {},
        l = l.numberOfItems ? l.numberOfItems > 1 ? WT(l) : l.getItem(0).matrix : Bu,
        u = l.a * h.x + l.c * h.y,
        c = l.b * h.x + l.d * h.y) : (l = new Wn,
        u = c = 0),
        e && t.tagName.toLowerCase() === "g" && (u = c = 0),
        (r ? i : o).appendChild(a),
        a.setAttribute("transform", "matrix(" + l.a + "," + l.b + "," + l.c + "," + l.d + "," + (l.e + u) + "," + (l.f + c) + ")");
    else {
        if (u = c = 0,
        mx)
            for (l = t.offsetParent,
            h = t; h && (h = h.parentNode) && h !== l && h.parentNode; )
                (Bn.getComputedStyle(h)[vr] + "").length > 4 && (u = h.offsetLeft,
                c = h.offsetTop,
                h = 0);
        if (d = Bn.getComputedStyle(t),
        d.position !== "absolute" && d.position !== "fixed")
            for (l = t.offsetParent; o && o !== l; )
                u += o.scrollLeft || 0,
                c += o.scrollTop || 0,
                o = o.parentNode;
        h = a.style,
        h.top = t.offsetTop - c + "px",
        h.left = t.offsetLeft - u + "px",
        h[vr] = d[vr],
        h[Rf] = d[Rf],
        h.position = d.position === "fixed" ? "fixed" : "absolute",
        t.parentNode.appendChild(a)
    }
    return a
}, sd = function(t, e, i, r, n, o, a) {
    return t.a = e,
    t.b = i,
    t.c = r,
    t.d = n,
    t.e = o,
    t.f = a,
    t
}, Wn = function() {
    function s(e, i, r, n, o, a) {
        e === void 0 && (e = 1),
        i === void 0 && (i = 0),
        r === void 0 && (r = 0),
        n === void 0 && (n = 1),
        o === void 0 && (o = 0),
        a === void 0 && (a = 0),
        sd(this, e, i, r, n, o, a)
    }
    var t = s.prototype;
    return t.inverse = function() {
        var i = this.a
          , r = this.b
          , n = this.c
          , o = this.d
          , a = this.e
          , l = this.f
          , h = i * o - r * n || 1e-10;
        return sd(this, o / h, -r / h, -n / h, i / h, (n * l - o * a) / h, -(i * l - r * a) / h)
    }
    ,
    t.multiply = function(i) {
        var r = this.a
          , n = this.b
          , o = this.c
          , a = this.d
          , l = this.e
          , h = this.f
          , u = i.a
          , c = i.c
          , d = i.b
          , f = i.d
          , p = i.e
          , m = i.f;
        return sd(this, u * r + d * o, u * n + d * a, c * r + f * o, c * n + f * a, l + p * r + m * o, h + p * n + m * a)
    }
    ,
    t.clone = function() {
        return new s(this.a,this.b,this.c,this.d,this.e,this.f)
    }
    ,
    t.equals = function(i) {
        var r = this.a
          , n = this.b
          , o = this.c
          , a = this.d
          , l = this.e
          , h = this.f;
        return r === i.a && n === i.b && o === i.c && a === i.d && l === i.e && h === i.f
    }
    ,
    t.apply = function(i, r) {
        r === void 0 && (r = {});
        var n = i.x
          , o = i.y
          , a = this.a
          , l = this.b
          , h = this.c
          , u = this.d
          , c = this.e
          , d = this.f;
        return r.x = n * a + o * h + c || 0,
        r.y = n * l + o * u + d || 0,
        r
    }
    ,
    s
}();
function es(s, t, e, i) {
    if (!s || !s.parentNode || (ps || fm(s)).documentElement === s)
        return new Wn;
    var r = VT(s)
      , n = gm(s)
      , o = n ? gx : _x
      , a = jT(s, e)
      , l = o[0].getBoundingClientRect()
      , h = o[1].getBoundingClientRect()
      , u = o[2].getBoundingClientRect()
      , c = a.parentNode
      , d = !i && XT(s)
      , f = new Wn((h.left - l.left) / 100,(h.top - l.top) / 100,(u.left - l.left) / 100,(u.top - l.top) / 100,l.left + (d ? 0 : mm()),l.top + (d ? 0 : pm()));
    if (c.removeChild(a),
    r)
        for (l = r.length; l--; )
            h = r[l],
            h.scaleX = h.scaleY = 0,
            h.renderTransform(1, h);
    return t ? f.inverse() : f
}
/*!
 * Flip 3.12.3
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var qT = 1, Qo, Ze, te, ol, Bs, ms, Mf, b0 = function(t, e) {
    return t.actions.forEach(function(i) {
        return i.vars[e] && i.vars[e](i)
    })
}, Ff = {}, w0 = 180 / Math.PI, YT = Math.PI / 180, Ou = {}, E0 = {}, wc = {}, _m = function(t) {
    return typeof t == "string" ? t.split(" ").join("").split(",") : t
}, KT = _m("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"), Ec = _m("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"), al = function(t) {
    return Qo(t)[0] || console.warn("Element not found:", t)
}, So = function(t) {
    return Math.round(t * 1e4) / 1e4 || 0
}, nd = function(t, e, i) {
    return t.forEach(function(r) {
        return r.classList[i](e)
    })
}, T0 = {
    zIndex: 1,
    kill: 1,
    simple: 1,
    spin: 1,
    clearProps: 1,
    targets: 1,
    toggleClass: 1,
    onComplete: 1,
    onUpdate: 1,
    onInterrupt: 1,
    onStart: 1,
    delay: 1,
    repeat: 1,
    repeatDelay: 1,
    yoyo: 1,
    scale: 1,
    fade: 1,
    absolute: 1,
    props: 1,
    onEnter: 1,
    onLeave: 1,
    custom: 1,
    paused: 1,
    nested: 1,
    prune: 1,
    absoluteOnLeave: 1
}, vx = {
    zIndex: 1,
    simple: 1,
    clearProps: 1,
    scale: 1,
    absolute: 1,
    fitChild: 1,
    getVars: 1,
    props: 1
}, xx = function(t) {
    return t.replace(/([A-Z])/g, "-$1").toLowerCase()
}, Co = function(t, e) {
    var i = {}, r;
    for (r in t)
        e[r] || (i[r] = t[r]);
    return i
}, ym = {}, bx = function(t) {
    var e = ym[t] = _m(t);
    return wc[t] = e.concat(Ec),
    e
}, ZT = function(t) {
    var e = t._gsap || Ze.core.getCache(t);
    return e.gmCache === Ze.ticker.frame ? e.gMatrix : (e.gmCache = Ze.ticker.frame,
    e.gMatrix = es(t, !0, !1, !0))
}, QT = function s(t, e, i) {
    i === void 0 && (i = 0);
    for (var r = t.parentNode, n = 1e3 * Math.pow(10, i) * (e ? -1 : 1), o = e ? -n * 900 : 0; t; )
        o += n,
        t = t.previousSibling;
    return r ? o + s(r, e, i + 1) : o
}, ku = function(t, e, i) {
    return t.forEach(function(r) {
        return r.d = QT(i ? r.element : r.t, e)
    }),
    t.sort(function(r, n) {
        return r.d - n.d
    }),
    t
}, Sl = function(t, e) {
    for (var i = t.element.style, r = t.css = t.css || [], n = e.length, o, a; n--; )
        o = e[n],
        a = i[o] || i.getPropertyValue(o),
        r.push(a ? o : E0[o] || (E0[o] = xx(o)), a);
    return i
}, Lu = function(t) {
    var e = t.css
      , i = t.element.style
      , r = 0;
    for (t.cache.uncache = 1; r < e.length; r += 2)
        e[r + 1] ? i[e[r]] = e[r + 1] : i.removeProperty(e[r]);
    !e[e.indexOf("transform") + 1] && i.translate && (i.removeProperty("translate"),
    i.removeProperty("scale"),
    i.removeProperty("rotate"))
}, D0 = function(t, e) {
    t.forEach(function(i) {
        return i.a.cache.uncache = 1
    }),
    e || t.finalStates.forEach(Lu)
}, od = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","), vm = function(t, e, i) {
    var r = t.element, n = t.width, o = t.height, a = t.uncache, l = t.getProp, h = r.style, u = 4, c, d, f;
    if (typeof e != "object" && (e = t),
    te && i !== 1)
        return te._abs.push({
            t: r,
            b: t,
            a: t,
            sd: 0
        }),
        te._final.push(function() {
            return (t.cache.uncache = 1) && Lu(t)
        }),
        r;
    for (d = l("display") === "none",
    (!t.isVisible || d) && (d && (Sl(t, ["display"]).display = e.display),
    t.matrix = e.matrix,
    t.width = n = t.width || e.width,
    t.height = o = t.height || e.height),
    Sl(t, od),
    f = window.getComputedStyle(r); u--; )
        h[od[u]] = f[od[u]];
    if (h.gridArea = "1 / 1 / 1 / 1",
    h.transition = "none",
    h.position = "absolute",
    h.width = n + "px",
    h.height = o + "px",
    h.top || (h.top = "0px"),
    h.left || (h.left = "0px"),
    a)
        c = new jn(r);
    else if (c = Co(t, Ou),
    c.position = "absolute",
    t.simple) {
        var p = r.getBoundingClientRect();
        c.matrix = new Wn(1,0,0,1,p.left + mm(),p.top + pm())
    } else
        c.matrix = es(r, !1, !1, !0);
    return c = Lo(c, t, !0),
    t.x = ms(c.x, .01),
    t.y = ms(c.y, .01),
    r
}, A0 = function(t, e) {
    return e !== !0 && (e = Qo(e),
    t = t.filter(function(i) {
        if (e.indexOf((i.sd < 0 ? i.b : i.a).element) !== -1)
            return !0;
        i.t._gsap.renderTransform(1),
        i.b.isVisible && (i.t.style.width = i.b.width + "px",
        i.t.style.height = i.b.height + "px")
    })),
    t
}, wx = function(t) {
    return ku(t, !0).forEach(function(e) {
        return (e.a.isVisible || e.b.isVisible) && vm(e.sd < 0 ? e.b : e.a, e.b, 1)
    })
}, JT = function(t, e) {
    return e && t.idLookup[Bf(e).id] || t.elementStates[0]
}, Bf = function(t, e, i, r) {
    return t instanceof jn ? t : t instanceof wr ? JT(t, r) : new jn(typeof t == "string" ? al(t) || console.warn(t + " not found") : t,e,i)
}, tD = function(t, e) {
    for (var i = Ze.getProperty(t.element, null, "native"), r = t.props = {}, n = e.length; n--; )
        r[e[n]] = (i(e[n]) + "").trim();
    return r.zIndex && (r.zIndex = parseFloat(r.zIndex) || 0),
    t
}, Ex = function(t, e) {
    var i = t.style || t, r;
    for (r in e)
        i[r] = e[r]
}, eD = function(t) {
    var e = t.getAttribute("data-flip-id");
    return e || t.setAttribute("data-flip-id", e = "auto-" + qT++),
    e
}, Tx = function(t) {
    return t.map(function(e) {
        return e.element
    })
}, S0 = function(t, e, i) {
    return t && e.length && i.add(t(Tx(e), i, new wr(e,0,!0)), 0)
}, Lo = function(t, e, i, r, n, o) {
    var a = t.element, l = t.cache, h = t.parent, u = t.x, c = t.y, d = e.width, f = e.height, p = e.scaleX, m = e.scaleY, g = e.rotation, _ = e.bounds, x = o && Mf && Mf(a, "transform"), y = t, v = e.matrix, E = v.e, P = v.f, w = t.bounds.width !== _.width || t.bounds.height !== _.height || t.scaleX !== p || t.scaleY !== m || t.rotation !== g, A = !w && t.simple && e.simple && !n, I, F, O, B, S, T, M;
    return A || !h ? (p = m = 1,
    g = I = 0) : (S = ZT(h),
    T = S.clone().multiply(e.ctm ? e.matrix.clone().multiply(e.ctm) : e.matrix),
    g = So(Math.atan2(T.b, T.a) * w0),
    I = So(Math.atan2(T.c, T.d) * w0 + g) % 360,
    p = Math.sqrt(Math.pow(T.a, 2) + Math.pow(T.b, 2)),
    m = Math.sqrt(Math.pow(T.c, 2) + Math.pow(T.d, 2)) * Math.cos(I * YT),
    n && (n = Qo(n)[0],
    B = Ze.getProperty(n),
    M = n.getBBox && typeof n.getBBox == "function" && n.getBBox(),
    y = {
        scaleX: B("scaleX"),
        scaleY: B("scaleY"),
        width: M ? M.width : Math.ceil(parseFloat(B("width", "px"))),
        height: M ? M.height : parseFloat(B("height", "px"))
    }),
    l.rotation = g + "deg",
    l.skewX = I + "deg"),
    i ? (p *= d === y.width || !y.width ? 1 : d / y.width,
    m *= f === y.height || !y.height ? 1 : f / y.height,
    l.scaleX = p,
    l.scaleY = m) : (d = ms(d * p / y.scaleX, 0),
    f = ms(f * m / y.scaleY, 0),
    a.style.width = d + "px",
    a.style.height = f + "px"),
    r && Ex(a, e.props),
    A || !h ? (u += E - t.matrix.e,
    c += P - t.matrix.f) : w || h !== e.parent ? (l.renderTransform(1, l),
    T = es(n || a, !1, !1, !0),
    F = S.apply({
        x: T.e,
        y: T.f
    }),
    O = S.apply({
        x: E,
        y: P
    }),
    u += O.x - F.x,
    c += O.y - F.y) : (S.e = S.f = 0,
    O = S.apply({
        x: E - t.matrix.e,
        y: P - t.matrix.f
    }),
    u += O.x,
    c += O.y),
    u = ms(u, .02),
    c = ms(c, .02),
    o && !(o instanceof jn) ? x && x.revert() : (l.x = u + "px",
    l.y = c + "px",
    l.renderTransform(1, l)),
    o && (o.x = u,
    o.y = c,
    o.rotation = g,
    o.skewX = I,
    i ? (o.scaleX = p,
    o.scaleY = m) : (o.width = d,
    o.height = f)),
    o || l
}, ad = function(t, e) {
    return t instanceof wr ? t : new wr(t,e)
}, Dx = function(t, e, i) {
    var r = t.idLookup[i]
      , n = t.alt[i];
    return n.isVisible && (!(e.getElementState(n.element) || n).isVisible || !r.isVisible) ? n : r
}, ld = [], hd = "width,height,overflowX,overflowY".split(","), bh, C0 = function(t) {
    if (t !== bh) {
        var e = Bs.style
          , i = Bs.clientWidth === window.outerWidth
          , r = Bs.clientHeight === window.outerHeight
          , n = 4;
        if (t && (i || r)) {
            for (; n--; )
                ld[n] = e[hd[n]];
            i && (e.width = Bs.clientWidth + "px",
            e.overflowY = "hidden"),
            r && (e.height = Bs.clientHeight + "px",
            e.overflowX = "hidden"),
            bh = t
        } else if (bh) {
            for (; n--; )
                ld[n] ? e[hd[n]] = ld[n] : e.removeProperty(xx(hd[n]));
            bh = t
        }
    }
}, ud = function(t, e, i, r) {
    t instanceof wr && e instanceof wr || console.warn("Not a valid state object."),
    i = i || {};
    var n = i, o = n.clearProps, a = n.onEnter, l = n.onLeave, h = n.absolute, u = n.absoluteOnLeave, c = n.custom, d = n.delay, f = n.paused, p = n.repeat, m = n.repeatDelay, g = n.yoyo, _ = n.toggleClass, x = n.nested, y = n.zIndex, v = n.scale, E = n.fade, P = n.stagger, w = n.spin, A = n.prune, I = ("props"in i ? i : t).props, F = Co(i, T0), O = Ze.timeline({
        delay: d,
        paused: f,
        repeat: p,
        repeatDelay: m,
        yoyo: g,
        data: "isFlip"
    }), B = F, S = [], T = [], M = [], D = [], C = w === !0 ? 1 : w || 0, k = typeof w == "function" ? w : function() {
        return C
    }
    , R = t.interrupted || e.interrupted, b = O[r !== 1 ? "to" : "from"], L, U, Y, $, z, j, W, X, et, Q, q, tt, Z, ot;
    for (U in e.idLookup)
        q = e.alt[U] ? Dx(e, t, U) : e.idLookup[U],
        z = q.element,
        Q = t.idLookup[U],
        t.alt[U] && z === Q.element && (t.alt[U].isVisible || !q.isVisible) && (Q = t.alt[U]),
        Q ? (j = {
            t: z,
            b: Q,
            a: q,
            sd: Q.element === z ? 0 : q.isVisible ? 1 : -1
        },
        M.push(j),
        j.sd && (j.sd < 0 && (j.b = q,
        j.a = Q),
        R && Sl(j.b, I ? wc[I] : Ec),
        E && M.push(j.swap = {
            t: Q.element,
            b: j.b,
            a: j.a,
            sd: -j.sd,
            swap: j
        })),
        z._flip = Q.element._flip = te ? te.timeline : O) : q.isVisible && (M.push({
            t: z,
            b: Co(q, {
                isVisible: 1
            }),
            a: q,
            sd: 0,
            entering: 1
        }),
        z._flip = te ? te.timeline : O);
    if (I && (ym[I] || bx(I)).forEach(function(H) {
        return F[H] = function(Ct) {
            return M[Ct].a.props[H]
        }
    }),
    M.finalStates = et = [],
    tt = function() {
        for (ku(M),
        C0(!0),
        $ = 0; $ < M.length; $++)
            j = M[$],
            Z = j.a,
            ot = j.b,
            A && !Z.isDifferent(ot) && !j.entering ? M.splice($--, 1) : (z = j.t,
            x && !(j.sd < 0) && $ && (Z.matrix = es(z, !1, !1, !0)),
            ot.isVisible && Z.isVisible ? (j.sd < 0 ? (W = new jn(z,I,t.simple),
            Lo(W, Z, v, 0, 0, W),
            W.matrix = es(z, !1, !1, !0),
            W.css = j.b.css,
            j.a = Z = W,
            E && (z.style.opacity = R ? ot.opacity : Z.opacity),
            P && D.push(z)) : j.sd > 0 && E && (z.style.opacity = R ? Z.opacity - ot.opacity : "0"),
            Lo(Z, ot, v, I)) : ot.isVisible !== Z.isVisible && (ot.isVisible ? Z.isVisible || (ot.css = Z.css,
            T.push(ot),
            M.splice($--, 1),
            h && x && Lo(Z, ot, v, I)) : (Z.isVisible && S.push(Z),
            M.splice($--, 1))),
            v || (z.style.maxWidth = Math.max(Z.width, ot.width) + "px",
            z.style.maxHeight = Math.max(Z.height, ot.height) + "px",
            z.style.minWidth = Math.min(Z.width, ot.width) + "px",
            z.style.minHeight = Math.min(Z.height, ot.height) + "px"),
            x && _ && z.classList.add(_)),
            et.push(Z);
        var Ct;
        if (_ && (Ct = et.map(function(V) {
            return V.element
        }),
        x && Ct.forEach(function(V) {
            return V.classList.remove(_)
        })),
        C0(!1),
        v ? (F.scaleX = function(V) {
            return M[V].a.scaleX
        }
        ,
        F.scaleY = function(V) {
            return M[V].a.scaleY
        }
        ) : (F.width = function(V) {
            return M[V].a.width + "px"
        }
        ,
        F.height = function(V) {
            return M[V].a.height + "px"
        }
        ,
        F.autoRound = i.autoRound || !1),
        F.x = function(V) {
            return M[V].a.x + "px"
        }
        ,
        F.y = function(V) {
            return M[V].a.y + "px"
        }
        ,
        F.rotation = function(V) {
            return M[V].a.rotation + (w ? k(V, X[V], X) * 360 : 0)
        }
        ,
        F.skewX = function(V) {
            return M[V].a.skewX
        }
        ,
        X = M.map(function(V) {
            return V.t
        }),
        (y || y === 0) && (F.modifiers = {
            zIndex: function() {
                return y
            }
        },
        F.zIndex = y,
        F.immediateRender = i.immediateRender !== !1),
        E && (F.opacity = function(V) {
            return M[V].sd < 0 ? 0 : M[V].sd > 0 ? M[V].a.opacity : "+=0"
        }
        ),
        D.length) {
            P = Ze.utils.distribute(P);
            var K = X.slice(D.length);
            F.stagger = function(V, ut) {
                return P(~D.indexOf(ut) ? X.indexOf(M[V].swap.t) : V, ut, K)
            }
        }
        if (KT.forEach(function(V) {
            return i[V] && O.eventCallback(V, i[V], i[V + "Params"])
        }),
        c && X.length) {
            B = Co(F, T0),
            "scale"in c && (c.scaleX = c.scaleY = c.scale,
            delete c.scale);
            for (U in c)
                L = Co(c[U], vx),
                L[U] = F[U],
                !("duration"in L) && "duration"in F && (L.duration = F.duration),
                L.stagger = F.stagger,
                b.call(O, X, L, 0),
                delete B[U]
        }
        (X.length || T.length || S.length) && (_ && O.add(function() {
            return nd(Ct, _, O._zTime < 0 ? "remove" : "add")
        }, 0) && !f && nd(Ct, _, "add"),
        X.length && b.call(O, X, B, 0)),
        S0(a, S, O),
        S0(l, T, O);
        var G = te && te.timeline;
        G && (G.add(O, 0),
        te._final.push(function() {
            return D0(M, !o)
        })),
        Y = O.duration(),
        O.call(function() {
            var V = O.time() >= Y;
            V && !G && D0(M, !o),
            _ && nd(Ct, _, V ? "remove" : "add")
        })
    }
    ,
    u && (h = M.filter(function(H) {
        return !H.sd && !H.a.isVisible && H.b.isVisible
    }).map(function(H) {
        return H.a.element
    })),
    te) {
        var vt;
        h && (vt = te._abs).push.apply(vt, A0(M, h)),
        te._run.push(tt)
    } else
        h && wx(A0(M, h)),
        tt();
    var It = te ? te.timeline : O;
    return It.revert = function() {
        return xm(It, 1, 1)
    }
    ,
    It
}, iD = function s(t) {
    t.vars.onInterrupt && t.vars.onInterrupt.apply(t, t.vars.onInterruptParams || []),
    t.getChildren(!0, !1, !0).forEach(s)
}, xm = function(t, e, i) {
    if (t && t.progress() < 1 && (!t.paused() || i))
        return e && (iD(t),
        e < 2 && t.progress(1),
        t.kill()),
        !0
}, wh = function(t) {
    for (var e = t.idLookup = {}, i = t.alt = {}, r = t.elementStates, n = r.length, o; n--; )
        o = r[n],
        e[o.id] ? i[o.id] = o : e[o.id] = o
}, wr = function() {
    function s(e, i, r) {
        if (this.props = i && i.props,
        this.simple = !!(i && i.simple),
        r)
            this.targets = Tx(e),
            this.elementStates = e,
            wh(this);
        else {
            this.targets = Qo(e);
            var n = i && (i.kill === !1 || i.batch && !i.kill);
            te && !n && te._kill.push(this),
            this.update(n || !!te)
        }
    }
    var t = s.prototype;
    return t.update = function(i) {
        var r = this;
        return this.elementStates = this.targets.map(function(n) {
            return new jn(n,r.props,r.simple)
        }),
        wh(this),
        this.interrupt(i),
        this.recordInlineStyles(),
        this
    }
    ,
    t.clear = function() {
        return this.targets.length = this.elementStates.length = 0,
        wh(this),
        this
    }
    ,
    t.fit = function(i, r, n) {
        for (var o = ku(this.elementStates.slice(0), !1, !0), a = (i || this).idLookup, l = 0, h, u; l < o.length; l++)
            h = o[l],
            n && (h.matrix = es(h.element, !1, !1, !0)),
            u = a[h.id],
            u && Lo(h, u, r, !0, 0, h),
            h.matrix = es(h.element, !1, !1, !0);
        return this
    }
    ,
    t.getProperty = function(i, r) {
        var n = this.getElementState(i) || Ou;
        return (r in n ? n : n.props || Ou)[r]
    }
    ,
    t.add = function(i) {
        for (var r = i.targets.length, n = this.idLookup, o = this.alt, a, l, h; r--; )
            l = i.elementStates[r],
            h = n[l.id],
            h && (l.element === h.element || o[l.id] && o[l.id].element === l.element) ? (a = this.elementStates.indexOf(l.element === h.element ? h : o[l.id]),
            this.targets.splice(a, 1, i.targets[r]),
            this.elementStates.splice(a, 1, l)) : (this.targets.push(i.targets[r]),
            this.elementStates.push(l));
        return i.interrupted && (this.interrupted = !0),
        i.simple || (this.simple = !1),
        wh(this),
        this
    }
    ,
    t.compare = function(i) {
        var r = i.idLookup, n = this.idLookup, o = [], a = [], l = [], h = [], u = [], c = i.alt, d = this.alt, f = function(A, I, F) {
            return (A.isVisible !== I.isVisible ? A.isVisible ? l : h : A.isVisible ? a : o).push(F) && u.push(F)
        }, p = function(A, I, F) {
            return u.indexOf(F) < 0 && f(A, I, F)
        }, m, g, _, x, y, v, E, P;
        for (_ in r)
            y = c[_],
            v = d[_],
            m = y ? Dx(i, this, _) : r[_],
            x = m.element,
            g = n[_],
            v ? (P = g.isVisible || !v.isVisible && x === g.element ? g : v,
            E = y && !m.isVisible && !y.isVisible && P.element === y.element ? y : m,
            E.isVisible && P.isVisible && E.element !== P.element ? ((E.isDifferent(P) ? a : o).push(E.element, P.element),
            u.push(E.element, P.element)) : f(E, P, E.element),
            y && E.element === y.element && (y = r[_]),
            p(E.element !== g.element && y ? y : E, g, g.element),
            p(y && y.element === v.element ? y : E, v, v.element),
            y && p(y, v.element === y.element ? v : g, y.element)) : (g ? g.isDifferent(m) ? f(m, g, x) : o.push(x) : l.push(x),
            y && p(y, g, y.element));
        for (_ in n)
            r[_] || (h.push(n[_].element),
            d[_] && h.push(d[_].element));
        return {
            changed: a,
            unchanged: o,
            enter: l,
            leave: h
        }
    }
    ,
    t.recordInlineStyles = function() {
        for (var i = wc[this.props] || Ec, r = this.elementStates.length; r--; )
            Sl(this.elementStates[r], i)
    }
    ,
    t.interrupt = function(i) {
        var r = this
          , n = [];
        this.targets.forEach(function(o) {
            var a = o._flip
              , l = xm(a, i ? 0 : 1);
            i && l && n.indexOf(a) < 0 && a.add(function() {
                return r.updateVisibility()
            }),
            l && n.push(a)
        }),
        !i && n.length && this.updateVisibility(),
        this.interrupted || (this.interrupted = !!n.length)
    }
    ,
    t.updateVisibility = function() {
        this.elementStates.forEach(function(i) {
            var r = i.element.getBoundingClientRect();
            i.isVisible = !!(r.width || r.height || r.top || r.left),
            i.uncache = 1
        })
    }
    ,
    t.getElementState = function(i) {
        return this.elementStates[this.targets.indexOf(al(i))]
    }
    ,
    t.makeAbsolute = function() {
        return ku(this.elementStates.slice(0), !0, !0).map(vm)
    }
    ,
    s
}(), jn = function() {
    function s(e, i, r) {
        this.element = e,
        this.update(i, r)
    }
    var t = s.prototype;
    return t.isDifferent = function(i) {
        var r = this.bounds
          , n = i.bounds;
        return r.top !== n.top || r.left !== n.left || r.width !== n.width || r.height !== n.height || !this.matrix.equals(i.matrix) || this.opacity !== i.opacity || this.props && i.props && JSON.stringify(this.props) !== JSON.stringify(i.props)
    }
    ,
    t.update = function(i, r) {
        var n = this
          , o = n.element
          , a = Ze.getProperty(o)
          , l = Ze.core.getCache(o)
          , h = o.getBoundingClientRect()
          , u = o.getBBox && typeof o.getBBox == "function" && o.nodeName.toLowerCase() !== "svg" && o.getBBox()
          , c = r ? new Wn(1,0,0,1,h.left + mm(),h.top + pm()) : es(o, !1, !1, !0);
        n.getProp = a,
        n.element = o,
        n.id = eD(o),
        n.matrix = c,
        n.cache = l,
        n.bounds = h,
        n.isVisible = !!(h.width || h.height || h.left || h.top),
        n.display = a("display"),
        n.position = a("position"),
        n.parent = o.parentNode,
        n.x = a("x"),
        n.y = a("y"),
        n.scaleX = l.scaleX,
        n.scaleY = l.scaleY,
        n.rotation = a("rotation"),
        n.skewX = a("skewX"),
        n.opacity = a("opacity"),
        n.width = u ? u.width : ms(a("width", "px"), .04),
        n.height = u ? u.height : ms(a("height", "px"), .04),
        i && tD(n, ym[i] || bx(i)),
        n.ctm = o.getCTM && o.nodeName.toLowerCase() === "svg" && yx(o).inverse(),
        n.simple = r || So(c.a) === 1 && !So(c.b) && !So(c.c) && So(c.d) === 1,
        n.uncache = 0
    }
    ,
    s
}(), rD = function() {
    function s(e, i) {
        this.vars = e,
        this.batch = i,
        this.states = [],
        this.timeline = i.timeline
    }
    var t = s.prototype;
    return t.getStateById = function(i) {
        for (var r = this.states.length; r--; )
            if (this.states[r].idLookup[i])
                return this.states[r]
    }
    ,
    t.kill = function() {
        this.batch.remove(this)
    }
    ,
    s
}(), sD = function() {
    function s(e) {
        this.id = e,
        this.actions = [],
        this._kill = [],
        this._final = [],
        this._abs = [],
        this._run = [],
        this.data = {},
        this.state = new wr,
        this.timeline = Ze.timeline()
    }
    var t = s.prototype;
    return t.add = function(i) {
        var r = this.actions.filter(function(n) {
            return n.vars === i
        });
        return r.length ? r[0] : (r = new rD(typeof i == "function" ? {
            animate: i
        } : i,this),
        this.actions.push(r),
        r)
    }
    ,
    t.remove = function(i) {
        var r = this.actions.indexOf(i);
        return r >= 0 && this.actions.splice(r, 1),
        this
    }
    ,
    t.getState = function(i) {
        var r = this
          , n = te
          , o = ol;
        return te = this,
        this.state.clear(),
        this._kill.length = 0,
        this.actions.forEach(function(a) {
            a.vars.getState && (a.states.length = 0,
            ol = a,
            a.state = a.vars.getState(a)),
            i && a.states.forEach(function(l) {
                return r.state.add(l)
            })
        }),
        ol = o,
        te = n,
        this.killConflicts(),
        this
    }
    ,
    t.animate = function() {
        var i = this, r = te, n = this.timeline, o = this.actions.length, a, l;
        for (te = this,
        n.clear(),
        this._abs.length = this._final.length = this._run.length = 0,
        this.actions.forEach(function(h) {
            h.vars.animate && h.vars.animate(h);
            var u = h.vars.onEnter, c = h.vars.onLeave, d = h.targets, f, p;
            d && d.length && (u || c) && (f = new wr,
            h.states.forEach(function(m) {
                return f.add(m)
            }),
            p = f.compare(Tc.getState(d)),
            p.enter.length && u && u(p.enter),
            p.leave.length && c && c(p.leave))
        }),
        wx(this._abs),
        this._run.forEach(function(h) {
            return h()
        }),
        l = n.duration(),
        a = this._final.slice(0),
        n.add(function() {
            l <= n.time() && (a.forEach(function(h) {
                return h()
            }),
            b0(i, "onComplete"))
        }),
        te = r; o--; )
            this.actions[o].vars.once && this.actions[o].kill();
        return b0(this, "onStart"),
        n.restart(),
        this
    }
    ,
    t.loadState = function(i) {
        i || (i = function() {
            return 0
        }
        );
        var r = [];
        return this.actions.forEach(function(n) {
            if (n.vars.loadState) {
                var o, a = function l(h) {
                    h && (n.targets = h),
                    o = r.indexOf(l),
                    ~o && (r.splice(o, 1),
                    r.length || i())
                };
                r.push(a),
                n.vars.loadState(a)
            }
        }),
        r.length || i(),
        this
    }
    ,
    t.setState = function() {
        return this.actions.forEach(function(i) {
            return i.targets = i.vars.setState && i.vars.setState(i)
        }),
        this
    }
    ,
    t.killConflicts = function(i) {
        return this.state.interrupt(i),
        this._kill.forEach(function(r) {
            return r.interrupt(i)
        }),
        this
    }
    ,
    t.run = function(i, r) {
        var n = this;
        return this !== te && (i || this.getState(r),
        this.loadState(function() {
            n._killed || (n.setState(),
            n.animate())
        })),
        this
    }
    ,
    t.clear = function(i) {
        this.state.clear(),
        i || (this.actions.length = 0)
    }
    ,
    t.getStateById = function(i) {
        for (var r = this.actions.length, n; r--; )
            if (n = this.actions[r].getStateById(i),
            n)
                return n;
        return this.state.idLookup[i] && this.state
    }
    ,
    t.kill = function() {
        this._killed = 1,
        this.clear(),
        delete Ff[this.id]
    }
    ,
    s
}(), Tc = function() {
    function s() {}
    return s.getState = function(e, i) {
        var r = ad(e, i);
        return ol && ol.states.push(r),
        i && i.batch && s.batch(i.batch).state.add(r),
        r
    }
    ,
    s.from = function(e, i) {
        return i = i || {},
        "clearProps"in i || (i.clearProps = !0),
        ud(e, ad(i.targets || e.targets, {
            props: i.props || e.props,
            simple: i.simple,
            kill: !!i.kill
        }), i, -1)
    }
    ,
    s.to = function(e, i) {
        return ud(e, ad(i.targets || e.targets, {
            props: i.props || e.props,
            simple: i.simple,
            kill: !!i.kill
        }), i, 1)
    }
    ,
    s.fromTo = function(e, i, r) {
        return ud(e, i, r)
    }
    ,
    s.fit = function(e, i, r) {
        var n = r ? Co(r, vx) : {}
          , o = r || n
          , a = o.absolute
          , l = o.scale
          , h = o.getVars
          , u = o.props
          , c = o.runBackwards
          , d = o.onComplete
          , f = o.simple
          , p = r && r.fitChild && al(r.fitChild)
          , m = Bf(i, u, f, e)
          , g = Bf(e, 0, f, m)
          , _ = u ? wc[u] : Ec
          , x = Ze.context();
        return u && Ex(n, m.props),
        Sl(g, _),
        c && ("immediateRender"in n || (n.immediateRender = !0),
        n.onComplete = function() {
            Lu(g),
            d && d.apply(this, arguments)
        }
        ),
        a && vm(g, m),
        n = Lo(g, m, l || p, u, p, n.duration || h ? n : 0),
        x && !h && x.add(function() {
            return function() {
                return Lu(g)
            }
        }),
        h ? n : n.duration ? Ze.to(g.element, n) : null
    }
    ,
    s.makeAbsolute = function(e, i) {
        return (e instanceof wr ? e : new wr(e,i)).makeAbsolute()
    }
    ,
    s.batch = function(e) {
        return e || (e = "default"),
        Ff[e] || (Ff[e] = new sD(e))
    }
    ,
    s.killFlipsOf = function(e, i) {
        (e instanceof wr ? e.targets : Qo(e)).forEach(function(r) {
            return r && xm(r._flip, i !== !1 ? 1 : 2)
        })
    }
    ,
    s.isFlipping = function(e) {
        var i = s.getByTarget(e);
        return !!i && i.isActive()
    }
    ,
    s.getByTarget = function(e) {
        return (al(e) || Ou)._flip
    }
    ,
    s.getElementState = function(e, i) {
        return new jn(al(e),i)
    }
    ,
    s.convertCoordinates = function(e, i, r) {
        var n = es(i, !0, !0).multiply(es(e));
        return r ? n.apply(r) : n
    }
    ,
    s.register = function(e) {
        if (Bs = typeof document < "u" && document.body,
        Bs) {
            Ze = e,
            fm(Bs),
            Qo = Ze.utils.toArray,
            Mf = Ze.core.getStyleSaver;
            var i = Ze.utils.snap(.1);
            ms = function(n, o) {
                return i(parseFloat(n) + o)
            }
        }
    }
    ,
    s
}();
Tc.version = "3.12.3";
typeof window < "u" && window.gsap && window.gsap.registerPlugin(Tc);
N.registerPlugin(mt, Qs, Tl, Tc, cm, Sf);
const Je = {
    mask: Sf.create("custom", "M0,0 C0.77,0 0.18,1 1,1"),
    default: Sf.create("custom", "M0,0 C0.14,0.95 0.43,1.01 1,1 ")
};
N.defaults({
    ease: Je.default
});
const zi = "(min-width: 768px)"
  , Of = "(max-width: 767px)";
function nD(s) {
    const t = N.utils.toArray(s);
    t && t.forEach(e=>{
        let i = N.matchMedia()
          , r = !1;
        e.classList.contains("reveal-bottom") && (r = !0);
        const n = N.timeline({
            paused: !0
        });
        n.to(e.querySelectorAll(".reveal-ani"), {
            y: 0,
            ease: Je.default,
            stagger: .1,
            duration: .8
        }, 0).to(e.querySelectorAll(".full-blur .inline-block"), {
            opacity: 0,
            duration: 2,
            ease: Je.default,
            stagger: {
                amount: .6,
                from: "random",
                ease: Je.default
            }
        }, 0).to(e.querySelectorAll(".mid-blur .text-blur"), {
            opacity: 1,
            ease: Je.default,
            duration: 2,
            stagger: .1
        }, 0),
        i.add(zi, ()=>{
            mt.create({
                trigger: e,
                start: r ? "top 95%" : "top 90%",
                onEnter: ()=>n.play()
            })
        }
        ),
        i.add(Of, ()=>{
            mt.create({
                trigger: e,
                start: r ? "top 95%" : "top 90%",
                onEnter: ()=>n.play()
            })
        }
        ),
        mt.create({
            trigger: e,
            onLeaveBack: ()=>n.pause(0)
        })
    }
    )
}
function oD(s) {
    const t = N.utils.toArray(s);
    t && t.forEach(e=>{
        let i = !1;
        e.classList.contains("reveal-stagger") && (i = !0);
        const r = N.timeline({
            paused: !0
        });
        r.fromTo(e.querySelector(".reveal-ani"), {
            yPercent: 110
        }, {
            yPercent: 0,
            ease: Je.default,
            duration: .6
        }, i ? .3 : 0),
        mt.create({
            trigger: e,
            start: "top 90%",
            onEnter: ()=>r.play()
        }),
        mt.create({
            trigger: e,
            onLeaveBack: ()=>r.pause(0)
        })
    }
    )
}
function aD(s) {
    const t = N.utils.toArray(s);
    function e(i, r) {
        let n = window.innerWidth
          , o = N.delayedCall(r || .2, i).pause()
          , a = ()=>{
            window.innerWidth !== n && (n = window.innerWidth,
            o.restart(!0))
        }
        ;
        return window.addEventListener("resize", a),
        a
    }
    t && t.forEach(i=>{
        let r, n;
        function o() {
            r && r.revert(),
            r = new Tl(i.querySelector("p"),{
                type: "lines",
                linesClass: "line-child whitespace-nowrap",
                lineThreshold: .9
            }),
            new Tl(i.querySelector("p"),{
                type: "lines",
                linesClass: "overflow-hidden line-parent",
                lineThreshold: .9
            }),
            n = N.timeline({
                paused: !0
            }),
            n.fromTo(r.lines, {
                yPercent: 110
            }, {
                yPercent: 0,
                ease: Je.default,
                stagger: .05,
                duration: .4
            }, .1)
        }
        o(),
        mt.create({
            trigger: i,
            start: "top 90%",
            onEnter: ()=>{
                o(),
                n.play(0)
            }
        }),
        mt.create({
            trigger: i,
            onLeaveBack: ()=>n.pause(0)
        });
        function a() {
            o(),
            n.play(0)
        }
        e(a)
    }
    )
}
function lD(s) {
    const t = N.utils.toArray(s);
    t && t.forEach(e=>{
        const i = N.timeline({
            paused: !0
        });
        i.fromTo(e.querySelectorAll(".reveal-ani"), {
            yPercent: 110
        }, {
            yPercent: 0,
            ease: Je.default,
            stagger: .05,
            duration: .4
        }, .2),
        mt.create({
            trigger: e,
            start: "top 90%",
            onEnter: ()=>i.play()
        }),
        mt.create({
            trigger: e,
            onLeaveBack: ()=>i.pause(0)
        })
    }
    )
}
function hD(s) {
    const t = N.utils.toArray(s);
    t && t.forEach(e=>{
        const i = N.timeline({
            paused: !0
        });
        i.fromTo(e, {
            "--width-percent": 0,
            "--width-pixel": 0
        }, {
            "--width-percent": 100,
            "--width-pixel": 20,
            ease: Je.default,
            duration: 1
        }),
        mt.create({
            trigger: e,
            start: "top 90%",
            onEnter: ()=>{
                i.play()
            }
        }),
        mt.create({
            trigger: e,
            onLeaveBack: ()=>i.pause(0)
        })
    }
    )
}
function uD(s) {
    const t = N.utils.toArray(s);
    t && t.forEach(e=>{
        N.matchMedia().add(zi, ()=>{
            const r = N.timeline({
                paused: !0,
                defaults: {
                    duration: .8,
                    modifiers: {
                        xPercent: function(o) {
                            return Math.round(o / .2) * .2
                        }
                    }
                }
            })
              , n = .4;
            r.fromTo(e.querySelector(".reveal-footer1"), {
                xPercent: 35
            }, {
                xPercent: 0
            }, n).fromTo(e.querySelector(".reveal-footer2"), {
                xPercent: -54
            }, {
                xPercent: 0
            }, n).fromTo(e.querySelector(".reveal-footer3"), {
                xPercent: 6
            }, {
                xPercent: 0
            }, n).fromTo(e.querySelector(".reveal-footer4"), {
                xPercent: -33
            }, {
                xPercent: 0
            }, n),
            mt.create({
                trigger: e,
                start: "top 95%",
                onEnter: ()=>r.play()
            }),
            mt.create({
                trigger: e,
                onLeaveBack: ()=>r.pause(0)
            })
        }
        )
    }
    )
}
var Po = function() {
    return Po = Object.assign || function(s) {
        for (var t, e = 1, i = arguments.length; e < i; e++)
            for (var r in t = arguments[e])
                Object.prototype.hasOwnProperty.call(t, r) && (s[r] = t[r]);
        return s
    }
    ,
    Po.apply(this, arguments)
};
function Ax(s, t, e) {
    if (e || arguments.length === 2)
        for (var i, r = 0, n = t.length; r < n; r++)
            !i && r in t || (i || (i = Array.prototype.slice.call(t, 0, r)),
            i[r] = t[r]);
    return s.concat(i || Array.prototype.slice.call(t))
}
function P0(s) {
    return Array.prototype.slice.call(s)
}
function I0(s, t) {
    var e = Math.floor(s);
    return e === t || e + 1 === t ? s : t
}
function R0() {
    return Date.now()
}
function cd(s, t, e) {
    if (t = "data-keen-slider-" + t,
    e === null)
        return s.removeAttribute(t);
    s.setAttribute(t, e || "")
}
function Nu(s, t) {
    return t = t || document,
    typeof s == "function" && (s = s(t)),
    Array.isArray(s) ? s : typeof s == "string" ? P0(t.querySelectorAll(s)) : s instanceof HTMLElement ? [s] : s instanceof NodeList ? P0(s) : []
}
function _a(s) {
    s.raw && (s = s.raw),
    s.cancelable && !s.defaultPrevented && s.preventDefault()
}
function ya(s) {
    s.raw && (s = s.raw),
    s.stopPropagation && s.stopPropagation()
}
function Sx() {
    var s = [];
    return {
        add: function(t, e, i, r) {
            t.addListener ? t.addListener(i) : t.addEventListener(e, i, r),
            s.push([t, e, i, r])
        },
        input: function(t, e, i, r) {
            this.add(t, e, function(n) {
                return function(o) {
                    o.nativeEvent && (o = o.nativeEvent);
                    var a = o.changedTouches || []
                      , l = o.targetTouches || []
                      , h = o.detail && o.detail.x ? o.detail : null;
                    return n({
                        id: h ? h.identifier ? h.identifier : "i" : l[0] ? l[0] ? l[0].identifier : "e" : "d",
                        idChanged: h ? h.identifier ? h.identifier : "i" : a[0] ? a[0] ? a[0].identifier : "e" : "d",
                        raw: o,
                        x: h && h.x ? h.x : l[0] ? l[0].screenX : h ? h.x : o.pageX,
                        y: h && h.y ? h.y : l[0] ? l[0].screenY : h ? h.y : o.pageY
                    })
                }
            }(i), r)
        },
        purge: function() {
            s.forEach(function(t) {
                t[0].removeListener ? t[0].removeListener(t[2]) : t[0].removeEventListener(t[1], t[2], t[3])
            }),
            s = []
        }
    }
}
function bm(s, t, e) {
    return Math.min(Math.max(s, t), e)
}
function _r(s) {
    return (s > 0 ? 1 : 0) - (s < 0 ? 1 : 0) || +s
}
function M0(s) {
    var t = s.getBoundingClientRect();
    return {
        height: I0(t.height, s.offsetHeight),
        width: I0(t.width, s.offsetWidth)
    }
}
function di(s, t, e, i) {
    var r = s && s[t];
    return r == null ? e : i && typeof r == "function" ? r() : r
}
function ji(s) {
    return Math.round(1e6 * s) / 1e6
}
function cD(s) {
    var t, e, i, r, n, o;
    function a(d) {
        o || (o = d),
        l(!0);
        var f = d - o;
        f > i && (f = i);
        var p = r[e];
        if (p[3] < f)
            return e++,
            a(d);
        var m = p[2]
          , g = p[4]
          , _ = p[0]
          , x = p[1] * (0,
        p[5])(g === 0 ? 1 : (f - m) / g);
        if (x && s.track.to(_ + x),
        f < i)
            return u();
        o = null,
        l(!1),
        h(null),
        s.emit("animationEnded")
    }
    function l(d) {
        t.active = d
    }
    function h(d) {
        t.targetIdx = d
    }
    function u() {
        var d;
        d = a,
        n = window.requestAnimationFrame(d)
    }
    function c() {
        var d;
        d = n,
        window.cancelAnimationFrame(d),
        l(!1),
        h(null),
        o && s.emit("animationStopped"),
        o = null
    }
    return t = {
        active: !1,
        start: function(d) {
            if (c(),
            s.track.details) {
                var f = 0
                  , p = s.track.details.position;
                e = 0,
                i = 0,
                r = d.map(function(m) {
                    var g, _ = Number(p), x = (g = m.earlyExit) !== null && g !== void 0 ? g : m.duration, y = m.easing, v = m.distance * y(x / m.duration) || 0;
                    p += v;
                    var E = i;
                    return i += x,
                    f += v,
                    [_, m.distance, E, i, m.duration, y]
                }),
                h(s.track.distToIdx(f)),
                u(),
                s.emit("animationStarted")
            }
        },
        stop: c,
        targetIdx: null
    }
}
function dD(s) {
    var t, e, i, r, n, o, a, l, h, u, c, d, f, p, m = 1 / 0, g = [], _ = null, x = 0;
    function y(T) {
        B(x + T)
    }
    function v(T) {
        var M = E(x + T).abs;
        return A(M) ? M : null
    }
    function E(T) {
        var M = Math.floor(Math.abs(ji(T / e)))
          , D = ji((T % e + e) % e);
        D === e && (D = 0);
        var C = _r(T)
          , k = a.indexOf(Ax([], a, !0).reduce(function(b, L) {
            return Math.abs(L - D) < Math.abs(b - D) ? L : b
        }))
          , R = k;
        return C < 0 && M++,
        k === o && (R = 0,
        M += C > 0 ? 1 : -1),
        {
            abs: R + M * o * C,
            origin: k,
            rel: R
        }
    }
    function P(T, M, D) {
        var C;
        if (M || !F())
            return w(T, D);
        if (!A(T))
            return null;
        var k = E(D ?? x)
          , R = k.abs
          , b = T - k.rel
          , L = R + b;
        C = w(L);
        var U = w(L - o * _r(b));
        return (U !== null && Math.abs(U) < Math.abs(C) || C === null) && (C = U),
        ji(C)
    }
    function w(T, M) {
        if (M == null && (M = ji(x)),
        !A(T) || T === null)
            return null;
        T = Math.round(T);
        var D = E(M)
          , C = D.abs
          , k = D.rel
          , R = D.origin
          , b = O(T)
          , L = (M % e + e) % e
          , U = a[R]
          , Y = Math.floor((T - (C - k)) / o) * e;
        return ji(U - L - U + a[b] + Y + (R === o ? e : 0))
    }
    function A(T) {
        return I(T) === T
    }
    function I(T) {
        return bm(T, h, u)
    }
    function F() {
        return r.loop
    }
    function O(T) {
        return (T % o + o) % o
    }
    function B(T) {
        var M;
        M = T - x,
        g.push({
            distance: M,
            timestamp: R0()
        }),
        g.length > 6 && (g = g.slice(-6)),
        x = ji(T);
        var D = S().abs;
        if (D !== _) {
            var C = _ !== null;
            _ = D,
            C && s.emit("slideChanged")
        }
    }
    function S(T) {
        var M = T ? null : function() {
            if (o) {
                var D = F()
                  , C = D ? (x % e + e) % e : x
                  , k = (D ? x % e : x) - n[0][2]
                  , R = 0 - (k < 0 && D ? e - Math.abs(k) : k)
                  , b = 0
                  , L = E(x)
                  , U = L.abs
                  , Y = L.rel
                  , $ = n[Y][2]
                  , z = n.map(function(j, W) {
                    var X = R + b;
                    (X < 0 - j[0] || X > 1) && (X += (Math.abs(X) > e - 1 && D ? e : 0) * _r(-X));
                    var et = W - Y
                      , Q = _r(et)
                      , q = et + U;
                    D && (Q === -1 && X > $ && (q += o),
                    Q === 1 && X < $ && (q -= o),
                    c !== null && q < c && (X += e),
                    d !== null && q > d && (X -= e));
                    var tt = X + j[0] + j[1]
                      , Z = Math.max(X >= 0 && tt <= 1 ? 1 : tt < 0 || X > 1 ? 0 : X < 0 ? Math.min(1, (j[0] + X) / j[0]) : (1 - X) / j[0], 0);
                    return b += j[0] + j[1],
                    {
                        abs: q,
                        distance: r.rtl ? -1 * X + 1 - j[0] : X,
                        portion: Z,
                        size: j[0]
                    }
                });
                return U = I(U),
                Y = O(U),
                {
                    abs: I(U),
                    length: i,
                    max: p,
                    maxIdx: u,
                    min: f,
                    minIdx: h,
                    position: x,
                    progress: D ? C / e : x / i,
                    rel: Y,
                    slides: z,
                    slidesLength: e
                }
            }
        }();
        return t.details = M,
        s.emit("detailsChanged"),
        M
    }
    return t = {
        absToRel: O,
        add: y,
        details: null,
        distToIdx: v,
        idxToDist: P,
        init: function(T) {
            if (function() {
                if (r = s.options,
                n = (r.trackConfig || []).map(function(k) {
                    return [di(k, "size", 1), di(k, "spacing", 0), di(k, "origin", 0)]
                }),
                o = n.length) {
                    e = ji(n.reduce(function(k, R) {
                        return k + R[0] + R[1]
                    }, 0));
                    var D, C = o - 1;
                    i = ji(e + n[0][2] - n[C][0] - n[C][2] - n[C][1]),
                    a = n.reduce(function(k, R) {
                        if (!k)
                            return [0];
                        var b = n[k.length - 1]
                          , L = k[k.length - 1] + (b[0] + b[2]) + b[1];
                        return L -= R[2],
                        k[k.length - 1] > L && (L = k[k.length - 1]),
                        L = ji(L),
                        k.push(L),
                        (!D || D < L) && (l = k.length - 1),
                        D = L,
                        k
                    }, null),
                    i === 0 && (l = 0),
                    a.push(ji(e))
                }
            }(),
            !o)
                return S(!0);
            var M;
            (function() {
                var D = s.options.range
                  , C = s.options.loop;
                c = h = C ? di(C, "min", -1 / 0) : 0,
                d = u = C ? di(C, "max", m) : l;
                var k = di(D, "min", null)
                  , R = di(D, "max", null);
                k !== null && (h = k),
                R !== null && (u = R),
                f = h === -1 / 0 ? h : s.track.idxToDist(h || 0, !0, 0),
                p = u === m ? u : P(u, !0, 0),
                R === null && (d = u),
                di(D, "align", !1) && u !== m && n[O(u)][2] === 0 && (p -= 1 - n[O(u)][0],
                u = v(p - x)),
                f = ji(f),
                p = ji(p)
            }
            )(),
            M = T,
            Number(M) === M ? y(w(I(T))) : S()
        },
        to: B,
        velocity: function() {
            var T = R0()
              , M = g.reduce(function(D, C) {
                var k = C.distance
                  , R = C.timestamp;
                return T - R > 200 || (_r(k) !== _r(D.distance) && D.distance && (D = {
                    distance: 0,
                    lastTimestamp: 0,
                    time: 0
                }),
                D.time && (D.distance += k),
                D.lastTimestamp && (D.time += R - D.lastTimestamp),
                D.lastTimestamp = R),
                D
            }, {
                distance: 0,
                lastTimestamp: 0,
                time: 0
            });
            return M.distance / M.time || 0
        }
    }
}
function fD(s) {
    var t, e, i, r, n, o, a, l;
    function h(_) {
        return 2 * _
    }
    function u(_) {
        return bm(_, a, l)
    }
    function c(_) {
        return 1 - Math.pow(1 - _, 3)
    }
    function d() {
        return i ? s.track.velocity() : 0
    }
    function f() {
        g();
        var _ = s.options.mode === "free-snap"
          , x = s.track
          , y = d();
        r = _r(y);
        var v = s.track.details
          , E = [];
        if (y || !_) {
            var P = p(y)
              , w = P.dist
              , A = P.dur;
            if (A = h(A),
            w *= r,
            _) {
                var I = x.idxToDist(x.distToIdx(w), !0);
                I && (w = I)
            }
            E.push({
                distance: w,
                duration: A,
                easing: c
            });
            var F = v.position
              , O = F + w;
            if (O < n || O > o) {
                var B = O < n ? n - F : o - F
                  , S = 0
                  , T = y;
                if (_r(B) === r) {
                    var M = Math.min(Math.abs(B) / Math.abs(w), 1)
                      , D = function(R) {
                        return 1 - Math.pow(1 - R, 1 / 3)
                    }(M) * A;
                    E[0].earlyExit = D,
                    T = y * (1 - M)
                } else
                    E[0].earlyExit = 0,
                    S += B;
                var C = p(T, 100)
                  , k = C.dist * r;
                s.options.rubberband && (E.push({
                    distance: k,
                    duration: h(C.dur),
                    easing: c
                }),
                E.push({
                    distance: -k + S,
                    duration: 500,
                    easing: c
                }))
            }
            s.animator.start(E)
        } else
            s.moveToIdx(u(v.abs), !0, {
                duration: 500,
                easing: function(R) {
                    return 1 + --R * R * R * R * R
                }
            })
    }
    function p(_, x) {
        x === void 0 && (x = 1e3);
        var y = 147e-9 + (_ = Math.abs(_)) / x;
        return {
            dist: Math.pow(_, 2) / y,
            dur: _ / y
        }
    }
    function m() {
        var _ = s.track.details;
        _ && (n = _.min,
        o = _.max,
        a = _.minIdx,
        l = _.maxIdx)
    }
    function g() {
        s.animator.stop()
    }
    s.on("updated", m),
    s.on("optionsChanged", m),
    s.on("created", m),
    s.on("dragStarted", function() {
        i = !1,
        g(),
        t = e = s.track.details.abs
    }),
    s.on("dragChecked", function() {
        i = !0
    }),
    s.on("dragEnded", function() {
        var _ = s.options.mode;
        _ === "snap" && function() {
            var x = s.track
              , y = s.track.details
              , v = y.position
              , E = _r(d());
            (v > o || v < n) && (E = 0);
            var P = t + E;
            y.slides[x.absToRel(P)].portion === 0 && (P -= E),
            t !== e && (P = e),
            _r(x.idxToDist(P, !0)) !== E && (P += E),
            P = u(P);
            var w = x.idxToDist(P, !0);
            s.animator.start([{
                distance: w,
                duration: 500,
                easing: function(A) {
                    return 1 + --A * A * A * A * A
                }
            }])
        }(),
        _ !== "free" && _ !== "free-snap" || f()
    }),
    s.on("dragged", function() {
        e = s.track.details.abs
    })
}
function pD(s) {
    var t, e, i, r, n, o, a, l, h, u, c, d, f, p, m, g, _, x, y = Sx();
    function v(S) {
        if (o && l === S.id) {
            var T = A(S);
            if (h) {
                if (!w(S))
                    return P(S);
                u = T,
                h = !1,
                s.emit("dragChecked")
            }
            if (g)
                return u = T;
            _a(S);
            var M = function(C) {
                if (_ === -1 / 0 && x === 1 / 0)
                    return C;
                var k = s.track.details
                  , R = k.length
                  , b = k.position
                  , L = bm(C, _ - b, x - b);
                if (R === 0)
                    return 0;
                if (!s.options.rubberband)
                    return L;
                if (b <= x && b >= _ || b < _ && e > 0 || b > x && e < 0)
                    return C;
                var U = (b < _ ? b - _ : b - x) / R
                  , Y = r * R
                  , $ = Math.abs(U * Y)
                  , z = Math.max(0, 1 - $ / n * 2);
                return z * z * C
            }(a(u - T) / r * i);
            e = _r(M);
            var D = s.track.details.position;
            (D > _ && D < x || D === _ && e > 0 || D === x && e < 0) && ya(S),
            c += M,
            !d && Math.abs(c * r) > 5 && (d = !0),
            s.track.add(M),
            u = T,
            s.emit("dragged")
        }
    }
    function E(S) {
        !o && s.track.details && s.track.details.length && (c = 0,
        o = !0,
        d = !1,
        h = !0,
        l = S.id,
        w(S),
        u = A(S),
        s.emit("dragStarted"))
    }
    function P(S) {
        o && l === S.idChanged && (o = !1,
        s.emit("dragEnded"))
    }
    function w(S) {
        var T = I()
          , M = T ? S.y : S.x
          , D = T ? S.x : S.y
          , C = f !== void 0 && p !== void 0 && Math.abs(p - D) <= Math.abs(f - M);
        return f = M,
        p = D,
        C
    }
    function A(S) {
        return I() ? S.y : S.x
    }
    function I() {
        return s.options.vertical
    }
    function F() {
        r = s.size,
        n = I() ? window.innerHeight : window.innerWidth;
        var S = s.track.details;
        S && (_ = S.min,
        x = S.max)
    }
    function O(S) {
        d && (ya(S),
        _a(S))
    }
    function B() {
        if (y.purge(),
        s.options.drag && !s.options.disabled) {
            var S;
            S = s.options.dragSpeed || 1,
            a = typeof S == "function" ? S : function(M) {
                return M * S
            }
            ,
            i = s.options.rtl ? -1 : 1,
            F(),
            t = s.container,
            function() {
                var M = "data-keen-slider-clickable";
                Nu("[".concat(M, "]:not([").concat(M, "=false])"), t).map(function(D) {
                    y.add(D, "dragstart", ya),
                    y.add(D, "mousedown", ya),
                    y.add(D, "touchstart", ya)
                })
            }(),
            y.add(t, "dragstart", function(M) {
                _a(M)
            }),
            y.add(t, "click", O, {
                capture: !0
            }),
            y.input(t, "ksDragStart", E),
            y.input(t, "ksDrag", v),
            y.input(t, "ksDragEnd", P),
            y.input(t, "mousedown", E),
            y.input(t, "mousemove", v),
            y.input(t, "mouseleave", P),
            y.input(t, "mouseup", P),
            y.input(t, "touchstart", E, {
                passive: !0
            }),
            y.input(t, "touchmove", v, {
                passive: !1
            }),
            y.input(t, "touchend", P),
            y.input(t, "touchcancel", P),
            y.add(window, "wheel", function(M) {
                o && _a(M)
            });
            var T = "data-keen-slider-scrollable";
            Nu("[".concat(T, "]:not([").concat(T, "=false])"), s.container).map(function(M) {
                return function(D) {
                    var C;
                    y.input(D, "touchstart", function(k) {
                        C = A(k),
                        g = !0,
                        m = !0
                    }, {
                        passive: !0
                    }),
                    y.input(D, "touchmove", function(k) {
                        var R = I()
                          , b = R ? D.scrollHeight - D.clientHeight : D.scrollWidth - D.clientWidth
                          , L = C - A(k)
                          , U = R ? D.scrollTop : D.scrollLeft
                          , Y = R && D.style.overflowY === "scroll" || !R && D.style.overflowX === "scroll";
                        if (C = A(k),
                        (L < 0 && U > 0 || L > 0 && U < b) && m && Y)
                            return g = !0;
                        m = !1,
                        _a(k),
                        g = !1
                    }),
                    y.input(D, "touchend", function() {
                        g = !1
                    })
                }(M)
            })
        }
    }
    s.on("updated", F),
    s.on("optionsChanged", B),
    s.on("created", B),
    s.on("destroyed", y.purge)
}
function mD(s) {
    var t, e, i = null;
    function r(f, p, m) {
        s.animator.active ? o(f, p, m) : requestAnimationFrame(function() {
            return o(f, p, m)
        })
    }
    function n() {
        r(!1, !1, e)
    }
    function o(f, p, m) {
        var g = 0
          , _ = s.size
          , x = s.track.details;
        if (x && t) {
            var y = x.slides;
            t.forEach(function(v, E) {
                if (f)
                    !i && p && l(v, null, m),
                    h(v, null, m);
                else {
                    if (!y[E])
                        return;
                    var P = y[E].size * _;
                    !i && p && l(v, P, m),
                    h(v, y[E].distance * _ - g, m),
                    g += P
                }
            })
        }
    }
    function a(f) {
        return s.options.renderMode === "performance" ? Math.round(f) : f
    }
    function l(f, p, m) {
        var g = m ? "height" : "width";
        p !== null && (p = a(p) + "px"),
        f.style["min-" + g] = p,
        f.style["max-" + g] = p
    }
    function h(f, p, m) {
        if (p !== null) {
            p = a(p);
            var g = m ? p : 0;
            p = "translate3d(".concat(m ? 0 : p, "px, ").concat(g, "px, 0)")
        }
        f.style.transform = p,
        f.style["-webkit-transform"] = p
    }
    function u() {
        t && (o(!0, !0, e),
        t = null),
        s.on("detailsChanged", n, !0)
    }
    function c() {
        r(!1, !0, e)
    }
    function d() {
        u(),
        e = s.options.vertical,
        s.options.disabled || s.options.renderMode === "custom" || (i = di(s.options.slides, "perView", null) === "auto",
        s.on("detailsChanged", n),
        (t = s.slides).length && c())
    }
    s.on("created", d),
    s.on("optionsChanged", d),
    s.on("beforeOptionsChanged", function() {
        u()
    }),
    s.on("updated", c),
    s.on("destroyed", u)
}
function gD(s, t) {
    return function(e) {
        var i, r, n, o, a, l = Sx();
        function h(w) {
            var A;
            cd(e.container, "reverse", (A = e.container,
            window.getComputedStyle(A, null).getPropertyValue("direction") !== "rtl" || w ? null : "")),
            cd(e.container, "v", e.options.vertical && !w ? "" : null),
            cd(e.container, "disabled", e.options.disabled && !w ? "" : null)
        }
        function u() {
            c() && g()
        }
        function c() {
            var w = null;
            if (o.forEach(function(I) {
                I.matches && (w = I.__media)
            }),
            w === i)
                return !1;
            i || e.emit("beforeOptionsChanged"),
            i = w;
            var A = w ? n.breakpoints[w] : n;
            return e.options = Po(Po({}, n), A),
            h(),
            E(),
            P(),
            x(),
            !0
        }
        function d(w) {
            var A = M0(w);
            return (e.options.vertical ? A.height : A.width) / e.size || 1
        }
        function f() {
            return e.options.trackConfig.length
        }
        function p(w) {
            for (var A in i = !1,
            n = Po(Po({}, t), w),
            l.purge(),
            r = e.size,
            o = [],
            n.breakpoints || []) {
                var I = window.matchMedia(A);
                I.__media = A,
                o.push(I),
                l.add(I, "change", u)
            }
            l.add(window, "orientationchange", v),
            l.add(window, "resize", y),
            c()
        }
        function m(w) {
            e.animator.stop();
            var A = e.track.details;
            e.track.init(w ?? (A ? A.abs : 0))
        }
        function g(w) {
            m(w),
            e.emit("optionsChanged")
        }
        function _(w, A) {
            if (w)
                return p(w),
                void g(A);
            E(),
            P();
            var I = f();
            x(),
            f() !== I ? g(A) : m(A),
            e.emit("updated")
        }
        function x() {
            var w = e.options.slides;
            if (typeof w == "function")
                return e.options.trackConfig = w(e.size, e.slides);
            for (var A = e.slides, I = A.length, F = typeof w == "number" ? w : di(w, "number", I, !0), O = [], B = di(w, "perView", 1, !0), S = di(w, "spacing", 0, !0) / e.size || 0, T = B === "auto" ? S : S / B, M = di(w, "origin", "auto"), D = 0, C = 0; C < F; C++) {
                var k = B === "auto" ? d(A[C]) : 1 / B - S + T
                  , R = M === "center" ? .5 - k / 2 : M === "auto" ? 0 : M;
                O.push({
                    origin: R,
                    size: k,
                    spacing: S
                }),
                D += k
            }
            if (D += S * (F - 1),
            M === "auto" && !e.options.loop && B !== 1) {
                var b = 0;
                O.map(function(L) {
                    var U = D - b;
                    return b += L.size + S,
                    U >= 1 || (L.origin = 1 - U - (D > 1 ? 0 : 1 - D)),
                    L
                })
            }
            e.options.trackConfig = O
        }
        function y() {
            E();
            var w = e.size;
            e.options.disabled || w === r || (r = w,
            _())
        }
        function v() {
            y(),
            setTimeout(y, 500),
            setTimeout(y, 2e3)
        }
        function E() {
            var w = M0(e.container);
            e.size = (e.options.vertical ? w.height : w.width) || 1
        }
        function P() {
            e.slides = Nu(e.options.selector, e.container)
        }
        e.container = (a = Nu(s, document)).length ? a[0] : null,
        e.destroy = function() {
            l.purge(),
            e.emit("destroyed"),
            h(!0)
        }
        ,
        e.prev = function() {
            e.moveToIdx(e.track.details.abs - 1, !0)
        }
        ,
        e.next = function() {
            e.moveToIdx(e.track.details.abs + 1, !0)
        }
        ,
        e.update = _,
        p(e.options)
    }
}
var kf = function(s, t, e) {
    try {
        return function(i, r) {
            var n, o = {};
            return n = {
                emit: function(a) {
                    o[a] && o[a].forEach(function(h) {
                        h(n)
                    });
                    var l = n.options && n.options[a];
                    l && l(n)
                },
                moveToIdx: function(a, l, h) {
                    var u = n.track.idxToDist(a, l);
                    if (u) {
                        var c = n.options.defaultAnimation;
                        n.animator.start([{
                            distance: u,
                            duration: di(h || c, "duration", 500),
                            easing: di(h || c, "easing", function(d) {
                                return 1 + --d * d * d * d * d
                            })
                        }])
                    }
                },
                on: function(a, l, h) {
                    h === void 0 && (h = !1),
                    o[a] || (o[a] = []);
                    var u = o[a].indexOf(l);
                    u > -1 ? h && delete o[a][u] : h || o[a].push(l)
                },
                options: i
            },
            function() {
                if (n.track = dD(n),
                n.animator = cD(n),
                r)
                    for (var a = 0, l = r; a < l.length; a++)
                        (0,
                        l[a])(n);
                n.track.init(n.options.initial || 0),
                n.emit("created")
            }(),
            n
        }(t, Ax([gD(s, {
            drag: !0,
            mode: "snap",
            renderMode: "precision",
            rubberband: !0,
            selector: ".keen-slider__slide"
        }), mD, pD, fD], e || [], !0))
    } catch (i) {
        console.error(i)
    }
}
  , dd = {
    duration: 2e5,
    easing: s=>s
};
function _D(s, t) {
    let e = !1;
    t === "reviews" && (e = !0);
    function i(n) {
        new kf(n.querySelector(".keen-slider"),{
            loop: !0,
            mode: "free",
            renderMode: "precision",
            slides: {
                perView: "auto",
                spacing: 64
            },
            breakpoints: {
                "(max-width: 767px)": {
                    slides: {
                        perView: e ? 1.2 : 1.25,
                        spacing: 16
                    }
                }
            },
            created(o) {
                o.moveToIdx(5, !0, dd)
            },
            updated(o) {
                o.moveToIdx(o.track.details.abs + 5, !0, dd)
            },
            animationEnded(o) {
                o.moveToIdx(o.track.details.abs + 5, !0, dd)
            }
        })
    }
    const r = document.querySelectorAll(s);
    r && r.forEach((n,o)=>{
        i(n)
    }
    )
}
let wm = !1;
if (typeof window < "u") {
    const s = {
        get passive() {
            wm = !0
        }
    };
    window.addEventListener("testPassive", null, s),
    window.removeEventListener("testPassive", null, s)
}
const Uu = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
let No = [], co = new Map, Gu = !1, Em = -1, ll, Oa, Ur, hl;
const Cx = s=>No.some(t=>!!(t.options.allowTouchMove && t.options.allowTouchMove(s)))
  , Hu = s=>{
    const t = s || window.event;
    return Cx(t.target) || t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(),
    !1)
}
  , yD = s=>{
    if (hl === void 0) {
        const t = !!s && s.reserveScrollBarGap === !0
          , e = window.innerWidth - document.documentElement.getBoundingClientRect().width;
        if (t && e > 0) {
            const i = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
            hl = document.body.style.paddingRight,
            document.body.style.paddingRight = `${i + e}px`
        }
    }
    ll === void 0 && (ll = document.body.style.overflow,
    document.body.style.overflow = "hidden")
}
  , vD = ()=>{
    hl !== void 0 && (document.body.style.paddingRight = hl,
    hl = void 0),
    ll !== void 0 && (document.body.style.overflow = ll,
    ll = void 0)
}
  , xD = ()=>window.requestAnimationFrame(()=>{
    const s = document.documentElement
      , t = document.body;
    if (Ur === void 0) {
        Oa = {
            ...s.style
        },
        Ur = {
            ...t.style
        };
        const {scrollY: e, scrollX: i, innerHeight: r} = window;
        s.style.height = "100%",
        s.style.overflow = "hidden",
        t.style.position = "fixed",
        t.style.top = `${-e}px`,
        t.style.left = `${-i}px`,
        t.style.width = "100%",
        t.style.height = "auto",
        t.style.overflow = "hidden",
        setTimeout(()=>window.requestAnimationFrame(()=>{
            const n = r - window.innerHeight;
            n && e >= r && (t.style.top = -(e + n) + "px")
        }
        ), 300)
    }
}
)
  , bD = ()=>{
    if (Ur !== void 0) {
        const s = -parseInt(document.body.style.top, 10)
          , t = -parseInt(document.body.style.left, 10)
          , e = document.documentElement
          , i = document.body;
        e.style.height = Oa?.height || "",
        e.style.overflow = Oa?.overflow || "",
        i.style.position = Ur.position || "",
        i.style.top = Ur.top || "",
        i.style.left = Ur.left || "",
        i.style.width = Ur.width || "",
        i.style.height = Ur.height || "",
        i.style.overflow = Ur.overflow || "",
        window.scrollTo(t, s),
        Ur = void 0
    }
}
  , wD = s=>s ? s.scrollHeight - s.scrollTop <= s.clientHeight : !1
  , ED = (s,t)=>{
    const e = s.targetTouches[0].clientY - Em;
    return Cx(s.target) ? !1 : t && t.scrollTop === 0 && e > 0 || wD(t) && e < 0 ? Hu(s) : (s.stopPropagation(),
    !0)
}
  , bs = (s,t)=>{
    if (!s) {
        console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
        return
    }
    if (co.set(s, co?.get(s) ? co?.get(s) + 1 : 1),
    No.some(i=>i.targetElement === s))
        return;
    const e = {
        targetElement: s,
        options: t || {}
    };
    No = [...No, e],
    Uu ? xD() : yD(t),
    Uu && (s.ontouchstart = i=>{
        i.targetTouches.length === 1 && (Em = i.targetTouches[0].clientY)
    }
    ,
    s.ontouchmove = i=>{
        i.targetTouches.length === 1 && ED(i, s)
    }
    ,
    Gu || (document.addEventListener("touchmove", Hu, wm ? {
        passive: !1
    } : void 0),
    Gu = !0))
}
  , Zn = ()=>{
    Uu && (No.forEach(s=>{
        s.targetElement.ontouchstart = null,
        s.targetElement.ontouchmove = null
    }
    ),
    Gu && (document.removeEventListener("touchmove", Hu, wm ? {
        passive: !1
    } : void 0),
    Gu = !1),
    Em = -1),
    Uu ? bD() : vD(),
    No = [],
    co.clear()
}
;
function TD(s, t, e) {
    const i = /^localhost$|^127(?:\.[0-9]+){0,2}\.[0-9]+$|^(?:0*:)*?:?0*1$/.test(location.hostname) || location.protocol === "file:";
    if (!t.trackLocalhost && i)
        return console.warn("[Plausible] Ignoring event because website is running locally");
    try {
        if (window.localStorage.plausible_ignore === "true")
            return console.warn('[Plausible] Ignoring event because "plausible_ignore" is set to "true" in localStorage')
    } catch {}
    const r = {
        n: s,
        u: t.url,
        d: t.domain,
        r: t.referrer,
        w: t.deviceWidth,
        h: t.hashMode ? 1 : 0,
        p: e && e.props ? JSON.stringify(e.props) : void 0
    }
      , n = new XMLHttpRequest;
    n.open("POST", `${t.apiHost}/api/event`, !0),
    n.setRequestHeader("Content-Type", "text/plain"),
    n.send(JSON.stringify(r)),
    n.onreadystatechange = ()=>{
        n.readyState === 4 && e && e.callback && e.callback()
    }
}
function DD(s) {
    const t = ()=>({
        hashMode: !1,
        trackLocalhost: !1,
        url: location.href,
        domain: location.hostname,
        referrer: document.referrer || null,
        deviceWidth: window.innerWidth,
        apiHost: "https://plausible.io",
        ...s
    })
      , e = (o,a,l)=>{
        TD(o, {
            ...t(),
            ...l
        }, a)
    }
      , i = (o,a)=>{
        e("pageview", a, o)
    }
    ;
    return {
        trackEvent: e,
        trackPageview: i,
        enableAutoPageviews: ()=>{
            const o = ()=>i()
              , a = history.pushState;
            return a && (history.pushState = function(l, h, u) {
                a.apply(this, [l, h, u]),
                o()
            }
            ,
            addEventListener("popstate", o)),
            s && s.hashMode && addEventListener("hashchange", o),
            i(),
            function() {
                a && (history.pushState = a,
                removeEventListener("popstate", o)),
                s && s.hashMode && removeEventListener("hashchange", o)
            }
        }
        ,
        enableAutoOutboundTracking: (o=document,a={
            subtree: !0,
            childList: !0,
            attributes: !0,
            attributeFilter: ["href"]
        })=>{
            function l(f) {
                e("Outbound Link: Click", {
                    props: {
                        url: this.href
                    }
                }),
                typeof process < "u" && process,
                setTimeout(()=>{
                    location.href = this.href
                }
                , 150),
                f.preventDefault()
            }
            const h = new Set;
            function u(f) {
                f instanceof HTMLAnchorElement ? f.host !== location.host && (f.addEventListener("click", l),
                h.add(f)) : "querySelectorAll"in f && f.querySelectorAll("a").forEach(u)
            }
            function c(f) {
                f instanceof HTMLAnchorElement ? (f.removeEventListener("click", l),
                h.delete(f)) : "querySelectorAll"in f && f.querySelectorAll("a").forEach(c)
            }
            const d = new MutationObserver(f=>{
                f.forEach(p=>{
                    p.type === "attributes" ? (c(p.target),
                    u(p.target)) : p.type === "childList" && (p.addedNodes.forEach(u),
                    p.removedNodes.forEach(c))
                }
                )
            }
            );
            return o.querySelectorAll("a").forEach(u),
            d.observe(o, a),
            function() {
                h.forEach(p=>{
                    p.removeEventListener("click", l)
                }
                ),
                h.clear(),
                d.disconnect()
            }
        }
    }
}
const AD = DD({
    domain: "canvascreative.co"
})
  , {trackEvent: Tm} = AD
  , $e = document.getElementById("header")
  , ro = document.getElementById("header-logo")
  , $u = document.querySelector(".modal-content")
  , zu = document.querySelectorAll(".workModal-item")
  , Vu = document.getElementById("contact-modal")
  , Lf = "footer-contact-button"
  , va = "header-contact-button"
  , Eh = "header-work-button";
function SD(s, t) {
    for (; s && s !== document; ) {
        if (s.classList.contains(t))
            return s;
        s = s.parentNode
    }
    return null
}
function CD(s) {
    let t = s.parentNode
      , e = []
      , i = t.firstChild;
    for (; i; )
        i.nodeType === 1 && i !== s && e.push(i),
        i = i.nextSibling;
    return e
}
function F0() {
    N.set(zu, {
        pointerEvents: "all"
    }),
    N.to(zu, {
        startAt: {
            opacity: 0,
            y: "20%"
        },
        opacity: 1,
        y: "0%",
        stagger: .03,
        delay: .2
    })
}
function B0() {
    N.set(zu, {
        pointerEvents: "none"
    }),
    N.to(zu, {
        opacity: 0,
        y: "20%",
        stagger: .03
    })
}
function O0() {
    Nf.submitted && Nf.resetAfterSuccess(),
    N.set(Vu, {
        pointerEvents: "all",
        overflowY: "scroll"
    }),
    Vu.scrollTop = 0,
    N.set($u, {
        pointerEvents: "all"
    }),
    N.to($u, {
        opacity: 1,
        delay: .2
    }),
    N.to(".contact-modal-line", {
        startAt: {
            width: "0%"
        },
        width: "100%",
        duration: .5,
        delay: .5
    }),
    N.to(".modal-slide", {
        opacity: 1,
        y: "0%",
        stagger: .03,
        duration: .5,
        delay: .4
    })
}
function k0() {
    N.set(Vu, {
        pointerEvents: "none",
        overflowY: "hidden"
    }),
    N.set($u, {
        pointerEvents: "none"
    }),
    N.to($u, {
        opacity: 0
    }),
    N.to(".contact-modal-line", {
        duration: .5,
        width: "0%"
    }),
    N.to(".modal-slide", {
        y: "100%",
        opacity: 0,
        duration: .3
    });
    const s = document.getElementById(Lf);
    s && s.classList.remove("active")
}
const Dc = s=>{
    const t = $e.classList.contains("active")
      , e = document.querySelector(".modal-backdrop");
    t ? $e.dataset.modal === s ? (Zn(),
    document.getElementById(s).classList.remove("active"),
    N.to(e, {
        duration: .5,
        height: "0",
        delay: .3
    }),
    $e.classList.contains("restore-theme-light") && setTimeout(()=>{
        $e.classList.remove("restore-theme-light"),
        Xu("light")
    }
    , 500),
    $e.classList.remove("active"),
    ro.classList.contains("restore-header-hidden") && (ro.classList.remove("restore-header-hidden"),
    N.to(ro, {
        opacity: 0,
        pointerEvents: "none"
    })),
    s === Eh && B0(),
    s === va && k0(),
    $e.dataset.modal = "") : ($e.dataset.modal = s,
    s === va ? (B0(),
    O0(),
    document.getElementById(Lf).classList.add("active"),
    document.getElementById(va).classList.add("active"),
    document.getElementById(Eh).classList.remove("active")) : (k0(),
    F0(),
    document.getElementById(Lf).classList.remove("active"),
    document.getElementById(va).classList.remove("active"),
    document.getElementById(Eh).classList.add("active"))) : ($e.classList.add("active"),
    document.getElementById(s).classList.add("active"),
    $e.dataset.modal = s,
    N.to(e, {
        duration: .5,
        height: "101%"
    }),
    $e.classList.contains("theme-light") && $e.classList.add("restore-theme-light"),
    window.getComputedStyle(ro).opacity === "0" && (ro.classList.add("restore-header-hidden"),
    N.to(ro, {
        opacity: 1,
        pointerEvents: "auto",
        delay: .5
    })),
    Xu("dark"),
    s === Eh && F0(),
    s === va && (Tm("Contact Open"),
    window.gtag("event", "contact_open"),
    bs(Vu),
    O0()))
}
;
function PD() {
    const s = N.matchMedia()
      , t = N.utils.toArray(".workModal-item");
    s.add(zi, ()=>{
        t.forEach(e=>{
            const i = e.parentElement.previousElementSibling
              , r = SD(e, "work-nav-item")
              , n = CD(r);
            e.addEventListener("mouseenter", ()=>{
                i.classList.contains("clicked") || (i.classList.add("active"),
                n.forEach(o=>{
                    o.classList.add("inactive")
                }
                ))
            }
            ),
            e.addEventListener("mouseleave", ()=>{
                i.classList.contains("clicked") || (i.classList.remove("active"),
                n.forEach(o=>{
                    o.classList.remove("inactive")
                }
                ))
            }
            ),
            e.addEventListener("click", ()=>{
                i.classList.add("clicked"),
                i.classList.remove("active")
            }
            )
        }
        )
    }
    )
}
function Xu(s) {
    const t = N.matchMedia();
    $e.classList.remove("theme-light"),
    $e.classList.remove("theme-dark"),
    $e.classList.remove("theme-"),
    s === "light" ? $e.classList.add("theme-light") : s === "light-desktop" && t.add(zi, ()=>{
        $e.classList.add("theme-light")
    }
    )
}
function ID() {
    const s = N.utils.toArray("[data-theme]");
    s && s.forEach(t=>{
        const e = t.getAttribute("data-theme");
        mt.create({
            trigger: t,
            start: "top 40px",
            end: "bottom 40px",
            onToggle: i=>{
                i.isActive && Xu(e)
            }
        })
    }
    )
}
const RD = ()=>{
    const s = document.querySelector("#header-logo")
      , t = document.querySelector("#hero__svg-logo")
      , e = i=>{
        window.location.pathname === "/" && (document.querySelector("#header").classList.contains("active") ? Dc($e.dataset.modal) : i.preventDefault()),
        document.querySelector("#header").classList.contains("active") || window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
    ;
    s.addEventListener("click", e),
    window.location.pathname === "/" ? (N.set(s, {
        opacity: 0,
        pointerEvents: "none"
    }),
    s.removeAttribute("href")) : (N.set(s, {
        opacity: 1,
        pointerEvents: "auto"
    }),
    s.setAttribute("href", "/")),
    t && N.set(t, {
        clearProps: "all"
    })
}
;
function MD() {
    PD(),
    document.querySelectorAll(".modal-button").forEach(t=>{
        const e = t.id;
        t.addEventListener("click", ()=>Dc(e))
    }
    )
}
var fd = {
    duration: 2e5,
    easing: s=>s
};
function FD(s, t) {
    function e(r) {
        new kf(r.querySelector(".keen-slider"),{
            loop: !0,
            mode: "free",
            renderMode: "precision",
            slides: {
                perView: 1.25,
                spacing: 16
            },
            created(n) {
                n.moveToIdx(5, !0, fd);
                const o = r.querySelectorAll(".keen-slider__slide")
                  , a = document.querySelector(".cap-sliders");
                o.forEach((l,h)=>{
                    const u = l.getAttribute("data-slider-index")
                      , c = l.getAttribute("data-slide-index")
                      , d = N.utils.toArray(".cap-sliders .lightbox-slider");
                    l.addEventListener("click", ()=>{
                        a.classList.remove("hidden"),
                        a.classList.add("flex"),
                        d[u].classList.remove("hidden"),
                        bs(a),
                        Xu("dark"),
                        new kf(document.querySelector(`.lightbox-slider[data-slider="lightbox-${u}"]`),{
                            mode: "snap",
                            loop: !0,
                            renderMode: "precision",
                            slides: {
                                perView: 1,
                                spacing: 16
                            },
                            created(p) {
                                a.addEventListener("click", ()=>{
                                    Zn(),
                                    a.classList.remove("flex"),
                                    a.classList.add("hidden"),
                                    d[u].classList.add("hidden"),
                                    n.moveToIdx(Number(p.animator.targetIdx), !0, {
                                        duration: 0
                                    }),
                                    p.destroy()
                                }
                                )
                            }
                        }).moveToIdx(Number(c), !0, {
                            duration: 0
                        })
                    }
                    )
                }
                )
            },
            updated(n) {
                n.moveToIdx(n.track.details.abs + 5, !0, fd)
            },
            animationEnded(n) {
                n.moveToIdx(n.track.details.abs + 5, !0, fd)
            }
        })
    }
    const i = document.querySelectorAll(s);
    i && i.forEach((r,n)=>{
        e(r)
    }
    )
}
function L0(s) {
    const t = N.utils.toArray(s);
    t && t.forEach(e=>{
        const i = e.querySelector("img")
          , r = Number.parseFloat(i.clientHeight - window.innerHeight).toFixed()
          , n = s === ".project-bg";
        N.matchMedia().add({
            isDesktop: "(min-width: 768px)"
        }, a=>{
            const {isDesktop: l} = a.conditions;
            N.set(e.querySelector("img"), {
                y: n && !l ? 0 : -r
            })
        }
        )
    }
    )
}
function BD() {
    if (N.matchMedia(),
    document.querySelector("#work-details-modal")) {
        const t = ()=>{
            N.set("#header", {
                visibility: "hidden"
            }),
            N.set(".detail-clip", {
                yPercent: 120,
                opacity: 0
            }),
            N.set("#work-details-modal", {
                visibility: "visible"
            }),
            N.to("#modal-details-backdrop", {
                height: "101%",
                duration: .5
            }),
            N.to("#modal-details-content", {
                opacity: 1,
                delay: .2
            }),
            N.to(".detail-clip", {
                opacity: 1,
                yPercent: 0,
                stagger: .04,
                duration: .5,
                delay: .3
            }),
            N.set(".detail-modal-line", {
                transformOrigin: "left",
                scaleX: 0
            }),
            N.to(".detail-modal-line", {
                scaleX: 1,
                stagger: .03,
                delay: .3
            }),
            N.to("#work-details-close", {
                opacity: 1,
                ease: "linear",
                duration: .3,
                delay: .6
            }),
            N.set("#work-details-close", {
                pointerEvents: "all",
                delay: .4
            })
        }
          , e = ()=>{
            Zn(),
            N.set("#header", {
                visibility: "visible",
                delay: .5
            }),
            N.to("#modal-details-backdrop", {
                height: "0",
                duration: .5,
                delay: .3
            }),
            N.to("#modal-details-content", {
                opacity: 0
            }),
            N.to(".detail-clip", {
                opacity: 0,
                yPercent: 100,
                duration: .3
            }),
            N.set("#work-details-modal", {
                visibility: "hidden",
                delay: .5
            }),
            N.to("#work-details-close", {
                opacity: 0,
                ease: "linear",
                duration: .3
            }),
            N.set("#work-details-close", {
                pointerEvents: "none"
            })
        }
        ;
        document.querySelectorAll(".work-details-open").forEach(i=>{
            i.addEventListener("click", ()=>{
                t()
            }
            )
        }
        ),
        document.querySelector("#work-details-close").addEventListener("click", ()=>{
            e()
        }
        )
    }
}
const OD = s=>{
    new ResizeObserver(()=>{
        s()
    }
    ).observe(document.body)
}
;
function kD() {
    const s = document.querySelector("#fixed-details-buttons");
    if (s) {
        const t = s.querySelector(".work-details-open");
        OD(()=>{
            mt.refresh()
        }
        ),
        mt.create({
            trigger: "#work-wrap",
            start: "top bottom",
            endTrigger: "#WorkNextProject",
            end: "top bottom",
            onEnter: ()=>{
                N.to(t, {
                    opacity: 1,
                    pointerEvents: "all",
                    y: 0
                })
            }
            ,
            onLeave: ()=>{
                N.to(t, {
                    opacity: 0,
                    pointerEvents: "none",
                    y: 50
                })
            }
            ,
            onEnterBack: ()=>{
                N.to(t, {
                    opacity: 1,
                    pointerEvents: "all",
                    y: 0
                })
            }
            ,
            onLeaveBack: ()=>{
                N.to(t, {
                    opacity: 0,
                    pointerEvents: "none",
                    y: 50
                })
            }
        })
    }
}
const LD = (s,t)=>{
    if (t.length <= 0)
        return "This field is required";
    if (s === "email") {
        if (!/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(t))
            return "Please enter a valid email"
    } else
        return ""
}
;
class ND {
    constructor() {
        this.submitted = !1;
        const t = document.querySelector("#contact-modal-form");
        this.form = t,
        this.submitBtn = t.querySelector("#contact-modal-submit"),
        this.inputs = [...t.querySelectorAll("input"), ...t.querySelectorAll("textarea")],
        this.addListeners()
    }
    addListeners = ()=>{
        const t = (o,a)=>{
            const l = o.parentElement.querySelector(".error-message");
            o.classList.add("pb-8"),
            o.classList.remove("pb-5"),
            l.classList.remove("opacity-0"),
            l.classList.add("opacity-100"),
            l.innerHTML = a
        }
          , e = o=>{
            const a = o.parentElement.querySelector(".error-message");
            o.classList.add("pb-5"),
            o.classList.remove("pb-8"),
            a.classList.remove("opacity-100"),
            a.classList.add("opacity-0"),
            a.innerHTML = ""
        }
          , i = ()=>{
            let o = !0;
            return this.inputs.forEach(a=>{
                const l = LD(a.id, a.value);
                l && l !== "" ? (o = !1,
                t(a, l)) : e(a)
            }
            ),
            o
        }
          , r = o=>{
            if (o.preventDefault(),
            this.submitted = !0,
            i()) {
                this.submitBtn.setAttribute("disabled", "true");
                const l = o.target
                  , h = new FormData(l);
                fetch("/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    body: new URLSearchParams(h).toString()
                }).then(()=>{
                    setTimeout(()=>{
                        this.form.classList.add("pointer-events-none"),
                        this.inputs.forEach(f=>f.parentElement.classList.add("opacity-50"));
                        const u = document.querySelector(".contact-modal-success--desc");
                        document.querySelector("#contact-modal").scrollTo({
                            top: 0,
                            behavior: "smooth"
                        }),
                        N.to(".contact-modal-desc", {
                            height: u.clientHeight
                        }),
                        N.to(".contact-modal-copy", {
                            opacity: 0
                        }),
                        N.to(".contact-modal-success", {
                            y: "0%",
                            opacity: 1,
                            delay: .1
                        });
                        const d = this.submitBtn.parentElement.querySelector(".success-message");
                        N.to(d, {
                            y: 0
                        }),
                        N.to(this.submitBtn, {
                            y: -100
                        })
                    }
                    , 300)
                }
                ).catch(u=>{
                    console.log(u),
                    this.submitBtn.removeAttribute("disabled")
                }
                )
            }
        }
        ;
        this.form.addEventListener("submit", r);
        const n = o=>{
            this.submitted || e(o.target),
            this.inputs.some(l=>l.value === "") ? this.submitBtn.setAttribute("disabled", "true") : this.submitBtn.removeAttribute("disabled"),
            this.submitted = !1
        }
        ;
        this.inputs.forEach(o=>{
            o.addEventListener("keyup", n)
        }
        )
    }
    ;
    resetAfterSuccess = ()=>{
        this.form.classList.remove("pointer-events-none"),
        this.inputs.forEach(e=>{
            e.value = "",
            e.parentElement.classList.remove("opacity-50")
        }
        ),
        N.to(".contact-modal-desc", {
            height: "auto"
        }),
        N.set(".contact-modal-copy", {
            opacity: 1
        }),
        N.set(".contact-modal-success", {
            y: "100%",
            opacity: 0
        });
        const t = this.submitBtn.parentElement.querySelector(".success-message");
        N.to(t, {
            y: "100%"
        }),
        N.to(this.submitBtn, {
            y: 0
        })
    }
}
let pd = !1;
const UD = ()=>{
    const s = document.querySelectorAll(".cursor-wrapper")
      , t = document.querySelector("#layout-cursor")
      , e = t.querySelector("span")
      , i = {
        opacity: N.quickTo(t, "opacity", {
            duration: .3,
            ease: "power4.out"
        }),
        x: N.quickTo(t, "x", {
            duration: .4,
            ease: "power3.out"
        }),
        y: N.quickTo(t, "y", {
            duration: .4,
            ease: "power3.out"
        })
    }
      , r = ()=>{
        i.opacity(1),
        pd = !0
    }
      , n = ()=>{
        i.opacity(0),
        pd = !1
    }
      , o = ()=>{
        pd || r()
    }
      , a = h=>{
        const u = h.clientX + 10
          , c = h.clientY + 20;
        i.x(u),
        i.y(c)
    }
      , l = new IntersectionObserver(h=>{
        h.forEach(u=>{
            u.isIntersecting || n()
        }
        )
    }
    );
    s.forEach(h=>{
        const u = h.dataset.cursorLabel;
        u && (e.innerText = `( ${u} )`);
        const c = ()=>{
            h.classList.add("pointer-events-none"),
            N.to(t, {
                opacity: 0
            })
        }
        ;
        l.observe(h),
        h.addEventListener("mouseenter", r),
        h.addEventListener("mouseleave", n),
        h.addEventListener("mousemove", o),
        h.addEventListener("click", c)
    }
    ),
    document.addEventListener("mousemove", a)
}
;
function GD() {
    let s = [].slice.call(document.querySelectorAll("video.lazy"));
    if ("IntersectionObserver"in window) {
        let t = new IntersectionObserver(function(e, i) {
            e.forEach(function(r) {
                if (r.isIntersecting) {
                    for (let n in r.target.children) {
                        let o = r.target.children[n];
                        typeof o.tagName == "string" && o.tagName === "SOURCE" && (o.src = o.dataset.src)
                    }
                    r.target.load(),
                    r.target.classList.remove("lazy"),
                    t.unobserve(r.target)
                }
            })
        }
        );
        s.forEach(function(e) {
            t.observe(e)
        })
    }
}
const HD = ()=>{
    document.querySelectorAll("img.lazy-blur").forEach((t,e)=>{
        t.addEventListener("load", ()=>{
            t.classList.remove("opacity-0", "hidden"),
            t.classList.remove("lazy")
        }
        ),
        t.src = t.dataset.src
    }
    )
}
;
let Nf = null;
function Wu() {
    Qs.create({
        smooth: 1,
        effects: !0,
        smoothTouch: !1
    }).scrollTo(0, !1),
    Nf = new ND,
    L0(".project-bg .wt-bg"),
    L0(".to-helper .wt-bg"),
    GD(),
    HD(),
    UD(),
    nD(".reveal-blur"),
    oD(".reveal-text"),
    aD(".reveal-lines"),
    lD(".reveal-rows"),
    uD(".reveal-footer"),
    _D(".reviews-slider", "reviews"),
    FD(".zoom-slider"),
    hD(".line-ani"),
    RD(),
    ID();
    const t = document.querySelector("#footer-contact-button");
    t && t.addEventListener("click", ()=>Dc("header-contact-button"));
    const e = document.querySelector(".footer-copy-year");
    e.innerHTML = new Date().getFullYear(),
    BD(),
    kD();
    function i(r) {
        typeof window.gtag == "function" ? r() : setTimeout(()=>i(r), 400)
    }
    i(()=>{
        window.gtag("event", "page_view", {
            page_title: document.title,
            page_location: location.href,
            page_path: location.pathname
        }),
        document.querySelectorAll("[data-plausible]").forEach(n=>{
            n.addEventListener("click", ()=>{
                const o = n.getAttribute("data-plausible");
                Tm(o),
                window.gtag("event", o.toLowerCase().replace(/ /g, "_"))
            }
            )
        }
        )
    }
    )
}
function qn() {
    mt.getAll().forEach(e=>{
        e.kill()
    }
    );
    const t = Qs.get();
    t && (t.scrollTo(0, !1),
    t.kill())
}
async function md(s, t) {
    const {next: e, current: i} = s;
    N.timeline().set(e.container, {
        onComplete: function() {
            i.container.remove(),
            Zn(),
            qn(),
            t()
        }
    })
}
async function xa(s, t) {
    const {next: e} = s
      , i = N.timeline()
      , r = document.getElementById("header")
      , n = document.getElementById("header-logo")
      , o = N.utils.toArray(".wt-menu .to-helper");
    i.set(o, {
        clearProps: "all"
    }).set(e.container, {
        position: "relative",
        zIndex: "1",
        onComplete: function() {
            Wu(),
            Zn(),
            r.classList.remove("restore-theme-light"),
            n.classList.remove("restore-header-hidden"),
            window.scrollTo(0, 0),
            t()
        }
    })
}
function Uo(s, t) {
    for (; s && s !== document; ) {
        if (s.classList.contains(t))
            return s;
        s = s.parentNode
    }
    return null
}
function Px(s, t) {
    let e = s.parentNode
      , i = []
      , r = e.firstChild;
    for (; r; )
        r.nodeType === 1 && r !== s && r.classList.contains(t) && i.push(r),
        r = r.nextSibling;
    return i
}
const N0 = N.matchMedia();
async function $D(s, t) {
    const {next: e, current: i} = s
      , r = e.container.querySelector(".relative > .wt-hero")
      , n = i.container.querySelector(".wt-footer")
      , o = i.container.querySelector("#fixedProjectButton")
      , a = document.querySelector("#work-footer-cursor")
      , l = n.querySelector(".wt-footer-copy")
      , h = n.querySelector(".wt-next")
      , u = n.querySelector(".wt-footer-title")
      , c = Uo(r.querySelector(".wt-title"), "overflow-hidden")
      , d = n.querySelector(".wt-title")
      , f = n.querySelector(".wt-bg img")
      , p = r.querySelector(".wt-bg img")
      , m = r.querySelector(".wt-subtitle")
      , g = r.querySelector(".wt-details")
      , _ = r.querySelectorAll(".hero-table-line")
      , x = r.querySelectorAll(".wt-clip")
      , y = r.querySelector(".wt-video")
      , v = u.getBoundingClientRect().top - d.getBoundingClientRect().top
      , E = n.getBoundingClientRect().top
      , P = Number.parseFloat(f.clientHeight - window.innerHeight).toFixed()
      , w = N.timeline({
        defaults: {
            duration: 1.3,
            ease: Je.default
        }
    });
    N0.add(zi, ()=>{
        w.set(e.container, {
            position: "fixed",
            zIndex: "2",
            onComplete: ()=>{
                bs(document.querySelector("body"))
            }
        }).set(f, {
            opacity: 0
        }).set(u, {
            opacity: 0
        }).set(a, {
            display: "none"
        }).set(r, {
            y: E
        }).set(p, {
            y: -P
        }).set(c, {
            y: v
        }).set(g, {
            yPercent: 110
        }).set(m, {
            yPercent: 100
        }).set(g, {
            yPercent: 110
        }).set(_, {
            width: 0
        }).set(x, {
            yPercent: 100
        }).set(y, {
            opacity: 0,
            yPercent: 200
        }).to([l, o], {
            opacity: 0,
            duration: .3,
            ease: "linear"
        }, 0).to(h, {
            opacity: 0,
            duration: .15,
            ease: "linear"
        }, 0).to(r, {
            y: 0,
            duration: 1
        }, 0).to(p, {
            y: 0,
            onComplete: function() {
                i.container.remove(),
                qn(),
                t()
            }
        }, 0).to(c, {
            y: 0,
            duration: 1.2
        }, 0).to(m, {
            yPercent: 0
        }, .2).to(g, {
            yPercent: 0
        }, .4).to(_, {
            width: "100%"
        }, .2).to(x, {
            yPercent: 0,
            stagger: .05
        }, .2).to(y, {
            opacity: 1,
            yPercent: 0
        }, .2)
    }
    ),
    N0.add("(max-width: 767px)", ()=>{
        w.set(e.container, {
            position: "fixed",
            zIndex: "2",
            top: 0,
            onComplete: ()=>{
                bs(document.querySelector("body"))
            }
        }, 0).set(r, {
            y: E
        }).set(m, {
            yPercent: 100
        }).set(g, {
            yPercent: 110
        }).set(_, {
            width: 0
        }).set(x, {
            yPercent: 100
        }).set(y, {
            opacity: 0,
            yPercent: 200
        }).to(r, {
            y: 0,
            onComplete: function() {
                i.container.remove(),
                qn(),
                t()
            }
        }, 0).to(m, {
            yPercent: 0
        }, .4).to(g, {
            yPercent: 0
        }, .5).to(_, {
            width: "100%"
        }, .4).to(x, {
            yPercent: 0,
            stagger: .05
        }, .4).to(y, {
            opacity: 1,
            yPercent: 0
        }, .5)
    }
    )
}
const U0 = N.matchMedia();
async function zD(s, t) {
    const {next: e, current: i, trigger: r} = s
      , n = e.container.querySelector(".relative > .wt-hero")
      , o = Uo(r, "wt-project")
      , a = o.querySelector(".wt-home-images")
      , l = o.getAttribute("data-project")
      , h = N.utils.toArray("#project-pin .project-bg")
      , u = N.utils.toArray("#project-pin .project-info")
      , c = Px(h[l], "project-bg")
      , d = h[l].querySelector(".wt-bg img")
      , f = h[l].querySelector(".wt-title")
      , p = h[l].querySelector(".wt-subtitle")
      , m = u[l].querySelector(".wt-home-case")
      , g = u[l].querySelector(".wt-home-title")
      , _ = u[l].querySelector(".wt-home-subtitle")
      , x = Uo(n.querySelector(".wt-title"), "overflow-hidden")
      , y = Uo(n.querySelector(".wt-subtitle"), "overflow-hidden")
      , v = n.querySelector(".wt-subtitle")
      , E = n.querySelector(".wt-bg img")
      , P = n.querySelector(".wt-details")
      , w = n.querySelectorAll(".hero-table-line")
      , A = n.querySelectorAll(".wt-clip")
      , I = n.querySelector(".wt-video")
      , F = g.getBoundingClientRect().top - f.getBoundingClientRect().top
      , O = _.getBoundingClientRect().top - p.getBoundingClientRect().top + 26
      , B = d.getBoundingClientRect().height - window.innerHeight;
    let S = 0;
    const T = document.querySelector("#project-pin").getBoundingClientRect().top;
    l === "0" && T > 0 && (S = T),
    Number(l) === c.length && T < 0 && (S = T);
    const M = N.timeline({
        defaults: {
            duration: 1.3,
            ease: Je.default
        }
    });
    U0.add(zi, ()=>{
        M.set(e.container, {
            position: "fixed",
            zIndex: "2",
            onComplete: ()=>{
                bs(document.querySelector("body"))
            }
        }).set(d, {
            opacity: 0
        }).set(g, {
            opacity: 0
        }).set(_, {
            opacity: 0
        }).set(n, {
            y: S
        }).set(E, {
            y: -B
        }).set(x, {
            y: F,
            scale: .218,
            transformOrigin: "top left"
        }).set(y, {
            y: O
        }).set(P, {
            yPercent: 110
        }).set(w, {
            width: 0
        }).set(A, {
            yPercent: 100
        }).set(I, {
            opacity: 0,
            yPercent: 200
        }).to(a, {
            opacity: 0,
            duration: .15,
            ease: "linear"
        }, 0).to(m, {
            opacity: 0,
            duration: .3,
            ease: "linear"
        }, 0).to(n, {
            y: 0,
            duration: 1
        }, 0).to(E, {
            y: 0,
            onComplete: function() {
                i.container.remove(),
                qn(),
                t()
            }
        }, 0).to(x, {
            scale: 1,
            y: 0,
            duration: 1.2
        }, 0).to(y, {
            y: 0
        }, 0).to(P, {
            yPercent: 0
        }, .4).to(w, {
            width: "100%"
        }, .2).to(A, {
            yPercent: 0,
            stagger: .05
        }, .2).to(I, {
            opacity: 1,
            yPercent: 0
        }, .2)
    }
    ),
    U0.add("(max-width: 767px)", ()=>{
        S = o.getBoundingClientRect().top,
        M.set(e.container, {
            position: "fixed",
            zIndex: "2",
            top: 0,
            onComplete: ()=>{
                bs(document.querySelector("body"))
            }
        }, 0).set(n, {
            y: S
        }).set(x, {
            y: F,
            scale: .218,
            transformOrigin: "top left"
        }).set(v, {
            yPercent: 100
        }).set(P, {
            yPercent: 110
        }).set(w, {
            width: 0
        }).set(A, {
            yPercent: 100
        }).set(I, {
            opacity: 0,
            yPercent: 200
        }).to(n, {
            y: 0,
            onComplete: function() {
                i.container.remove(),
                qn(),
                t()
            }
        }, 0).to(x, {
            scale: 1,
            y: 0
        }, 0).to(v, {
            yPercent: 0
        }, .4).to(P, {
            yPercent: 0
        }, .5).to(w, {
            width: "100%"
        }, .4).to(A, {
            yPercent: 0,
            stagger: .05
        }, .4).to(I, {
            opacity: 1,
            yPercent: 0
        }, .5)
    }
    )
}
const G0 = N.matchMedia();
async function H0(s, t) {
    const {next: e, current: i, trigger: r} = s
      , n = e.container.querySelector(".relative > .wt-hero")
      , o = document.getElementById("header");
    document.getElementById("header-logo");
    const a = document.getElementById("header-work-button")
      , l = document.getElementById("header-contact-button")
      , h = document.getElementById("work-modal");
    i.container.querySelector("#fixedProjectButton");
    const u = Uo(r, "work-nav-item")
      , c = u.querySelector(".to-helper")
      , d = Px(u, "work-nav-item")
      , f = u.querySelectorAll(".wt-menu-hide")
      , p = document.querySelectorAll(".workModal-item")
      , m = u.querySelector(".wt-menu-title")
      , g = Uo(n.querySelector(".wt-title"), "overflow-hidden")
      , _ = u.querySelector(".wt-title")
      , x = u.querySelector(".wt-bg img")
      , y = n.querySelector(".wt-bg img")
      , v = n.querySelector(".wt-subtitle")
      , E = n.querySelector(".wt-details")
      , P = n.querySelectorAll(".hero-table-line")
      , w = n.querySelectorAll(".wt-clip")
      , A = n.querySelector(".wt-video")
      , I = m.getBoundingClientRect().top - _.getBoundingClientRect().top
      , F = Number.parseFloat(x.clientHeight - window.innerHeight).toFixed()
      , O = N.timeline({
        defaults: {
            duration: 1.3,
            ease: Je.default
        }
    })
      , B = N.timeline({
        paused: !0
    });
    B.set(c, {
        opacity: 0,
        onComplete: ()=>{
            N.set(c, {
                clearProps: "all"
            }),
            N.set(d, {
                clearProps: "all"
            }),
            N.set(h, {
                clearProps: "all"
            }),
            N.set(f, {
                clearProps: "all"
            }),
            c.classList.remove("clicked"),
            d.forEach(T=>{
                T.classList.remove("inactive")
            }
            )
        }
    }, 0);
    function S() {
        N.set(".modal-backdrop", {
            height: "0"
        }),
        N.set(x, {
            opacity: 1
        }),
        N.set(m, {
            clearProps: "all"
        }),
        N.set(p, {
            pointerEvents: "none"
        }),
        N.set(p, {
            opacity: 0,
            y: "20%"
        }),
        o.classList.remove("theme-light"),
        o.classList.remove("active"),
        o.classList.remove("restore-theme-light"),
        l.classList.remove("active"),
        a.classList.remove("active")
    }
    G0.add(zi, ()=>{
        O.set(e.container, {
            position: "fixed",
            zIndex: "2",
            onComplete: ()=>{
                bs(document.querySelector("body")),
                a.classList.remove("active"),
                B.play(),
                S()
            }
        }).set(y, {
            y: -F
        }).set(g, {
            y: I,
            scale: .10909,
            transformOrigin: "top left"
        }).set(v, {
            yPercent: 100
        }).set(E, {
            yPercent: 110
        }).set(P, {
            width: 0
        }).set(w, {
            yPercent: 100
        }).set(A, {
            opacity: 0,
            yPercent: 200
        }).to(y, {
            y: 0,
            onComplete: function() {
                i.container.remove(),
                qn(),
                t()
            }
        }, 0).to(g, {
            scale: 1,
            y: 0,
            duration: 1.2
        }, 0).to(v, {
            yPercent: 0
        }, .2).to(E, {
            yPercent: 0
        }, .4).to(P, {
            width: "100%"
        }, .2).to(w, {
            yPercent: 0,
            stagger: .05
        }, .2).to(A, {
            opacity: 1,
            yPercent: 0
        }, .2)
    }
    ),
    G0.add("(max-width: 767px)", ()=>{
        O.set(e.container, {
            position: "fixed",
            zIndex: "2",
            top: 0,
            onComplete: ()=>{
                bs(document.querySelector("body")),
                a.classList.remove("active"),
                B.play(),
                S()
            }
        }).set(g, {
            y: I,
            scale: .218,
            transformOrigin: "top left"
        }).set(v, {
            yPercent: 100
        }).set(E, {
            yPercent: 110
        }).set(P, {
            width: 0
        }).set(w, {
            yPercent: 100
        }).set(A, {
            opacity: 0,
            yPercent: 200
        }).to(g, {
            scale: 1,
            y: 0,
            onComplete: function() {
                i.container.remove(),
                qn(),
                t()
            }
        }, 0).to(v, {
            yPercent: 0
        }, .4).to(E, {
            yPercent: 0
        }, .5).to(P, {
            width: "100%"
        }, .4).to(w, {
            yPercent: 0,
            stagger: .05
        }, .4).to(A, {
            opacity: 1,
            yPercent: 0
        }, .5)
    }
    )
}
async function VD(s) {
    const {next: t} = s
      , e = t.container.querySelector(".wt-hero")
      , i = e.querySelector(".wt-title")
      , r = e.querySelector(".wt-subtitle")
      , n = e.querySelector(".wt-details")
      , o = e.querySelector(".wt-video")
      , a = e.querySelectorAll(".hero-table-line")
      , l = e.querySelectorAll(".wt-clip");
    N.timeline({
        defaults: {
            duration: 1.3,
            ease: Je.default
        }
    }).set(i, {
        yPercent: 120
    }).set(r, {
        yPercent: 120
    }).set(n, {
        yPercent: 120
    }).set(o, {
        yPercent: 100
    }).set(a, {
        width: 0
    }).set(l, {
        yPercent: 120
    }).to(i, {
        yPercent: 0
    }, .5).to(r, {
        yPercent: 0
    }, .7).to(n, {
        yPercent: 0
    }, .9).to(o, {
        yPercent: 0
    }, .7).to(a, {
        width: "100%"
    }, .7).to(l, {
        yPercent: 0,
        stagger: .05
    }, .7)
}
const XD = s=>s.replace(/[A-Z]/g, t=>`-${t.toLowerCase()}`)
  , WD = (s,t)=>{
    const e = new URL(s);
    for (const r in t) {
        const n = XD(r)
          , o = t[r];
        o === void 0 ? e.searchParams.delete(n) : Array.isArray(o) ? e.searchParams.set(n, o.join(",")) : e.searchParams.set(n, `${o}`)
    }
    const i = e.searchParams.get("s");
    return i && (e.searchParams.delete("s"),
    e.searchParams.append("s", i)),
    e.toString()
}
  , jD = s=>s != null
  , qD = s=>jD(s) && !!s.url
  , YD = (s,t={})=>s && qD(s) ? WD(s.url, t) : null;
let KD = class {
    constructor(t, e) {
        this.DOM = {
            portfolioItems: t,
            container: document.querySelector(".portfolio"),
            filterContainer: document.querySelector(".filter-container"),
            filterButtons: [...document.querySelectorAll(".filter-button")],
            categorizedPortfolioItems: {}
        },
        this.activeTag = "all",
        this.hoveredTag = null,
        this.availableTags = this.DOM.filterContainer.dataset.availabletags.split(","),
        this.availableTags.forEach(i=>{
            let r = i.split(" ")[0] === "" ? i.split(" ")[1].toLowerCase() : i.split(" ")[0].toLowerCase();
            if (i.toLowerCase() === this.activeTag) {
                this.DOM.categorizedPortfolioItems[r] = this.DOM.portfolioItems;
                return
            }
            this.DOM.categorizedPortfolioItems[r] = this.DOM.portfolioItems.filter(n=>n.dataset.tags.split(",").includes(r))
        }
        ),
        this.initEvents(),
        this.initAnimations()
    }
    getNormalizedTag = t=>{
        const e = t.split(" ");
        return e[0] === "" ? e[1] : e[0]
    }
    ;
    initEvents() {
        const t = (i,r)=>{
            this.DOM.categorizedPortfolioItems[i].forEach(n=>{
                n.classList.add(r)
            }
            )
        }
          , e = (i,r)=>{
            this.DOM.categorizedPortfolioItems[i].forEach(n=>{
                n.classList.remove(r)
            }
            )
        }
        ;
        t(this.activeTag, "active"),
        this.DOM.filterButtons.forEach(i=>{
            const r = this.getNormalizedTag(i.dataset.tag);
            r === this.activeTag && i.classList.add("active"),
            i.addEventListener("mouseenter", ()=>{
                e(this.activeTag, "active"),
                this.hoveredTag = r,
                t(this.hoveredTag, "hover-active")
            }
            ),
            i.addEventListener("mouseleave", ()=>{
                t(this.activeTag, "active"),
                this.hoveredTag = null,
                e(r, "hover-active")
            }
            )
        }
        )
    }
    initAnimations() {
        const t = this.DOM.filterButtons.find(e=>e.classList.contains("active"));
        N.set(t.querySelectorAll(".indicator"), {
            width: "1rem"
        }),
        this.DOM.filterButtons.forEach(e=>{
            const i = this.getNormalizedTag(e.dataset.tag)
              , r = e.querySelector(".clone");
            N.set(r, {
                yPercent: 100
            });
            const n = .2
              , o = Je.default
              , a = (l,{active: h=!1, indicators: u=!1, animated: c=!0})=>{
                const d = l.querySelector(".content")
                  , f = l.querySelector(".clone");
                if (c ? (N.to(d, {
                    yPercent: h ? -100 : 0,
                    duration: n,
                    ease: o
                }),
                N.to(f, {
                    yPercent: h ? 0 : 100,
                    duration: n,
                    ease: o
                })) : (N.set(d, {
                    yPercent: h ? -100 : 0
                }),
                N.set(f, {
                    yPercent: h ? 0 : 100
                })),
                u) {
                    const p = l.querySelectorAll(".indicator");
                    N.to(p, {
                        width: h ? "1rem" : "0rem",
                        duration: n,
                        ease: o
                    })
                }
            }
            ;
            e.addEventListener("mouseover", ()=>{
                this.activeTag !== i && a(e, {
                    active: !0
                })
            }
            ),
            e.addEventListener("mouseleave", ()=>{
                this.activeTag !== i && a(e, {
                    active: !1
                })
            }
            ),
            e.addEventListener("click", ()=>{
                if (this.activeTag === i)
                    return;
                const l = this.DOM.filterButtons.find(h=>h.classList.contains("active"));
                this.DOM.filterButtons.forEach(h=>h.classList.remove("active")),
                e.classList.add("active"),
                this.activeTag = i,
                a(l, {
                    active: !1,
                    animated: !1,
                    indicators: !0
                }),
                a(e, {
                    active: !0,
                    indicators: !0
                })
            }
            )
        }
        )
    }
}
;
const Qr = (s,t,e)=>s <= t ? t : s >= e ? e : s
  , ZD = (s,t,e,i,r=0,n=0)=>{
    const o = Qr(s - e / 2, r, window.innerWidth - e)
      , a = Qr(t - i / 2, n, window.innerHeight - i);
    return [o, a, i]
}
;
function QD(s=1) {
    const t = window.innerWidth * .4
      , e = t / s;
    return [t, e]
}
class JD {
    constructor(t, e) {
        const i = document.querySelector(".hover-reveal");
        if (!i)
            return;
        this.DOM = {
            items: t,
            el: i,
            inner: i.querySelector(".hover-reveal__inner"),
            loading: i.querySelector(".hover-reveal__loading"),
            container: document.querySelectorAll(".portfolio")[0]
        },
        this.bounds = {
            el: this.DOM.el.getBoundingClientRect(),
            inner: this.DOM.inner.getBoundingClientRect()
        },
        this.imagesData = e;
        const r = {
            duration: .6,
            ease: Je.default
        };
        this.xSetter = N.quickTo(this.DOM.el, "x", r),
        this.ySetter = N.quickTo(this.DOM.el, "y", r),
        this.hSetter = N.quickTo(this.DOM.el, "height", r),
        this.initEvents()
    }
    setBounds() {
        this.bounds = {
            el: this.DOM.el.getBoundingClientRect(),
            inner: this.DOM.inner.getBoundingClientRect()
        }
    }
    initEvents = ()=>{
        this.isScrolling = !1,
        this.firstRAFCycle = !0;
        let t = null
          , e = 300;
        const i = n=>{
            clearTimeout(t),
            this.showImage(n),
            this.loopRender()
        }
        ;
        this.mouseenterFn = n=>{
            this.isScrolling || i(n)
        }
        ,
        this.mouseleaveFn = ()=>{
            t = setTimeout(()=>{
                this.firstRAFCycle = !0,
                this.stopRendering(),
                this.hideImage()
            }
            , e)
        }
        ;
        let r = null;
        this.windowScrollFn = ()=>{
            clearTimeout(r),
            this.isScrolling || (this.stopRendering(),
            this.hideImage()),
            this.isScrolling = !0,
            r = setTimeout(()=>{
                this.isScrolling = !1
            }
            , 300)
        }
        ,
        this.mousemoveFn = n=>{
            this.mousePos = {
                x: n.clientX,
                y: n.clientY
            }
        }
        ,
        this.DOM.items.forEach((n,o)=>{
            const a = n.querySelector("img");
            a.addEventListener("mouseenter", ()=>this.mouseenterFn(o)),
            a.addEventListener("mouseleave", ()=>this.mouseleaveFn(o));
            const l = this.imagesData[o];
            new Image().src = l.url
        }
        ),
        window.addEventListener("scroll", this.windowScrollFn),
        window.addEventListener("mousemove", this.mousemoveFn)
    }
    ;
    handleBackground = ({url: t})=>{
        const e = document.createElement("img");
        e.className = "w-full h-full object-cover",
        e.lazy = "eager",
        e.src = t,
        this.DOM.inner.appendChild(e)
    }
    ;
    handleVideo = t=>{
        const e = document.createElement("video");
        e.autoplay = !0,
        e.loop = !0,
        e.muted = !0,
        e.playsInline = !0,
        e.disablePictureInPicture = !0,
        e.className = "w-full h-full object-cover",
        e.poster = t.url,
        this.DOM.inner.appendChild(e),
        e.src = t.video;
        var i = e.currentTime > 0 && !e.paused && !e.ended && e.readyState > 2;
        i || e.play()
    }
    ;
    showImage(t) {
        const e = this.imagesData[t]
          , [i,r] = QD(e.width / e.height);
        this.DOM.el.style.opacity = 1,
        this.DOM.el.style.backgroundColor = e.color,
        this.DOM.inner.innerHTML = null,
        N.set(this.DOM.inner, {
            width: i,
            height: r
        }),
        this.setBounds(),
        e.video ? this.handleVideo(e) : this.handleBackground(e)
    }
    hideImage() {
        this.DOM.el.style.opacity = 0
    }
    loopRender() {
        this.requestId || (this.requestId = requestAnimationFrame(this.render))
    }
    stopRendering() {
        this.requestId && (window.cancelAnimationFrame(this.requestId),
        this.requestId = void 0)
    }
    render = ()=>{
        this.requestId = void 0;
        const [t,e,i] = ZD(this.mousePos.x, this.mousePos.y, this.bounds.inner.width, this.bounds.inner.height, 0, 80);
        this.firstRAFCycle ? (this.hSetter(i, i),
        this.xSetter(t, t),
        this.ySetter(e, e)) : (this.hSetter(i),
        this.xSetter(t),
        this.ySetter(e)),
        this.firstRAFCycle = !1,
        this.loopRender()
    }
}
const tA = s=>{
    const t = {
        alt: null,
        copyright: null,
        url: s.dataset.img,
        id: s.dataset.imgId,
        dimensions: {
            width: 2e3,
            height: 1124
        },
        edit: {
            x: 0,
            y: 0,
            zoom: 1,
            background: "#fff"
        }
    };
    return {
        thumb: s.querySelector("img").srcset.split(" ")[0],
        url: YD(t, {
            width: Math.floor(window.innerWidth * .4)
        })
    }
}
;
class eA {
    constructor(t, e) {
        if (this.DOM = {
            container: document.querySelector(`.${t}`)
        },
        !this.DOM.container || (this.DOM.menuItems = [...this.DOM.container.querySelectorAll(`.${e}`)],
        !this.DOM.menuItems))
            return;
        const i = [...this.DOM.menuItems].map((r,n)=>{
            const o = tA(r);
            return {
                index: n,
                color: r.dataset.color,
                width: r.dataset.width,
                height: r.dataset.height,
                video: r.dataset.video,
                thumb: o.thumb,
                url: o.url,
                loaded: !1
            }
        }
        );
        this.filter = new KD(this.DOM.menuItems,i),
        this.cursor = new JD(this.DOM.menuItems,i)
    }
}
const iA = N.matchMedia()
  , Uf = 100
  , rA = [[{
    x: 16.2,
    y: 17.8
}, {
    x: 16.2,
    y: 67
}, {
    x: 0,
    y: 83
}, {
    x: 0,
    y: .5
}, {
    x: 83.8,
    y: .5
}, {
    x: 67,
    y: 17.8
}, {
    x: 16.2,
    y: 17.8
}], [{
    x: 84,
    y: 82.3
}, {
    x: 84,
    y: 33
}, {
    x: 100,
    y: 18
}, {
    x: 100,
    y: 100
}, {
    x: 16,
    y: 100
}, {
    x: 33.8,
    y: 82.3
}, {
    x: 84,
    y: 82.3
}]]
  , sA = [[{
    x: 50,
    y: 50
}, {
    x: 50,
    y: 50
}, {
    x: 0,
    y: 100
}, {
    x: 0,
    y: 0
}, {
    x: 100,
    y: 0
}, {
    x: 50,
    y: 50
}, {
    x: 50,
    y: 50
}], [{
    x: 50,
    y: 50
}, {
    x: 50,
    y: 50
}, {
    x: 100,
    y: 0
}, {
    x: 100,
    y: 100
}, {
    x: 0,
    y: 100
}, {
    x: 50,
    y: 50
}, {
    x: 50,
    y: 50
}]]
  , Go = {
    scale: .28,
    minWidth: 250,
    maxWidth: 500
}
  , Th = s=>{
    const t = window.innerWidth
      , e = window.innerHeight;
    return s ? (t > e ? t : e) / 100 : Qr(window.innerWidth * Go.scale, Go.minWidth, Go.maxWidth) / Uf
}
  , $0 = {
    duration: .4,
    ease: "power3.out"
};
class nA {
    constructor(t, e) {
        this.booted = !1,
        this.DOM = {
            canvas: e,
            container: t,
            header: document.getElementById("header")
        },
        this.DOM.canvas.setAttribute("data-speed", "1.2"),
        this.ctx = e.getContext("2d"),
        this.gelatinContainer = document.createElement("div"),
        this.label = document.createElement("div"),
        this.label.className = "text-white l2 fixed left-0 top-0 w-24 h-3 z-20 transition-transform duration-500 ease-out overflow-hidden pointer-events-none opacity-0",
        this.playLabel = document.createElement("div"),
        this.playLabel.classList.add("absolute", "left-0", "top-0", "hidden", "md:block"),
        this.playLabel.innerHTML = "( PLAY REEL )",
        this.exitLabel = document.createElement("div"),
        this.exitLabel.classList.add("absolute", "left-0", "top-0", "translate-y-full", "opacity-0"),
        this.exitLabel.innerHTML = "( EXIT REEL )",
        this.label.appendChild(this.playLabel),
        this.label.appendChild(this.exitLabel),
        document.querySelector("#home-hero").appendChild(this.label),
        this.gelatinMark = document.querySelector("#mask-container img"),
        this.mouse = this.mouseCache = this.animatedMouse = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2
        },
        this.xSetter = N.quickTo(this.mouse, "x", $0),
        this.ySetter = N.quickTo(this.mouse, "y", $0),
        this.bounds = {
            width: Uf,
            height: Uf
        }
    }
    initialAnimation() {
        this.open = !0,
        this.fromShape = rA,
        this.toShape = sA,
        this.scale = Th(!0),
        this.setupTimeline(),
        this.tl.progress(1);
        const t = Th(!1);
        N.to(this, {
            duration: 2,
            scale: t,
            ease: "expo.inOut",
            onComplete: ()=>{
                this.open = !1,
                this.booted = !0
            }
        }),
        this.tl.reverse()
    }
    setupTimeline = t=>{
        const e = {
            duration: 2,
            ease: "expo.inOut"
        };
        this.tl = N.timeline({
            paused: !0,
            defaults: e,
            ...t
        }),
        this.tl.to(this.playLabel, {
            y: "-100%",
            duration: 1
        }, 0),
        this.tl.to(this.exitLabel, {
            y: "0%",
            duration: 1
        }, 0),
        this.tl.to(this, {
            scale: Th(!0)
        }, 0),
        this.fromShape.forEach((i,r)=>{
            this.tl.to(i, {
                x: n=>this.toShape[r][n].x,
                y: n=>this.toShape[r][n].y
            }, 0)
        }
        )
    }
    ;
    initEvents = ({canvas: t})=>{
        let e = !1
          , i = !1
          , r = null;
        this.showLabel = ()=>{
            e = !0,
            N.to(this.label, {
                opacity: 1,
                duration: .3,
                delay: 1
            })
        }
        ,
        this.hideLabel = ()=>{
            e = !1,
            N.to(this.label, {
                opacity: 0,
                duration: .3
            })
        }
        ,
        this.mouseEnterFn = ()=>{
            clearTimeout(r),
            this.isInView || (this.isInView = !0),
            this.booted && this.showLabel()
        }
        ,
        this.mouseOutFn = ()=>{
            r = setTimeout(()=>{
                this.isInView = !1,
                this.xSetter(window.innerWidth / 2),
                this.ySetter(window.innerHeight / 2),
                this.hideLabel()
            }
            , 300)
        }
        ,
        this.DOM.header.querySelectorAll("ul li").forEach(o=>{
            o.id !== "header-logo" && (o.addEventListener("mouseenter", ()=>{
                i = !0,
                this.hideLabel()
            }
            ),
            o.addEventListener("mouseleave", ()=>{
                i = !1,
                this.showLabel()
            }
            ))
        }
        ),
        this.mouseMoveFn = o=>{
            if (this.mouseCache = {
                x: o.clientX,
                y: o.clientY
            },
            !e && this.booted && !i && this.showLabel(),
            this.isInView && this.booted && !this.open) {
                let a = Qr(window.innerWidth * Go.scale, Go.minWidth, Go.maxWidth) / 2;
                const l = Qr(o.clientX, a, window.innerWidth - a)
                  , h = Qr(o.clientY, a + this.DOM.header.clientHeight, window.innerHeight - a);
                this.xSetter(l),
                this.ySetter(h)
            }
        }
        ,
        iA.add(zi, ()=>{
            t.addEventListener("mouseleave", this.mouseOutFn),
            t.addEventListener("mouseenter", this.mouseEnterFn),
            window.addEventListener("mousemove", this.mouseMoveFn)
        }
        )
    }
    ;
    draw = ()=>{
        const t = this.open ? this.animatedMouse : this.mouse
          , e = this.bounds.width * this.scale / 2
          , i = this.bounds.height * this.scale / 2;
        this.label.style.transform = `translateX(${this.mouseCache.x + 25}px) translateY(${this.mouseCache.y + 25}px)`,
        this.gelatinMark.style.width = `${this.bounds.width * this.scale * 1.521}px`,
        this.gelatinMark.style.height = `${this.bounds.height * this.scale * 1.521}px`,
        this.gelatinMark.style.left = `${t.x - e * 1.521}px`,
        this.gelatinMark.style.top = `${t.y - i * 1.521}px`,
        this.ctx.fillStyle = "black",
        this.fromShape.forEach((r,n)=>{
            n === 0 && this.ctx.beginPath(),
            r.forEach((o,a)=>{
                const l = o.x * this.scale - e + t.x
                  , h = o.y * this.scale - i + t.y;
                a === 0 && this.ctx.moveTo(l, h),
                this.ctx.lineTo(l, h)
            }
            ),
            this.ctx.closePath()
        }
        ),
        this.ctx.fill("evenodd")
    }
    ;
    animateMouse = (t,e)=>{
        const i = {
            x: e ? window.innerWidth / 2 : this.mouseCache.x,
            y: e ? window.innerHeight / 2 : this.mouseCache.y
        };
        t.to(this.animatedMouse, {
            duration: 2,
            ease: "expo.out",
            x: i.x,
            y: i.y
        }, 0)
    }
    ;
    openShape = ()=>{
        this.setupTimeline(),
        this.open = !0;
        const t = N.timeline({
            paused: !0
        });
        this.animateMouse(t, !0),
        t.set(this.exitLabel, {
            opacity: 1
        }, 0),
        t.to(this.gelatinMark, {
            opacity: 0,
            duration: 1
        }, 0),
        t.play(),
        this.tl.play()
    }
    ;
    closeShape = ()=>{
        this.open = !1;
        const t = N.timeline({
            paused: !0
        });
        this.animateMouse(t, !1),
        t.set(this.exitLabel, {
            opacity: 0,
            delay: 2
        }, 0),
        t.to(this.gelatinMark, {
            opacity: 1,
            duration: 1
        }, 1),
        t.play(),
        this.tl.reverse()
    }
    ;
    reScale = (t,e=!1)=>{
        this.scale = Th(e),
        this.xSetter(window.innerWidth / 2),
        this.ySetter(window.innerHeight / 2)
    }
}
/*! npm.im/intrinsic-scale */
function oA(s) {
    return function(t, e, i, r) {
        var n = i / r
          , o = t / e
          , a = t
          , l = e;
        return (s ? n > o : n < o) ? l = a / n : a = l * n,
        {
            width: a,
            height: l,
            x: (t - a) / 2,
            y: (e - l) / 2
        }
    }
}
var aA = oA(!1);
const z0 = "/video/canvas_reel_preview_optimized.mp4"
  , Ix = "/video/canvas_reel_full_optimized.mp4";
class lA {
    constructor(t) {
        this.canvas = t,
        this.ctx = this.canvas.getContext("2d"),
        this.video = document.createElement("video"),
        this.video.loop = !0,
        this.video.muted = !0,
        this.video.playsInline = !0,
        this.video.autoplay = !0,
        this.video.onloadeddata = ()=>{
            this.setBounds(),
            this.videoLoaded = !0,
            this.video.play()
        }
        ,
        this.video.src = z0,
        this.volume = 0,
        this.scale = .7,
        this.bounds = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        },
        this.animating = !1,
        this.videoLoaded = !1
    }
    reScale = ()=>{
        this.setBounds()
    }
    ;
    setBounds = ()=>{
        const t = aA(this.canvas.width, this.canvas.height, 1920, 1080);
        this.bounds = {
            video: t
        }
    }
    ;
    open = ()=>{
        this.video.pause(),
        this.video.currentTime = 0,
        this.video.src = Ix,
        this.video.muted = !1,
        this.video.volume = 1,
        this.video.play()
    }
    ;
    close = ()=>{
        this.video.pause(),
        this.video.currentTime = 0,
        this.video.src = z0,
        this.video.muted = !0,
        this.video.play()
    }
    ;
    draw = ()=>{
        if (this.videoLoaded && !this.animating) {
            const {x: t, y: e, width: i, height: r} = this.bounds.video;
            this.ctx?.drawImage(this.video, t, e, i, r)
        }
        this.ctx?.restore()
    }
}
const Dh = N.matchMedia();
class hA {
    constructor() {
        this.isOpen = !1,
        this.DOM = {
            header: document.querySelector("header"),
            footer: document.querySelector(".hero-footer"),
            headerLogo: document.querySelector("#header-logo"),
            container: document.querySelector("#home-hero"),
            letters: document.querySelector("#hero__svg-logo"),
            lettersSVG: document.querySelector("#hero__svg-logo svg"),
            mobilePlayLabel: document.querySelector("#tap-to-play"),
            offCanvas: document.createElement("canvas"),
            canvas: document.createElement("canvas"),
            displacement: document.querySelector("#pixi-ani")
        },
        this.filters = {
            opacity: 0,
            blur: 10,
            grayscale: 100
        },
        this.DOM.canvas.id = "canvas",
        this.DOM.canvas.width = this.DOM.offCanvas.width = window.innerWidth,
        this.DOM.canvas.height = this.DOM.offCanvas.height = window.innerHeight,
        this.DOM.canvas.className = "absolute left-0 top-0 cursor-pointer z-20 focus:outline-none",
        this.DOM.canvas.role = "button",
        this.DOM.canvas.tabIndex = 0,
        this.DOM.canvas.ariaLabel = "Play Video",
        this.DOM.container.insertBefore(this.DOM.canvas, this.DOM.letters),
        this.ctx = this.DOM.canvas.getContext("2d"),
        this.DOM.offCanvas.id = "off-canvas",
        this.offCtx = this.DOM.offCanvas.getContext("2d"),
        this.background = new lA(this.DOM.offCanvas),
        this.logo = new nA(this.DOM.container,this.DOM.offCanvas),
        this.initListeners(),
        this.loopRender(),
        this.stopRendering = this.stopRendering.bind(this)
    }
    initListeners() {
        this.logo.initEvents(this.DOM);
        const t = N.matchMedia();
        this.windowResizeFn = ()=>{
            this.DOM.canvas.width = this.DOM.offCanvas.width = window.innerWidth,
            this.DOM.canvas.height = this.DOM.offCanvas.height = window.innerHeight,
            t.add(zi, ()=>{
                this.logo.reScale(this.DOM.offCanvas, this.isOpen),
                this.background.reScale()
            }
            )
        }
        ,
        this.onClickFn = ()=>{
            this.logo.booted && (this.isOpen = !this.isOpen,
            this.isOpen ? (Tm("Reel Open"),
            window.gtag("event", "reel_open"),
            this.open()) : this.close())
        }
        ,
        this.DOM.canvas.addEventListener("click", this.onClickFn),
        this.DOM.header.addEventListener("click", ()=>{
            this.isOpen && this.onClickFn()
        }
        ),
        window.addEventListener("resize", this.windowResizeFn),
        this.windowResizeFn()
    }
    loopRender = ()=>{
        this.requestId || (this.requestId = requestAnimationFrame(this.render))
    }
    ;
    stopRendering = ()=>{
        this.requestId && (window.cancelAnimationFrame(this.requestId),
        this.requestId = void 0)
    }
    ;
    render = ()=>{
        this.requestId = void 0,
        this.offCtx?.clearRect(0, 0, this.DOM.offCanvas.width, this.DOM.offCanvas.height),
        this.offCtx.save(),
        this.logo.draw(),
        this.offCtx.clip(),
        this.background?.draw(),
        this.ctx?.clearRect(0, 0, this.DOM.offCanvas.width, this.DOM.offCanvas.height),
        this.ctx.drawImage(this.DOM.offCanvas, 0, 0, window.innerWidth, window.innerHeight),
        this.ctx.filter = `grayscale(${this.filters.grayscale}%) blur(${this.filters.blur}px)`,
        this.ctx.globalAlpha = this.filters.opacity,
        this.loopRender()
    }
    ;
    createMobileVideo = ()=>{
        const t = document.createElement("video");
        t.classList.add("absolute", "pointer-events-none", "top-0", "left-0", "w-full", "h-full", "bg-pure-black", "flex", "items-center", "justify-center"),
        t.style.zIndex = 999,
        t.controls = !0,
        t.classList.add("w-full", "object-contain");
        const e = document.createElement("source");
        e.type = "video/mp4",
        e.src = Ix,
        t.appendChild(e),
        this.mobileVideo = t,
        this.mobileVideo.addEventListener("ended", this.close, !1),
        this.mobileVideo.addEventListener("click", this.close, !1),
        this.mobileVideo.addEventListener("webkitendfullscreen", this.close, !1),
        this.DOM.container.appendChild(this.mobileVideo)
    }
    ;
    open = ()=>{
        Dh.add("(min-width: 768px)", ()=>{
            bs(document.querySelector("body")),
            window.scrollTo({
                top: 0,
                behavior: "smooth"
            }),
            N.to(this.DOM.headerLogo, {
                opacity: 1,
                ease: "linear",
                duration: .3,
                delay: 1
            }),
            this.logo?.openShape(),
            this.background?.open(),
            N.set(this.DOM.displacement, {
                opacity: 0
            })
        }
        ),
        Dh.add("(max-width: 767px)", ()=>{
            this.background.video.pause(),
            this.mobileVideo ? this.DOM.container.appendChild(this.mobileVideo) : this.createMobileVideo(),
            this.mobileVideo.load(),
            this.mobileVideo.play()
        }
        )
    }
    ;
    close = ()=>{
        Dh.add("(min-width: 768px)", ()=>{
            Zn(),
            N.set(this.DOM.footer, {
                opacity: 1
            }),
            N.to(this.DOM.headerLogo, {
                opacity: 0,
                ease: "linear",
                duration: .3
            }),
            this.footerTl.pause(1),
            this.logo?.closeShape(),
            this.background?.close(),
            N.to(this.DOM.displacement, {
                opacity: 1,
                ease: "linear",
                duration: .3,
                delay: 1
            })
        }
        ),
        Dh.add("(max-width: 767px)", ()=>{
            this.DOM.container.removeChild(this.mobileVideo),
            this.isOpen = !1,
            this.mobileVideo.pause(),
            this.background.video.play()
        }
        )
    }
    ;
    setupAnimationLogo = ()=>{
        N.to(this.logo.gelatinMark, {
            delay: 1.5,
            opacity: 1,
            duration: 1
        })
    }
    ;
    setupAnimationFooter = ()=>{
        const t = N.timeline({
            delay: 1,
            paused: !0,
            defaults: {
                duration: .8
            }
        });
        t.set(this.DOM.footer, {
            opacity: 1
        }, 0),
        t.to(".hero-footer-line", {
            scaleX: 1
        }, 0),
        t.to(".hero-footer-logo", {
            opacity: 1
        }, 0),
        t.to(".hero-footer-1 > span", {
            y: "0%"
        }, 0),
        t.to(".hero-footer-2 > span", {
            y: "0%"
        }, .1),
        t.to(this.DOM.mobilePlayLabel, {
            y: 0,
            opacity: 1
        }, 0),
        N.utils.toArray(".hero-footer-spacer").forEach(i=>{
            t.to(i, {
                duration: 1,
                x: "0em"
            }, .4)
        }
        ),
        t.to(".modal-button", {
            y: 0
        }, 0),
        this.footerTl = t
    }
    ;
    setupFiltersAnimation = ()=>{
        const t = N.timeline({
            paused: !0,
            defaults: {
                ease: Je.mask
            }
        });
        t.to(this.filters, {
            opacity: 1,
            duration: 1
        }, 0),
        t.to(this.filters, {
            grayscale: 0,
            duration: 2
        }, 0),
        t.to(this.filters, {
            blur: 0,
            duration: 2
        }, 0),
        this.filtersTl = t
    }
    ;
    initialAnimation = ()=>{
        this.setupFiltersAnimation(),
        this.setupAnimationLogo(),
        this.setupAnimationFooter(),
        this.logo.initialAnimation(),
        this.filtersTl.play(),
        this.footerTl.play(),
        N.to(this.DOM.displacement, {
            opacity: 1,
            delay: 2
        })
    }
}
function uA(s) {
    const t = N.utils.toArray(s)
      , e = new ResizeObserver(r=>{
        mt.refresh()
    }
    );
    N.matchMedia().add("(min-width: 768px)", ()=>{
        if (t) {
            const r = N.utils.toArray("#project-pin .project-bg")
              , n = N.utils.toArray("#project-pin .project-info");
            r.forEach((o,a)=>{
                N.set(o, {
                    zIndex: r.length - a,
                    clipPath: "polygon(0% 0, 100% 0, 100% 100%, 0% 100%)"
                });
                const l = t[a];
                if (e.observe(l),
                a > 0) {
                    const h = window.innerHeight * .1
                      , u = o.querySelector("img")
                      , d = new WebKitCSSMatrix(u.style.transform).m42;
                    N.set(u, {
                        y: `+=${h}`
                    }),
                    N.to(u, {
                        y: d,
                        ease: "none",
                        scrollTrigger: {
                            trigger: l,
                            start: ()=>"top bottom",
                            end: ()=>"+=100%",
                            scrub: !0
                        }
                    })
                }
                a < r.length - 1 && N.to(o, {
                    duration: 1,
                    ease: "none",
                    y: `-=${window.innerHeight * .1}`,
                    clipPath: "polygon(0% 0%, 100% 0%, 100% 0%, 0% 0%)",
                    scrollTrigger: {
                        trigger: l,
                        start: ()=>"bottom bottom",
                        end: ()=>"+=100%",
                        scrub: !0
                    }
                })
            }
            ),
            n.forEach((o,a)=>{
                if (a > 0) {
                    const l = n[a - 1];
                    N.timeline({
                        paused: !0,
                        defaults: {
                            ease: "none",
                            duration: .8
                        },
                        scrollTrigger: {
                            start: ()=>"top 230px",
                            end: ()=>"+=230px",
                            trigger: t[a],
                            scrub: !0,
                            invalidateOnRefresh: !0
                        }
                    }).to(o.querySelector(".wt-home-title"), {
                        y: 0
                    }, 0).to(o.querySelector(".wt-home-subtitle"), {
                        y: 0
                    }, 0).to(o.querySelector(".wt-home-number"), {
                        y: 0
                    }, 0).to(l.querySelector(".wt-home-title"), {
                        y: -50
                    }, 0).to(l.querySelector(".wt-home-subtitle"), {
                        y: -50
                    }, 0).to(l.querySelector(".wt-home-number"), {
                        y: -50
                    }, 0)
                }
            }
            ),
            mt.create({
                trigger: "#projects",
                start: "top top",
                end: "bottom bottom",
                pin: "#project-pin"
            })
        }
    }
    )
}
var rn = (s=>(s[s.WEBGL_LEGACY = 0] = "WEBGL_LEGACY",
s[s.WEBGL = 1] = "WEBGL",
s[s.WEBGL2 = 2] = "WEBGL2",
s))(rn || {})
  , Dm = (s=>(s[s.UNKNOWN = 0] = "UNKNOWN",
s[s.WEBGL = 1] = "WEBGL",
s[s.CANVAS = 2] = "CANVAS",
s))(Dm || {})
  , ju = (s=>(s[s.COLOR = 16384] = "COLOR",
s[s.DEPTH = 256] = "DEPTH",
s[s.STENCIL = 1024] = "STENCIL",
s))(ju || {})
  , _t = (s=>(s[s.NORMAL = 0] = "NORMAL",
s[s.ADD = 1] = "ADD",
s[s.MULTIPLY = 2] = "MULTIPLY",
s[s.SCREEN = 3] = "SCREEN",
s[s.OVERLAY = 4] = "OVERLAY",
s[s.DARKEN = 5] = "DARKEN",
s[s.LIGHTEN = 6] = "LIGHTEN",
s[s.COLOR_DODGE = 7] = "COLOR_DODGE",
s[s.COLOR_BURN = 8] = "COLOR_BURN",
s[s.HARD_LIGHT = 9] = "HARD_LIGHT",
s[s.SOFT_LIGHT = 10] = "SOFT_LIGHT",
s[s.DIFFERENCE = 11] = "DIFFERENCE",
s[s.EXCLUSION = 12] = "EXCLUSION",
s[s.HUE = 13] = "HUE",
s[s.SATURATION = 14] = "SATURATION",
s[s.COLOR = 15] = "COLOR",
s[s.LUMINOSITY = 16] = "LUMINOSITY",
s[s.NORMAL_NPM = 17] = "NORMAL_NPM",
s[s.ADD_NPM = 18] = "ADD_NPM",
s[s.SCREEN_NPM = 19] = "SCREEN_NPM",
s[s.NONE = 20] = "NONE",
s[s.SRC_OVER = 0] = "SRC_OVER",
s[s.SRC_IN = 21] = "SRC_IN",
s[s.SRC_OUT = 22] = "SRC_OUT",
s[s.SRC_ATOP = 23] = "SRC_ATOP",
s[s.DST_OVER = 24] = "DST_OVER",
s[s.DST_IN = 25] = "DST_IN",
s[s.DST_OUT = 26] = "DST_OUT",
s[s.DST_ATOP = 27] = "DST_ATOP",
s[s.ERASE = 26] = "ERASE",
s[s.SUBTRACT = 28] = "SUBTRACT",
s[s.XOR = 29] = "XOR",
s))(_t || {})
  , xr = (s=>(s[s.POINTS = 0] = "POINTS",
s[s.LINES = 1] = "LINES",
s[s.LINE_LOOP = 2] = "LINE_LOOP",
s[s.LINE_STRIP = 3] = "LINE_STRIP",
s[s.TRIANGLES = 4] = "TRIANGLES",
s[s.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP",
s[s.TRIANGLE_FAN = 6] = "TRIANGLE_FAN",
s))(xr || {})
  , J = (s=>(s[s.RGBA = 6408] = "RGBA",
s[s.RGB = 6407] = "RGB",
s[s.RG = 33319] = "RG",
s[s.RED = 6403] = "RED",
s[s.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
s[s.RGB_INTEGER = 36248] = "RGB_INTEGER",
s[s.RG_INTEGER = 33320] = "RG_INTEGER",
s[s.RED_INTEGER = 36244] = "RED_INTEGER",
s[s.ALPHA = 6406] = "ALPHA",
s[s.LUMINANCE = 6409] = "LUMINANCE",
s[s.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
s[s.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
s[s.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
s))(J || {})
  , On = (s=>(s[s.TEXTURE_2D = 3553] = "TEXTURE_2D",
s[s.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
s[s.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
s[s.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
s[s.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
s[s.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
s[s.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
s[s.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
s[s.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
s))(On || {})
  , ft = (s=>(s[s.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
s[s.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
s[s.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
s[s.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
s[s.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
s[s.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
s[s.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
s[s.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
s[s.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
s[s.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
s[s.BYTE = 5120] = "BYTE",
s[s.SHORT = 5122] = "SHORT",
s[s.INT = 5124] = "INT",
s[s.FLOAT = 5126] = "FLOAT",
s[s.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
s[s.HALF_FLOAT = 36193] = "HALF_FLOAT",
s))(ft || {})
  , rt = (s=>(s[s.FLOAT = 0] = "FLOAT",
s[s.INT = 1] = "INT",
s[s.UINT = 2] = "UINT",
s))(rt || {})
  , Wr = (s=>(s[s.NEAREST = 0] = "NEAREST",
s[s.LINEAR = 1] = "LINEAR",
s))(Wr || {})
  , Jr = (s=>(s[s.CLAMP = 33071] = "CLAMP",
s[s.REPEAT = 10497] = "REPEAT",
s[s.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
s))(Jr || {})
  , Ar = (s=>(s[s.OFF = 0] = "OFF",
s[s.POW2 = 1] = "POW2",
s[s.ON = 2] = "ON",
s[s.ON_MANUAL = 3] = "ON_MANUAL",
s))(Ar || {})
  , _i = (s=>(s[s.NPM = 0] = "NPM",
s[s.UNPACK = 1] = "UNPACK",
s[s.PMA = 2] = "PMA",
s[s.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA",
s[s.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD",
s[s.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA",
s))(_i || {})
  , yr = (s=>(s[s.NO = 0] = "NO",
s[s.YES = 1] = "YES",
s[s.AUTO = 2] = "AUTO",
s[s.BLEND = 0] = "BLEND",
s[s.CLEAR = 1] = "CLEAR",
s[s.BLIT = 2] = "BLIT",
s))(yr || {})
  , Ac = (s=>(s[s.AUTO = 0] = "AUTO",
s[s.MANUAL = 1] = "MANUAL",
s))(Ac || {})
  , Hi = (s=>(s.LOW = "lowp",
s.MEDIUM = "mediump",
s.HIGH = "highp",
s))(Hi || {})
  , ve = (s=>(s[s.NONE = 0] = "NONE",
s[s.SCISSOR = 1] = "SCISSOR",
s[s.STENCIL = 2] = "STENCIL",
s[s.SPRITE = 3] = "SPRITE",
s[s.COLOR = 4] = "COLOR",
s))(ve || {})
  , Rx = (s=>(s[s.RED = 1] = "RED",
s[s.GREEN = 2] = "GREEN",
s[s.BLUE = 4] = "BLUE",
s[s.ALPHA = 8] = "ALPHA",
s))(Rx || {})
  , ge = (s=>(s[s.NONE = 0] = "NONE",
s[s.LOW = 2] = "LOW",
s[s.MEDIUM = 4] = "MEDIUM",
s[s.HIGH = 8] = "HIGH",
s))(ge || {})
  , Er = (s=>(s[s.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
s[s.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
s[s.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
s))(Er || {});
const Mx = {
    createCanvas: (s,t)=>{
        const e = document.createElement("canvas");
        return e.width = s,
        e.height = t,
        e
    }
    ,
    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
    getWebGLRenderingContext: ()=>WebGLRenderingContext,
    getNavigator: ()=>navigator,
    getBaseUrl: ()=>document.baseURI ?? window.location.href,
    getFontFaceSet: ()=>document.fonts,
    fetch: (s,t)=>fetch(s, t),
    parseXML: s=>new DOMParser().parseFromString(s, "text/xml")
}
  , nt = {
    ADAPTER: Mx,
    RESOLUTION: 1,
    CREATE_IMAGE_BITMAP: !1,
    ROUND_PIXELS: !1
};
var gd = /iPhone/i
  , V0 = /iPod/i
  , X0 = /iPad/i
  , W0 = /\biOS-universal(?:.+)Mac\b/i
  , _d = /\bAndroid(?:.+)Mobile\b/i
  , j0 = /Android/i
  , so = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
  , Ah = /Silk/i
  , ss = /Windows Phone/i
  , q0 = /\bWindows(?:.+)ARM\b/i
  , Y0 = /BlackBerry/i
  , K0 = /BB10/i
  , Z0 = /Opera Mini/i
  , Q0 = /\b(CriOS|Chrome)(?:.+)Mobile/i
  , J0 = /Mobile(?:.+)Firefox\b/i
  , t_ = function(s) {
    return typeof s < "u" && s.platform === "MacIntel" && typeof s.maxTouchPoints == "number" && s.maxTouchPoints > 1 && typeof MSStream > "u"
};
function cA(s) {
    return function(t) {
        return t.test(s)
    }
}
function e_(s) {
    var t = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !s && typeof navigator < "u" ? t = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof s == "string" ? t.userAgent = s : s && s.userAgent && (t = {
        userAgent: s.userAgent,
        platform: s.platform,
        maxTouchPoints: s.maxTouchPoints || 0
    });
    var e = t.userAgent
      , i = e.split("[FBAN");
    typeof i[1] < "u" && (e = i[0]),
    i = e.split("Twitter"),
    typeof i[1] < "u" && (e = i[0]);
    var r = cA(e)
      , n = {
        apple: {
            phone: r(gd) && !r(ss),
            ipod: r(V0),
            tablet: !r(gd) && (r(X0) || t_(t)) && !r(ss),
            universal: r(W0),
            device: (r(gd) || r(V0) || r(X0) || r(W0) || t_(t)) && !r(ss)
        },
        amazon: {
            phone: r(so),
            tablet: !r(so) && r(Ah),
            device: r(so) || r(Ah)
        },
        android: {
            phone: !r(ss) && r(so) || !r(ss) && r(_d),
            tablet: !r(ss) && !r(so) && !r(_d) && (r(Ah) || r(j0)),
            device: !r(ss) && (r(so) || r(Ah) || r(_d) || r(j0)) || r(/\bokhttp\b/i)
        },
        windows: {
            phone: r(ss),
            tablet: r(q0),
            device: r(ss) || r(q0)
        },
        other: {
            blackberry: r(Y0),
            blackberry10: r(K0),
            opera: r(Z0),
            firefox: r(J0),
            chrome: r(Q0),
            device: r(Y0) || r(K0) || r(Z0) || r(J0) || r(Q0)
        },
        any: !1,
        phone: !1,
        tablet: !1
    };
    return n.any = n.apple.device || n.android.device || n.windows.device || n.other.device,
    n.phone = n.apple.phone || n.android.phone || n.windows.phone,
    n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet,
    n
}
const dA = e_.default ?? e_
  , br = dA(globalThis.navigator);
nt.RETINA_PREFIX = /@([0-9\.]+)x/;
nt.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var Fx = {
    exports: {}
};
(function(s) {
    var t = Object.prototype.hasOwnProperty
      , e = "~";
    function i() {}
    Object.create && (i.prototype = Object.create(null),
    new i().__proto__ || (e = !1));
    function r(l, h, u) {
        this.fn = l,
        this.context = h,
        this.once = u || !1
    }
    function n(l, h, u, c, d) {
        if (typeof u != "function")
            throw new TypeError("The listener must be a function");
        var f = new r(u,c || l,d)
          , p = e ? e + h : h;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f,
        l._eventsCount++),
        l
    }
    function o(l, h) {
        --l._eventsCount === 0 ? l._events = new i : delete l._events[h]
    }
    function a() {
        this._events = new i,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var h = [], u, c;
        if (this._eventsCount === 0)
            return h;
        for (c in u = this._events)
            t.call(u, c) && h.push(e ? c.slice(1) : c);
        return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(u)) : h
    }
    ,
    a.prototype.listeners = function(h) {
        var u = e ? e + h : h
          , c = this._events[u];
        if (!c)
            return [];
        if (c.fn)
            return [c.fn];
        for (var d = 0, f = c.length, p = new Array(f); d < f; d++)
            p[d] = c[d].fn;
        return p
    }
    ,
    a.prototype.listenerCount = function(h) {
        var u = e ? e + h : h
          , c = this._events[u];
        return c ? c.fn ? 1 : c.length : 0
    }
    ,
    a.prototype.emit = function(h, u, c, d, f, p) {
        var m = e ? e + h : h;
        if (!this._events[m])
            return !1;
        var g = this._events[m], _ = arguments.length, x, y;
        if (g.fn) {
            switch (g.once && this.removeListener(h, g.fn, void 0, !0),
            _) {
            case 1:
                return g.fn.call(g.context),
                !0;
            case 2:
                return g.fn.call(g.context, u),
                !0;
            case 3:
                return g.fn.call(g.context, u, c),
                !0;
            case 4:
                return g.fn.call(g.context, u, c, d),
                !0;
            case 5:
                return g.fn.call(g.context, u, c, d, f),
                !0;
            case 6:
                return g.fn.call(g.context, u, c, d, f, p),
                !0
            }
            for (y = 1,
            x = new Array(_ - 1); y < _; y++)
                x[y - 1] = arguments[y];
            g.fn.apply(g.context, x)
        } else {
            var v = g.length, E;
            for (y = 0; y < v; y++)
                switch (g[y].once && this.removeListener(h, g[y].fn, void 0, !0),
                _) {
                case 1:
                    g[y].fn.call(g[y].context);
                    break;
                case 2:
                    g[y].fn.call(g[y].context, u);
                    break;
                case 3:
                    g[y].fn.call(g[y].context, u, c);
                    break;
                case 4:
                    g[y].fn.call(g[y].context, u, c, d);
                    break;
                default:
                    if (!x)
                        for (E = 1,
                        x = new Array(_ - 1); E < _; E++)
                            x[E - 1] = arguments[E];
                    g[y].fn.apply(g[y].context, x)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(h, u, c) {
        return n(this, h, u, c, !1)
    }
    ,
    a.prototype.once = function(h, u, c) {
        return n(this, h, u, c, !0)
    }
    ,
    a.prototype.removeListener = function(h, u, c, d) {
        var f = e ? e + h : h;
        if (!this._events[f])
            return this;
        if (!u)
            return o(this, f),
            this;
        var p = this._events[f];
        if (p.fn)
            p.fn === u && (!d || p.once) && (!c || p.context === c) && o(this, f);
        else {
            for (var m = 0, g = [], _ = p.length; m < _; m++)
                (p[m].fn !== u || d && !p[m].once || c && p[m].context !== c) && g.push(p[m]);
            g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(h) {
        var u;
        return h ? (u = e ? e + h : h,
        this._events[u] && o(this, u)) : (this._events = new i,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = e,
    a.EventEmitter = a,
    s.exports = a
}
)(Fx);
var fA = Fx.exports;
const na = um(fA);
var Am = {
    exports: {}
};
Am.exports = Sc;
Am.exports.default = Sc;
function Sc(s, t, e) {
    e = e || 2;
    var i = t && t.length
      , r = i ? t[0] * e : s.length
      , n = Bx(s, 0, r, e, !0)
      , o = [];
    if (!n || n.next === n.prev)
        return o;
    var a, l, h, u, c, d, f;
    if (i && (n = yA(s, t, n, e)),
    s.length > 80 * e) {
        a = h = s[0],
        l = u = s[1];
        for (var p = e; p < r; p += e)
            c = s[p],
            d = s[p + 1],
            c < a && (a = c),
            d < l && (l = d),
            c > h && (h = c),
            d > u && (u = d);
        f = Math.max(h - a, u - l),
        f = f !== 0 ? 32767 / f : 0
    }
    return Cl(n, o, e, a, l, f, 0),
    o
}
function Bx(s, t, e, i, r) {
    var n, o;
    if (r === $f(s, t, e, i) > 0)
        for (n = t; n < e; n += i)
            o = i_(n, s[n], s[n + 1], o);
    else
        for (n = e - i; n >= t; n -= i)
            o = i_(n, s[n], s[n + 1], o);
    return o && Cc(o, o.next) && (Il(o),
    o = o.next),
    o
}
function Yn(s, t) {
    if (!s)
        return s;
    t || (t = s);
    var e = s, i;
    do
        if (i = !1,
        !e.steiner && (Cc(e, e.next) || ue(e.prev, e, e.next) === 0)) {
            if (Il(e),
            e = t = e.prev,
            e === e.next)
                break;
            i = !0
        } else
            e = e.next;
    while (i || e !== t);
    return t
}
function Cl(s, t, e, i, r, n, o) {
    if (s) {
        !o && n && EA(s, i, r, n);
        for (var a = s, l, h; s.prev !== s.next; ) {
            if (l = s.prev,
            h = s.next,
            n ? mA(s, i, r, n) : pA(s)) {
                t.push(l.i / e | 0),
                t.push(s.i / e | 0),
                t.push(h.i / e | 0),
                Il(s),
                s = h.next,
                a = h.next;
                continue
            }
            if (s = h,
            s === a) {
                o ? o === 1 ? (s = gA(Yn(s), t, e),
                Cl(s, t, e, i, r, n, 2)) : o === 2 && _A(s, t, e, i, r, n) : Cl(Yn(s), t, e, i, r, n, 1);
                break
            }
        }
    }
}
function pA(s) {
    var t = s.prev
      , e = s
      , i = s.next;
    if (ue(t, e, i) >= 0)
        return !1;
    for (var r = t.x, n = e.x, o = i.x, a = t.y, l = e.y, h = i.y, u = r < n ? r < o ? r : o : n < o ? n : o, c = a < l ? a < h ? a : h : l < h ? l : h, d = r > n ? r > o ? r : o : n > o ? n : o, f = a > l ? a > h ? a : h : l > h ? l : h, p = i.next; p !== t; ) {
        if (p.x >= u && p.x <= d && p.y >= c && p.y <= f && Io(r, a, n, l, o, h, p.x, p.y) && ue(p.prev, p, p.next) >= 0)
            return !1;
        p = p.next
    }
    return !0
}
function mA(s, t, e, i) {
    var r = s.prev
      , n = s
      , o = s.next;
    if (ue(r, n, o) >= 0)
        return !1;
    for (var a = r.x, l = n.x, h = o.x, u = r.y, c = n.y, d = o.y, f = a < l ? a < h ? a : h : l < h ? l : h, p = u < c ? u < d ? u : d : c < d ? c : d, m = a > l ? a > h ? a : h : l > h ? l : h, g = u > c ? u > d ? u : d : c > d ? c : d, _ = Gf(f, p, t, e, i), x = Gf(m, g, t, e, i), y = s.prevZ, v = s.nextZ; y && y.z >= _ && v && v.z <= x; ) {
        if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== r && y !== o && Io(a, u, l, c, h, d, y.x, y.y) && ue(y.prev, y, y.next) >= 0 || (y = y.prevZ,
        v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== r && v !== o && Io(a, u, l, c, h, d, v.x, v.y) && ue(v.prev, v, v.next) >= 0))
            return !1;
        v = v.nextZ
    }
    for (; y && y.z >= _; ) {
        if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== r && y !== o && Io(a, u, l, c, h, d, y.x, y.y) && ue(y.prev, y, y.next) >= 0)
            return !1;
        y = y.prevZ
    }
    for (; v && v.z <= x; ) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== r && v !== o && Io(a, u, l, c, h, d, v.x, v.y) && ue(v.prev, v, v.next) >= 0)
            return !1;
        v = v.nextZ
    }
    return !0
}
function gA(s, t, e) {
    var i = s;
    do {
        var r = i.prev
          , n = i.next.next;
        !Cc(r, n) && Ox(r, i, i.next, n) && Pl(r, n) && Pl(n, r) && (t.push(r.i / e | 0),
        t.push(i.i / e | 0),
        t.push(n.i / e | 0),
        Il(i),
        Il(i.next),
        i = s = n),
        i = i.next
    } while (i !== s);
    return Yn(i)
}
function _A(s, t, e, i, r, n) {
    var o = s;
    do {
        for (var a = o.next.next; a !== o.prev; ) {
            if (o.i !== a.i && AA(o, a)) {
                var l = kx(o, a);
                o = Yn(o, o.next),
                l = Yn(l, l.next),
                Cl(o, t, e, i, r, n, 0),
                Cl(l, t, e, i, r, n, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== s)
}
function yA(s, t, e, i) {
    var r = [], n, o, a, l, h;
    for (n = 0,
    o = t.length; n < o; n++)
        a = t[n] * i,
        l = n < o - 1 ? t[n + 1] * i : s.length,
        h = Bx(s, a, l, i, !1),
        h === h.next && (h.steiner = !0),
        r.push(DA(h));
    for (r.sort(vA),
    n = 0; n < r.length; n++)
        e = xA(r[n], e);
    return e
}
function vA(s, t) {
    return s.x - t.x
}
function xA(s, t) {
    var e = bA(s, t);
    if (!e)
        return t;
    var i = kx(e, s);
    return Yn(i, i.next),
    Yn(e, e.next)
}
function bA(s, t) {
    var e = t, i = s.x, r = s.y, n = -1 / 0, o;
    do {
        if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
            var a = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
            if (a <= i && a > n && (n = a,
            o = e.x < e.next.x ? e : e.next,
            a === i))
                return o
        }
        e = e.next
    } while (e !== t);
    if (!o)
        return null;
    var l = o, h = o.x, u = o.y, c = 1 / 0, d;
    e = o;
    do
        i >= e.x && e.x >= h && i !== e.x && Io(r < u ? i : n, r, h, u, r < u ? n : i, r, e.x, e.y) && (d = Math.abs(r - e.y) / (i - e.x),
        Pl(e, s) && (d < c || d === c && (e.x > o.x || e.x === o.x && wA(o, e))) && (o = e,
        c = d)),
        e = e.next;
    while (e !== l);
    return o
}
function wA(s, t) {
    return ue(s.prev, s, t.prev) < 0 && ue(t.next, s, s.next) < 0
}
function EA(s, t, e, i) {
    var r = s;
    do
        r.z === 0 && (r.z = Gf(r.x, r.y, t, e, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== s);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    TA(r)
}
function TA(s) {
    var t, e, i, r, n, o, a, l, h = 1;
    do {
        for (e = s,
        s = null,
        n = null,
        o = 0; e; ) {
            for (o++,
            i = e,
            a = 0,
            t = 0; t < h && (a++,
            i = i.nextZ,
            !!i); t++)
                ;
            for (l = h; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || e.z <= i.z) ? (r = e,
                e = e.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                l--),
                n ? n.nextZ = r : s = r,
                r.prevZ = n,
                n = r;
            e = i
        }
        n.nextZ = null,
        h *= 2
    } while (o > 1);
    return s
}
function Gf(s, t, e, i, r) {
    return s = (s - e) * r | 0,
    t = (t - i) * r | 0,
    s = (s | s << 8) & 16711935,
    s = (s | s << 4) & 252645135,
    s = (s | s << 2) & 858993459,
    s = (s | s << 1) & 1431655765,
    t = (t | t << 8) & 16711935,
    t = (t | t << 4) & 252645135,
    t = (t | t << 2) & 858993459,
    t = (t | t << 1) & 1431655765,
    s | t << 1
}
function DA(s) {
    var t = s
      , e = s;
    do
        (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t),
        t = t.next;
    while (t !== s);
    return e
}
function Io(s, t, e, i, r, n, o, a) {
    return (r - o) * (t - a) >= (s - o) * (n - a) && (s - o) * (i - a) >= (e - o) * (t - a) && (e - o) * (n - a) >= (r - o) * (i - a)
}
function AA(s, t) {
    return s.next.i !== t.i && s.prev.i !== t.i && !SA(s, t) && (Pl(s, t) && Pl(t, s) && CA(s, t) && (ue(s.prev, s, t.prev) || ue(s, t.prev, t)) || Cc(s, t) && ue(s.prev, s, s.next) > 0 && ue(t.prev, t, t.next) > 0)
}
function ue(s, t, e) {
    return (t.y - s.y) * (e.x - t.x) - (t.x - s.x) * (e.y - t.y)
}
function Cc(s, t) {
    return s.x === t.x && s.y === t.y
}
function Ox(s, t, e, i) {
    var r = Ch(ue(s, t, e))
      , n = Ch(ue(s, t, i))
      , o = Ch(ue(e, i, s))
      , a = Ch(ue(e, i, t));
    return !!(r !== n && o !== a || r === 0 && Sh(s, e, t) || n === 0 && Sh(s, i, t) || o === 0 && Sh(e, s, i) || a === 0 && Sh(e, t, i))
}
function Sh(s, t, e) {
    return t.x <= Math.max(s.x, e.x) && t.x >= Math.min(s.x, e.x) && t.y <= Math.max(s.y, e.y) && t.y >= Math.min(s.y, e.y)
}
function Ch(s) {
    return s > 0 ? 1 : s < 0 ? -1 : 0
}
function SA(s, t) {
    var e = s;
    do {
        if (e.i !== s.i && e.next.i !== s.i && e.i !== t.i && e.next.i !== t.i && Ox(e, e.next, s, t))
            return !0;
        e = e.next
    } while (e !== s);
    return !1
}
function Pl(s, t) {
    return ue(s.prev, s, s.next) < 0 ? ue(s, t, s.next) >= 0 && ue(s, s.prev, t) >= 0 : ue(s, t, s.prev) < 0 || ue(s, s.next, t) < 0
}
function CA(s, t) {
    var e = s
      , i = !1
      , r = (s.x + t.x) / 2
      , n = (s.y + t.y) / 2;
    do
        e.y > n != e.next.y > n && e.next.y !== e.y && r < (e.next.x - e.x) * (n - e.y) / (e.next.y - e.y) + e.x && (i = !i),
        e = e.next;
    while (e !== s);
    return i
}
function kx(s, t) {
    var e = new Hf(s.i,s.x,s.y)
      , i = new Hf(t.i,t.x,t.y)
      , r = s.next
      , n = t.prev;
    return s.next = t,
    t.prev = s,
    e.next = r,
    r.prev = e,
    i.next = e,
    e.prev = i,
    n.next = i,
    i.prev = n,
    i
}
function i_(s, t, e, i) {
    var r = new Hf(s,t,e);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function Il(s) {
    s.next.prev = s.prev,
    s.prev.next = s.next,
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ)
}
function Hf(s, t, e) {
    this.i = s,
    this.x = t,
    this.y = e,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
Sc.deviation = function(s, t, e, i) {
    var r = t && t.length
      , n = r ? t[0] * e : s.length
      , o = Math.abs($f(s, 0, n, e));
    if (r)
        for (var a = 0, l = t.length; a < l; a++) {
            var h = t[a] * e
              , u = a < l - 1 ? t[a + 1] * e : s.length;
            o -= Math.abs($f(s, h, u, e))
        }
    var c = 0;
    for (a = 0; a < i.length; a += 3) {
        var d = i[a] * e
          , f = i[a + 1] * e
          , p = i[a + 2] * e;
        c += Math.abs((s[d] - s[p]) * (s[f + 1] - s[d + 1]) - (s[d] - s[f]) * (s[p + 1] - s[d + 1]))
    }
    return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o)
}
;
function $f(s, t, e, i) {
    for (var r = 0, n = t, o = e - i; n < e; n += i)
        r += (s[o] - s[n]) * (s[n + 1] + s[o + 1]),
        o = n;
    return r
}
Sc.flatten = function(s) {
    for (var t = s[0][0].length, e = {
        vertices: [],
        holes: [],
        dimensions: t
    }, i = 0, r = 0; r < s.length; r++) {
        for (var n = 0; n < s[r].length; n++)
            for (var o = 0; o < t; o++)
                e.vertices.push(s[r][n][o]);
        r > 0 && (i += s[r - 1].length,
        e.holes.push(i))
    }
    return e
}
;
var PA = Am.exports;
const Lx = um(PA);
var qu = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */
qu.exports;
(function(s, t) {
    (function(e) {
        var i = t && !t.nodeType && t
          , r = s && !s.nodeType && s
          , n = typeof rl == "object" && rl;
        (n.global === n || n.window === n || n.self === n) && (e = n);
        var o, a = 2147483647, l = 36, h = 1, u = 26, c = 38, d = 700, f = 72, p = 128, m = "-", g = /^xn--/, _ = /[^\x20-\x7E]/, x = /[\x2E\u3002\uFF0E\uFF61]/g, y = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, v = l - h, E = Math.floor, P = String.fromCharCode, w;
        function A(b) {
            throw new RangeError(y[b])
        }
        function I(b, L) {
            for (var U = b.length, Y = []; U--; )
                Y[U] = L(b[U]);
            return Y
        }
        function F(b, L) {
            var U = b.split("@")
              , Y = "";
            U.length > 1 && (Y = U[0] + "@",
            b = U[1]),
            b = b.replace(x, ".");
            var $ = b.split(".")
              , z = I($, L).join(".");
            return Y + z
        }
        function O(b) {
            for (var L = [], U = 0, Y = b.length, $, z; U < Y; )
                $ = b.charCodeAt(U++),
                $ >= 55296 && $ <= 56319 && U < Y ? (z = b.charCodeAt(U++),
                (z & 64512) == 56320 ? L.push((($ & 1023) << 10) + (z & 1023) + 65536) : (L.push($),
                U--)) : L.push($);
            return L
        }
        function B(b) {
            return I(b, function(L) {
                var U = "";
                return L > 65535 && (L -= 65536,
                U += P(L >>> 10 & 1023 | 55296),
                L = 56320 | L & 1023),
                U += P(L),
                U
            }).join("")
        }
        function S(b) {
            return b - 48 < 10 ? b - 22 : b - 65 < 26 ? b - 65 : b - 97 < 26 ? b - 97 : l
        }
        function T(b, L) {
            return b + 22 + 75 * (b < 26) - ((L != 0) << 5)
        }
        function M(b, L, U) {
            var Y = 0;
            for (b = U ? E(b / d) : b >> 1,
            b += E(b / L); b > v * u >> 1; Y += l)
                b = E(b / v);
            return E(Y + (v + 1) * b / (b + c))
        }
        function D(b) {
            var L = [], U = b.length, Y, $ = 0, z = p, j = f, W, X, et, Q, q, tt, Z, ot, vt;
            for (W = b.lastIndexOf(m),
            W < 0 && (W = 0),
            X = 0; X < W; ++X)
                b.charCodeAt(X) >= 128 && A("not-basic"),
                L.push(b.charCodeAt(X));
            for (et = W > 0 ? W + 1 : 0; et < U; ) {
                for (Q = $,
                q = 1,
                tt = l; et >= U && A("invalid-input"),
                Z = S(b.charCodeAt(et++)),
                (Z >= l || Z > E((a - $) / q)) && A("overflow"),
                $ += Z * q,
                ot = tt <= j ? h : tt >= j + u ? u : tt - j,
                !(Z < ot); tt += l)
                    vt = l - ot,
                    q > E(a / vt) && A("overflow"),
                    q *= vt;
                Y = L.length + 1,
                j = M($ - Q, Y, Q == 0),
                E($ / Y) > a - z && A("overflow"),
                z += E($ / Y),
                $ %= Y,
                L.splice($++, 0, z)
            }
            return B(L)
        }
        function C(b) {
            var L, U, Y, $, z, j, W, X, et, Q, q, tt = [], Z, ot, vt, It;
            for (b = O(b),
            Z = b.length,
            L = p,
            U = 0,
            z = f,
            j = 0; j < Z; ++j)
                q = b[j],
                q < 128 && tt.push(P(q));
            for (Y = $ = tt.length,
            $ && tt.push(m); Y < Z; ) {
                for (W = a,
                j = 0; j < Z; ++j)
                    q = b[j],
                    q >= L && q < W && (W = q);
                for (ot = Y + 1,
                W - L > E((a - U) / ot) && A("overflow"),
                U += (W - L) * ot,
                L = W,
                j = 0; j < Z; ++j)
                    if (q = b[j],
                    q < L && ++U > a && A("overflow"),
                    q == L) {
                        for (X = U,
                        et = l; Q = et <= z ? h : et >= z + u ? u : et - z,
                        !(X < Q); et += l)
                            It = X - Q,
                            vt = l - Q,
                            tt.push(P(T(Q + It % vt, 0))),
                            X = E(It / vt);
                        tt.push(P(T(X, 0))),
                        z = M(U, ot, Y == $),
                        U = 0,
                        ++Y
                    }
                ++U,
                ++L
            }
            return tt.join("")
        }
        function k(b) {
            return F(b, function(L) {
                return g.test(L) ? D(L.slice(4).toLowerCase()) : L
            })
        }
        function R(b) {
            return F(b, function(L) {
                return _.test(L) ? "xn--" + C(L) : L
            })
        }
        if (o = {
            version: "1.4.1",
            ucs2: {
                decode: O,
                encode: B
            },
            decode: D,
            encode: C,
            toASCII: R,
            toUnicode: k
        },
        i && r)
            if (s.exports == i)
                r.exports = o;
            else
                for (w in o)
                    o.hasOwnProperty(w) && (i[w] = o[w]);
        else
            e.punycode = o
    }
    )(rl)
}
)(qu, qu.exports);
var IA = qu.exports, RA = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return !1;
    if (typeof Symbol.iterator == "symbol")
        return !0;
    var t = {}
      , e = Symbol("test")
      , i = Object(e);
    if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
        return !1;
    var r = 42;
    t[e] = r;
    for (e in t)
        return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
        return !1;
    var n = Object.getOwnPropertySymbols(t);
    if (n.length !== 1 || n[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
        return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
        var o = Object.getOwnPropertyDescriptor(t, e);
        if (o.value !== r || o.enumerable !== !0)
            return !1
    }
    return !0
}, r_ = typeof Symbol < "u" && Symbol, MA = RA, FA = function() {
    return typeof r_ != "function" || typeof Symbol != "function" || typeof r_("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : MA()
}, s_ = {
    foo: {}
}, BA = Object, OA = function() {
    return {
        __proto__: s_
    }.foo === s_.foo && !({
        __proto__: null
    }instanceof BA)
}, kA = "Function.prototype.bind called on incompatible ", LA = Object.prototype.toString, NA = Math.max, UA = "[object Function]", n_ = function(t, e) {
    for (var i = [], r = 0; r < t.length; r += 1)
        i[r] = t[r];
    for (var n = 0; n < e.length; n += 1)
        i[n + t.length] = e[n];
    return i
}, GA = function(t, e) {
    for (var i = [], r = e || 0, n = 0; r < t.length; r += 1,
    n += 1)
        i[n] = t[r];
    return i
}, HA = function(s, t) {
    for (var e = "", i = 0; i < s.length; i += 1)
        e += s[i],
        i + 1 < s.length && (e += t);
    return e
}, $A = function(t) {
    var e = this;
    if (typeof e != "function" || LA.apply(e) !== UA)
        throw new TypeError(kA + e);
    for (var i = GA(arguments, 1), r, n = function() {
        if (this instanceof r) {
            var u = e.apply(this, n_(i, arguments));
            return Object(u) === u ? u : this
        }
        return e.apply(t, n_(i, arguments))
    }, o = NA(0, e.length - i.length), a = [], l = 0; l < o; l++)
        a[l] = "$" + l;
    if (r = Function("binder", "return function (" + HA(a, ",") + "){ return binder.apply(this,arguments); }")(n),
    e.prototype) {
        var h = function() {};
        h.prototype = e.prototype,
        r.prototype = new h,
        h.prototype = null
    }
    return r
}, zA = $A, Sm = Function.prototype.bind || zA, VA = Function.prototype.call, XA = Object.prototype.hasOwnProperty, WA = Sm, jA = WA.call(VA, XA), Lt, Jo = SyntaxError, Nx = Function, Ho = TypeError, yd = function(s) {
    try {
        return Nx('"use strict"; return (' + s + ").constructor;")()
    } catch {}
}, kn = Object.getOwnPropertyDescriptor;
if (kn)
    try {
        kn({}, "")
    } catch {
        kn = null
    }
var vd = function() {
    throw new Ho
}
  , qA = kn ? function() {
    try {
        return arguments.callee,
        vd
    } catch {
        try {
            return kn(arguments, "callee").get
        } catch {
            return vd
        }
    }
}() : vd
  , no = FA()
  , YA = OA()
  , Oe = Object.getPrototypeOf || (YA ? function(s) {
    return s.__proto__
}
: null)
  , fo = {}
  , KA = typeof Uint8Array > "u" || !Oe ? Lt : Oe(Uint8Array)
  , Ln = {
    "%AggregateError%": typeof AggregateError > "u" ? Lt : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Lt : ArrayBuffer,
    "%ArrayIteratorPrototype%": no && Oe ? Oe([][Symbol.iterator]()) : Lt,
    "%AsyncFromSyncIteratorPrototype%": Lt,
    "%AsyncFunction%": fo,
    "%AsyncGenerator%": fo,
    "%AsyncGeneratorFunction%": fo,
    "%AsyncIteratorPrototype%": fo,
    "%Atomics%": typeof Atomics > "u" ? Lt : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Lt : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Lt : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Lt : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Lt : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? Lt : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Lt : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Lt : FinalizationRegistry,
    "%Function%": Nx,
    "%GeneratorFunction%": fo,
    "%Int8Array%": typeof Int8Array > "u" ? Lt : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Lt : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Lt : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": no && Oe ? Oe(Oe([][Symbol.iterator]())) : Lt,
    "%JSON%": typeof JSON == "object" ? JSON : Lt,
    "%Map%": typeof Map > "u" ? Lt : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !no || !Oe ? Lt : Oe(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Lt : Promise,
    "%Proxy%": typeof Proxy > "u" ? Lt : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? Lt : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Lt : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !no || !Oe ? Lt : Oe(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Lt : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": no && Oe ? Oe(""[Symbol.iterator]()) : Lt,
    "%Symbol%": no ? Symbol : Lt,
    "%SyntaxError%": Jo,
    "%ThrowTypeError%": qA,
    "%TypedArray%": KA,
    "%TypeError%": Ho,
    "%Uint8Array%": typeof Uint8Array > "u" ? Lt : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Lt : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Lt : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Lt : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? Lt : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Lt : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Lt : WeakSet
};
if (Oe)
    try {
        null.error
    } catch (s) {
        var ZA = Oe(Oe(s));
        Ln["%Error.prototype%"] = ZA
    }
var QA = function s(t) {
    var e;
    if (t === "%AsyncFunction%")
        e = yd("async function () {}");
    else if (t === "%GeneratorFunction%")
        e = yd("function* () {}");
    else if (t === "%AsyncGeneratorFunction%")
        e = yd("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var i = s("%AsyncGeneratorFunction%");
        i && (e = i.prototype)
    } else if (t === "%AsyncIteratorPrototype%") {
        var r = s("%AsyncGenerator%");
        r && Oe && (e = Oe(r.prototype))
    }
    return Ln[t] = e,
    e
}
  , o_ = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
}
  , Wl = Sm
  , Yu = jA
  , JA = Wl.call(Function.call, Array.prototype.concat)
  , tS = Wl.call(Function.apply, Array.prototype.splice)
  , a_ = Wl.call(Function.call, String.prototype.replace)
  , Ku = Wl.call(Function.call, String.prototype.slice)
  , eS = Wl.call(Function.call, RegExp.prototype.exec)
  , iS = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
  , rS = /\\(\\)?/g
  , sS = function(t) {
    var e = Ku(t, 0, 1)
      , i = Ku(t, -1);
    if (e === "%" && i !== "%")
        throw new Jo("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && e !== "%")
        throw new Jo("invalid intrinsic syntax, expected opening `%`");
    var r = [];
    return a_(t, iS, function(n, o, a, l) {
        r[r.length] = a ? a_(l, rS, "$1") : o || n
    }),
    r
}
  , nS = function(t, e) {
    var i = t, r;
    if (Yu(o_, i) && (r = o_[i],
    i = "%" + r[0] + "%"),
    Yu(Ln, i)) {
        var n = Ln[i];
        if (n === fo && (n = QA(i)),
        typeof n > "u" && !e)
            throw new Ho("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return {
            alias: r,
            name: i,
            value: n
        }
    }
    throw new Jo("intrinsic " + t + " does not exist!")
}
  , Qn = function(t, e) {
    if (typeof t != "string" || t.length === 0)
        throw new Ho("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof e != "boolean")
        throw new Ho('"allowMissing" argument must be a boolean');
    if (eS(/^%?[^%]*%?$/, t) === null)
        throw new Jo("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i = sS(t)
      , r = i.length > 0 ? i[0] : ""
      , n = nS("%" + r + "%", e)
      , o = n.name
      , a = n.value
      , l = !1
      , h = n.alias;
    h && (r = h[0],
    tS(i, JA([0, 1], h)));
    for (var u = 1, c = !0; u < i.length; u += 1) {
        var d = i[u]
          , f = Ku(d, 0, 1)
          , p = Ku(d, -1);
        if ((f === '"' || f === "'" || f === "`" || p === '"' || p === "'" || p === "`") && f !== p)
            throw new Jo("property names with quotes must have matching quotes");
        if ((d === "constructor" || !c) && (l = !0),
        r += "." + d,
        o = "%" + r + "%",
        Yu(Ln, o))
            a = Ln[o];
        else if (a != null) {
            if (!(d in a)) {
                if (!e)
                    throw new Ho("base intrinsic for " + t + " exists, but the property is not available.");
                return
            }
            if (kn && u + 1 >= i.length) {
                var m = kn(a, d);
                c = !!m,
                c && "get"in m && !("originalValue"in m.get) ? a = m.get : a = a[d]
            } else
                c = Yu(a, d),
                a = a[d];
            c && !l && (Ln[o] = a)
        }
    }
    return a
}
  , Ux = {
    exports: {}
}
  , oS = Qn
  , zf = oS("%Object.defineProperty%", !0)
  , Vf = function() {
    if (zf)
        try {
            return zf({}, "a", {
                value: 1
            }),
            !0
        } catch {
            return !1
        }
    return !1
};
Vf.hasArrayLengthDefineBug = function() {
    if (!Vf())
        return null;
    try {
        return zf([], "length", {
            value: 1
        }).length !== 1
    } catch {
        return !0
    }
}
;
var Gx = Vf
  , aS = Qn
  , lu = aS("%Object.getOwnPropertyDescriptor%", !0);
if (lu)
    try {
        lu([], "length")
    } catch {
        lu = null
    }
var Hx = lu
  , lS = Gx()
  , Cm = Qn
  , ul = lS && Cm("%Object.defineProperty%", !0);
if (ul)
    try {
        ul({}, "a", {
            value: 1
        })
    } catch {
        ul = !1
    }
var hS = Cm("%SyntaxError%")
  , oo = Cm("%TypeError%")
  , l_ = Hx
  , uS = function(t, e, i) {
    if (!t || typeof t != "object" && typeof t != "function")
        throw new oo("`obj` must be an object or a function`");
    if (typeof e != "string" && typeof e != "symbol")
        throw new oo("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
        throw new oo("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
        throw new oo("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
        throw new oo("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
        throw new oo("`loose`, if provided, must be a boolean");
    var r = arguments.length > 3 ? arguments[3] : null
      , n = arguments.length > 4 ? arguments[4] : null
      , o = arguments.length > 5 ? arguments[5] : null
      , a = arguments.length > 6 ? arguments[6] : !1
      , l = !!l_ && l_(t, e);
    if (ul)
        ul(t, e, {
            configurable: o === null && l ? l.configurable : !o,
            enumerable: r === null && l ? l.enumerable : !r,
            value: i,
            writable: n === null && l ? l.writable : !n
        });
    else if (a || !r && !n && !o)
        t[e] = i;
    else
        throw new hS("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
}
  , $x = Qn
  , h_ = uS
  , cS = Gx()
  , u_ = Hx
  , c_ = $x("%TypeError%")
  , dS = $x("%Math.floor%")
  , fS = function(t, e) {
    if (typeof t != "function")
        throw new c_("`fn` is not a function");
    if (typeof e != "number" || e < 0 || e > 4294967295 || dS(e) !== e)
        throw new c_("`length` must be a positive 32-bit integer");
    var i = arguments.length > 2 && !!arguments[2]
      , r = !0
      , n = !0;
    if ("length"in t && u_) {
        var o = u_(t, "length");
        o && !o.configurable && (r = !1),
        o && !o.writable && (n = !1)
    }
    return (r || n || !i) && (cS ? h_(t, "length", e, !0, !0) : h_(t, "length", e)),
    t
};
(function(s) {
    var t = Sm
      , e = Qn
      , i = fS
      , r = e("%TypeError%")
      , n = e("%Function.prototype.apply%")
      , o = e("%Function.prototype.call%")
      , a = e("%Reflect.apply%", !0) || t.call(o, n)
      , l = e("%Object.defineProperty%", !0)
      , h = e("%Math.max%");
    if (l)
        try {
            l({}, "a", {
                value: 1
            })
        } catch {
            l = null
        }
    s.exports = function(d) {
        if (typeof d != "function")
            throw new r("a function is required");
        var f = a(t, o, arguments);
        return i(f, 1 + h(0, d.length - (arguments.length - 1)), !0)
    }
    ;
    var u = function() {
        return a(t, n, arguments)
    };
    l ? l(s.exports, "apply", {
        value: u
    }) : s.exports.apply = u
}
)(Ux);
var pS = Ux.exports
  , zx = Qn
  , Vx = pS
  , mS = Vx(zx("String.prototype.indexOf"))
  , gS = function(t, e) {
    var i = zx(t, !!e);
    return typeof i == "function" && mS(t, ".prototype.") > -1 ? Vx(i) : i
};
const _S = {}
  , yS = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: _S
}, Symbol.toStringTag, {
    value: "Module"
}))
  , vS = RT(yS);
var Pm = typeof Map == "function" && Map.prototype
  , xd = Object.getOwnPropertyDescriptor && Pm ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
  , Zu = Pm && xd && typeof xd.get == "function" ? xd.get : null
  , d_ = Pm && Map.prototype.forEach
  , Im = typeof Set == "function" && Set.prototype
  , bd = Object.getOwnPropertyDescriptor && Im ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
  , Qu = Im && bd && typeof bd.get == "function" ? bd.get : null
  , f_ = Im && Set.prototype.forEach
  , xS = typeof WeakMap == "function" && WeakMap.prototype
  , cl = xS ? WeakMap.prototype.has : null
  , bS = typeof WeakSet == "function" && WeakSet.prototype
  , dl = bS ? WeakSet.prototype.has : null
  , wS = typeof WeakRef == "function" && WeakRef.prototype
  , p_ = wS ? WeakRef.prototype.deref : null
  , ES = Boolean.prototype.valueOf
  , TS = Object.prototype.toString
  , DS = Function.prototype.toString
  , AS = String.prototype.match
  , Rm = String.prototype.slice
  , zs = String.prototype.replace
  , SS = String.prototype.toUpperCase
  , m_ = String.prototype.toLowerCase
  , Xx = RegExp.prototype.test
  , g_ = Array.prototype.concat
  , $r = Array.prototype.join
  , CS = Array.prototype.slice
  , __ = Math.floor
  , Xf = typeof BigInt == "function" ? BigInt.prototype.valueOf : null
  , wd = Object.getOwnPropertySymbols
  , Wf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null
  , ta = typeof Symbol == "function" && typeof Symbol.iterator == "object"
  , ri = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === ta || "symbol") ? Symbol.toStringTag : null
  , Wx = Object.prototype.propertyIsEnumerable
  , y_ = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(s) {
    return s.__proto__
}
: null);
function v_(s, t) {
    if (s === 1 / 0 || s === -1 / 0 || s !== s || s && s > -1e3 && s < 1e3 || Xx.call(/e/, t))
        return t;
    var e = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof s == "number") {
        var i = s < 0 ? -__(-s) : __(s);
        if (i !== s) {
            var r = String(i)
              , n = Rm.call(t, r.length + 1);
            return zs.call(r, e, "$&_") + "." + zs.call(zs.call(n, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return zs.call(t, e, "$&_")
}
var jf = vS
  , x_ = jf.custom
  , b_ = qx(x_) ? x_ : null
  , PS = function s(t, e, i, r) {
    var n = e || {};
    if (Is(n, "quoteStyle") && n.quoteStyle !== "single" && n.quoteStyle !== "double")
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Is(n, "maxStringLength") && (typeof n.maxStringLength == "number" ? n.maxStringLength < 0 && n.maxStringLength !== 1 / 0 : n.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var o = Is(n, "customInspect") ? n.customInspect : !0;
    if (typeof o != "boolean" && o !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Is(n, "indent") && n.indent !== null && n.indent !== "	" && !(parseInt(n.indent, 10) === n.indent && n.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Is(n, "numericSeparator") && typeof n.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var a = n.numericSeparator;
    if (typeof t > "u")
        return "undefined";
    if (t === null)
        return "null";
    if (typeof t == "boolean")
        return t ? "true" : "false";
    if (typeof t == "string")
        return Kx(t, n);
    if (typeof t == "number") {
        if (t === 0)
            return 1 / 0 / t > 0 ? "0" : "-0";
        var l = String(t);
        return a ? v_(t, l) : l
    }
    if (typeof t == "bigint") {
        var h = String(t) + "n";
        return a ? v_(t, h) : h
    }
    var u = typeof n.depth > "u" ? 5 : n.depth;
    if (typeof i > "u" && (i = 0),
    i >= u && u > 0 && typeof t == "object")
        return qf(t) ? "[Array]" : "[Object]";
    var c = jS(n, i);
    if (typeof r > "u")
        r = [];
    else if (Yx(r, t) >= 0)
        return "[Circular]";
    function d(S, T, M) {
        if (T && (r = CS.call(r),
        r.push(T)),
        M) {
            var D = {
                depth: n.depth
            };
            return Is(n, "quoteStyle") && (D.quoteStyle = n.quoteStyle),
            s(S, D, i + 1, r)
        }
        return s(S, n, i + 1, r)
    }
    if (typeof t == "function" && !w_(t)) {
        var f = NS(t)
          , p = Ph(t, d);
        return "[Function" + (f ? ": " + f : " (anonymous)") + "]" + (p.length > 0 ? " { " + $r.call(p, ", ") + " }" : "")
    }
    if (qx(t)) {
        var m = ta ? zs.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Wf.call(t);
        return typeof t == "object" && !ta ? ba(m) : m
    }
    if (VS(t)) {
        for (var g = "<" + m_.call(String(t.nodeName)), _ = t.attributes || [], x = 0; x < _.length; x++)
            g += " " + _[x].name + "=" + jx(IS(_[x].value), "double", n);
        return g += ">",
        t.childNodes && t.childNodes.length && (g += "..."),
        g += "</" + m_.call(String(t.nodeName)) + ">",
        g
    }
    if (qf(t)) {
        if (t.length === 0)
            return "[]";
        var y = Ph(t, d);
        return c && !WS(y) ? "[" + Yf(y, c) + "]" : "[ " + $r.call(y, ", ") + " ]"
    }
    if (MS(t)) {
        var v = Ph(t, d);
        return !("cause"in Error.prototype) && "cause"in t && !Wx.call(t, "cause") ? "{ [" + String(t) + "] " + $r.call(g_.call("[cause]: " + d(t.cause), v), ", ") + " }" : v.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + $r.call(v, ", ") + " }"
    }
    if (typeof t == "object" && o) {
        if (b_ && typeof t[b_] == "function" && jf)
            return jf(t, {
                depth: u - i
            });
        if (o !== "symbol" && typeof t.inspect == "function")
            return t.inspect()
    }
    if (US(t)) {
        var E = [];
        return d_ && d_.call(t, function(S, T) {
            E.push(d(T, t, !0) + " => " + d(S, t))
        }),
        E_("Map", Zu.call(t), E, c)
    }
    if ($S(t)) {
        var P = [];
        return f_ && f_.call(t, function(S) {
            P.push(d(S, t))
        }),
        E_("Set", Qu.call(t), P, c)
    }
    if (GS(t))
        return Ed("WeakMap");
    if (zS(t))
        return Ed("WeakSet");
    if (HS(t))
        return Ed("WeakRef");
    if (BS(t))
        return ba(d(Number(t)));
    if (kS(t))
        return ba(d(Xf.call(t)));
    if (OS(t))
        return ba(ES.call(t));
    if (FS(t))
        return ba(d(String(t)));
    if (typeof window < "u" && t === window)
        return "{ [object Window] }";
    if (t === rl)
        return "{ [object globalThis] }";
    if (!RS(t) && !w_(t)) {
        var w = Ph(t, d)
          , A = y_ ? y_(t) === Object.prototype : t instanceof Object || t.constructor === Object
          , I = t instanceof Object ? "" : "null prototype"
          , F = !A && ri && Object(t) === t && ri in t ? Rm.call(sn(t), 8, -1) : I ? "Object" : ""
          , O = A || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : ""
          , B = O + (F || I ? "[" + $r.call(g_.call([], F || [], I || []), ": ") + "] " : "");
        return w.length === 0 ? B + "{}" : c ? B + "{" + Yf(w, c) + "}" : B + "{ " + $r.call(w, ", ") + " }"
    }
    return String(t)
};
function jx(s, t, e) {
    var i = (e.quoteStyle || t) === "double" ? '"' : "'";
    return i + s + i
}
function IS(s) {
    return zs.call(String(s), /"/g, "&quot;")
}
function qf(s) {
    return sn(s) === "[object Array]" && (!ri || !(typeof s == "object" && ri in s))
}
function RS(s) {
    return sn(s) === "[object Date]" && (!ri || !(typeof s == "object" && ri in s))
}
function w_(s) {
    return sn(s) === "[object RegExp]" && (!ri || !(typeof s == "object" && ri in s))
}
function MS(s) {
    return sn(s) === "[object Error]" && (!ri || !(typeof s == "object" && ri in s))
}
function FS(s) {
    return sn(s) === "[object String]" && (!ri || !(typeof s == "object" && ri in s))
}
function BS(s) {
    return sn(s) === "[object Number]" && (!ri || !(typeof s == "object" && ri in s))
}
function OS(s) {
    return sn(s) === "[object Boolean]" && (!ri || !(typeof s == "object" && ri in s))
}
function qx(s) {
    if (ta)
        return s && typeof s == "object" && s instanceof Symbol;
    if (typeof s == "symbol")
        return !0;
    if (!s || typeof s != "object" || !Wf)
        return !1;
    try {
        return Wf.call(s),
        !0
    } catch {}
    return !1
}
function kS(s) {
    if (!s || typeof s != "object" || !Xf)
        return !1;
    try {
        return Xf.call(s),
        !0
    } catch {}
    return !1
}
var LS = Object.prototype.hasOwnProperty || function(s) {
    return s in this
}
;
function Is(s, t) {
    return LS.call(s, t)
}
function sn(s) {
    return TS.call(s)
}
function NS(s) {
    if (s.name)
        return s.name;
    var t = AS.call(DS.call(s), /^function\s*([\w$]+)/);
    return t ? t[1] : null
}
function Yx(s, t) {
    if (s.indexOf)
        return s.indexOf(t);
    for (var e = 0, i = s.length; e < i; e++)
        if (s[e] === t)
            return e;
    return -1
}
function US(s) {
    if (!Zu || !s || typeof s != "object")
        return !1;
    try {
        Zu.call(s);
        try {
            Qu.call(s)
        } catch {
            return !0
        }
        return s instanceof Map
    } catch {}
    return !1
}
function GS(s) {
    if (!cl || !s || typeof s != "object")
        return !1;
    try {
        cl.call(s, cl);
        try {
            dl.call(s, dl)
        } catch {
            return !0
        }
        return s instanceof WeakMap
    } catch {}
    return !1
}
function HS(s) {
    if (!p_ || !s || typeof s != "object")
        return !1;
    try {
        return p_.call(s),
        !0
    } catch {}
    return !1
}
function $S(s) {
    if (!Qu || !s || typeof s != "object")
        return !1;
    try {
        Qu.call(s);
        try {
            Zu.call(s)
        } catch {
            return !0
        }
        return s instanceof Set
    } catch {}
    return !1
}
function zS(s) {
    if (!dl || !s || typeof s != "object")
        return !1;
    try {
        dl.call(s, dl);
        try {
            cl.call(s, cl)
        } catch {
            return !0
        }
        return s instanceof WeakSet
    } catch {}
    return !1
}
function VS(s) {
    return !s || typeof s != "object" ? !1 : typeof HTMLElement < "u" && s instanceof HTMLElement ? !0 : typeof s.nodeName == "string" && typeof s.getAttribute == "function"
}
function Kx(s, t) {
    if (s.length > t.maxStringLength) {
        var e = s.length - t.maxStringLength
          , i = "... " + e + " more character" + (e > 1 ? "s" : "");
        return Kx(Rm.call(s, 0, t.maxStringLength), t) + i
    }
    var r = zs.call(zs.call(s, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, XS);
    return jx(r, "single", t)
}
function XS(s) {
    var t = s.charCodeAt(0)
      , e = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return e ? "\\" + e : "\\x" + (t < 16 ? "0" : "") + SS.call(t.toString(16))
}
function ba(s) {
    return "Object(" + s + ")"
}
function Ed(s) {
    return s + " { ? }"
}
function E_(s, t, e, i) {
    var r = i ? Yf(e, i) : $r.call(e, ", ");
    return s + " (" + t + ") {" + r + "}"
}
function WS(s) {
    for (var t = 0; t < s.length; t++)
        if (Yx(s[t], `
`) >= 0)
            return !1;
    return !0
}
function jS(s, t) {
    var e;
    if (s.indent === "	")
        e = "	";
    else if (typeof s.indent == "number" && s.indent > 0)
        e = $r.call(Array(s.indent + 1), " ");
    else
        return null;
    return {
        base: e,
        prev: $r.call(Array(t + 1), e)
    }
}
function Yf(s, t) {
    if (s.length === 0)
        return "";
    var e = `
` + t.prev + t.base;
    return e + $r.call(s, "," + e) + `
` + t.prev
}
function Ph(s, t) {
    var e = qf(s)
      , i = [];
    if (e) {
        i.length = s.length;
        for (var r = 0; r < s.length; r++)
            i[r] = Is(s, r) ? t(s[r], s) : ""
    }
    var n = typeof wd == "function" ? wd(s) : [], o;
    if (ta) {
        o = {};
        for (var a = 0; a < n.length; a++)
            o["$" + n[a]] = n[a]
    }
    for (var l in s)
        Is(s, l) && (e && String(Number(l)) === l && l < s.length || ta && o["$" + l]instanceof Symbol || (Xx.call(/[^\w$]/, l) ? i.push(t(l, s) + ": " + t(s[l], s)) : i.push(l + ": " + t(s[l], s))));
    if (typeof wd == "function")
        for (var h = 0; h < n.length; h++)
            Wx.call(s, n[h]) && i.push("[" + t(n[h]) + "]: " + t(s[n[h]], s));
    return i
}
var Mm = Qn
  , oa = gS
  , qS = PS
  , YS = Mm("%TypeError%")
  , Ih = Mm("%WeakMap%", !0)
  , Rh = Mm("%Map%", !0)
  , KS = oa("WeakMap.prototype.get", !0)
  , ZS = oa("WeakMap.prototype.set", !0)
  , QS = oa("WeakMap.prototype.has", !0)
  , JS = oa("Map.prototype.get", !0)
  , tC = oa("Map.prototype.set", !0)
  , eC = oa("Map.prototype.has", !0)
  , Fm = function(s, t) {
    for (var e = s, i; (i = e.next) !== null; e = i)
        if (i.key === t)
            return e.next = i.next,
            i.next = s.next,
            s.next = i,
            i
}
  , iC = function(s, t) {
    var e = Fm(s, t);
    return e && e.value
}
  , rC = function(s, t, e) {
    var i = Fm(s, t);
    i ? i.value = e : s.next = {
        key: t,
        next: s.next,
        value: e
    }
}
  , sC = function(s, t) {
    return !!Fm(s, t)
}
  , nC = function() {
    var t, e, i, r = {
        assert: function(n) {
            if (!r.has(n))
                throw new YS("Side channel does not contain " + qS(n))
        },
        get: function(n) {
            if (Ih && n && (typeof n == "object" || typeof n == "function")) {
                if (t)
                    return KS(t, n)
            } else if (Rh) {
                if (e)
                    return JS(e, n)
            } else if (i)
                return iC(i, n)
        },
        has: function(n) {
            if (Ih && n && (typeof n == "object" || typeof n == "function")) {
                if (t)
                    return QS(t, n)
            } else if (Rh) {
                if (e)
                    return eC(e, n)
            } else if (i)
                return sC(i, n);
            return !1
        },
        set: function(n, o) {
            Ih && n && (typeof n == "object" || typeof n == "function") ? (t || (t = new Ih),
            ZS(t, n, o)) : Rh ? (e || (e = new Rh),
            tC(e, n, o)) : (i || (i = {
                key: {},
                next: null
            }),
            rC(i, n, o))
        }
    };
    return r
}
  , oC = String.prototype.replace
  , aC = /%20/g
  , Td = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}
  , Bm = {
    default: Td.RFC3986,
    formatters: {
        RFC1738: function(s) {
            return oC.call(s, aC, "+")
        },
        RFC3986: function(s) {
            return String(s)
        }
    },
    RFC1738: Td.RFC1738,
    RFC3986: Td.RFC3986
}
  , lC = Bm
  , Dd = Object.prototype.hasOwnProperty
  , xn = Array.isArray
  , Br = function() {
    for (var s = [], t = 0; t < 256; ++t)
        s.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return s
}()
  , hC = function(t) {
    for (; t.length > 1; ) {
        var e = t.pop()
          , i = e.obj[e.prop];
        if (xn(i)) {
            for (var r = [], n = 0; n < i.length; ++n)
                typeof i[n] < "u" && r.push(i[n]);
            e.obj[e.prop] = r
        }
    }
}
  , Zx = function(t, e) {
    for (var i = e && e.plainObjects ? Object.create(null) : {}, r = 0; r < t.length; ++r)
        typeof t[r] < "u" && (i[r] = t[r]);
    return i
}
  , uC = function s(t, e, i) {
    if (!e)
        return t;
    if (typeof e != "object") {
        if (xn(t))
            t.push(e);
        else if (t && typeof t == "object")
            (i && (i.plainObjects || i.allowPrototypes) || !Dd.call(Object.prototype, e)) && (t[e] = !0);
        else
            return [t, e];
        return t
    }
    if (!t || typeof t != "object")
        return [t].concat(e);
    var r = t;
    return xn(t) && !xn(e) && (r = Zx(t, i)),
    xn(t) && xn(e) ? (e.forEach(function(n, o) {
        if (Dd.call(t, o)) {
            var a = t[o];
            a && typeof a == "object" && n && typeof n == "object" ? t[o] = s(a, n, i) : t.push(n)
        } else
            t[o] = n
    }),
    t) : Object.keys(e).reduce(function(n, o) {
        var a = e[o];
        return Dd.call(n, o) ? n[o] = s(n[o], a, i) : n[o] = a,
        n
    }, r)
}
  , cC = function(t, e) {
    return Object.keys(e).reduce(function(i, r) {
        return i[r] = e[r],
        i
    }, t)
}
  , dC = function(s, t, e) {
    var i = s.replace(/\+/g, " ");
    if (e === "iso-8859-1")
        return i.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(i)
    } catch {
        return i
    }
}
  , fC = function(t, e, i, r, n) {
    if (t.length === 0)
        return t;
    var o = t;
    if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)),
    i === "iso-8859-1")
        return escape(o).replace(/%u[0-9a-f]{4}/gi, function(u) {
            return "%26%23" + parseInt(u.slice(2), 16) + "%3B"
        });
    for (var a = "", l = 0; l < o.length; ++l) {
        var h = o.charCodeAt(l);
        if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || n === lC.RFC1738 && (h === 40 || h === 41)) {
            a += o.charAt(l);
            continue
        }
        if (h < 128) {
            a = a + Br[h];
            continue
        }
        if (h < 2048) {
            a = a + (Br[192 | h >> 6] + Br[128 | h & 63]);
            continue
        }
        if (h < 55296 || h >= 57344) {
            a = a + (Br[224 | h >> 12] + Br[128 | h >> 6 & 63] + Br[128 | h & 63]);
            continue
        }
        l += 1,
        h = 65536 + ((h & 1023) << 10 | o.charCodeAt(l) & 1023),
        a += Br[240 | h >> 18] + Br[128 | h >> 12 & 63] + Br[128 | h >> 6 & 63] + Br[128 | h & 63]
    }
    return a
}
  , pC = function(t) {
    for (var e = [{
        obj: {
            o: t
        },
        prop: "o"
    }], i = [], r = 0; r < e.length; ++r)
        for (var n = e[r], o = n.obj[n.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
            var h = a[l]
              , u = o[h];
            typeof u == "object" && u !== null && i.indexOf(u) === -1 && (e.push({
                obj: o,
                prop: h
            }),
            i.push(u))
        }
    return hC(e),
    t
}
  , mC = function(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
  , gC = function(t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
}
  , _C = function(t, e) {
    return [].concat(t, e)
}
  , yC = function(t, e) {
    if (xn(t)) {
        for (var i = [], r = 0; r < t.length; r += 1)
            i.push(e(t[r]));
        return i
    }
    return e(t)
}
  , Qx = {
    arrayToObject: Zx,
    assign: cC,
    combine: _C,
    compact: pC,
    decode: dC,
    encode: fC,
    isBuffer: gC,
    isRegExp: mC,
    maybeMap: yC,
    merge: uC
}
  , Jx = nC
  , hu = Qx
  , fl = Bm
  , vC = Object.prototype.hasOwnProperty
  , T_ = {
    brackets: function(t) {
        return t + "[]"
    },
    comma: "comma",
    indices: function(t, e) {
        return t + "[" + e + "]"
    },
    repeat: function(t) {
        return t
    }
}
  , us = Array.isArray
  , xC = Array.prototype.push
  , t1 = function(s, t) {
    xC.apply(s, us(t) ? t : [t])
}
  , bC = Date.prototype.toISOString
  , D_ = fl.default
  , Ke = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: hu.encode,
    encodeValuesOnly: !1,
    format: D_,
    formatter: fl.formatters[D_],
    indices: !1,
    serializeDate: function(t) {
        return bC.call(t)
    },
    skipNulls: !1,
    strictNullHandling: !1
}
  , wC = function(t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint"
}
  , Ad = {}
  , EC = function s(t, e, i, r, n, o, a, l, h, u, c, d, f, p, m, g) {
    for (var _ = t, x = g, y = 0, v = !1; (x = x.get(Ad)) !== void 0 && !v; ) {
        var E = x.get(t);
        if (y += 1,
        typeof E < "u") {
            if (E === y)
                throw new RangeError("Cyclic object value");
            v = !0
        }
        typeof x.get(Ad) > "u" && (y = 0)
    }
    if (typeof l == "function" ? _ = l(e, _) : _ instanceof Date ? _ = c(_) : i === "comma" && us(_) && (_ = hu.maybeMap(_, function(D) {
        return D instanceof Date ? c(D) : D
    })),
    _ === null) {
        if (n)
            return a && !p ? a(e, Ke.encoder, m, "key", d) : e;
        _ = ""
    }
    if (wC(_) || hu.isBuffer(_)) {
        if (a) {
            var P = p ? e : a(e, Ke.encoder, m, "key", d);
            return [f(P) + "=" + f(a(_, Ke.encoder, m, "value", d))]
        }
        return [f(e) + "=" + f(String(_))]
    }
    var w = [];
    if (typeof _ > "u")
        return w;
    var A;
    if (i === "comma" && us(_))
        p && a && (_ = hu.maybeMap(_, a)),
        A = [{
            value: _.length > 0 ? _.join(",") || null : void 0
        }];
    else if (us(l))
        A = l;
    else {
        var I = Object.keys(_);
        A = h ? I.sort(h) : I
    }
    for (var F = r && us(_) && _.length === 1 ? e + "[]" : e, O = 0; O < A.length; ++O) {
        var B = A[O]
          , S = typeof B == "object" && typeof B.value < "u" ? B.value : _[B];
        if (!(o && S === null)) {
            var T = us(_) ? typeof i == "function" ? i(F, B) : F : F + (u ? "." + B : "[" + B + "]");
            g.set(t, y);
            var M = Jx();
            M.set(Ad, g),
            t1(w, s(S, T, i, r, n, o, i === "comma" && p && us(_) ? null : a, l, h, u, c, d, f, p, m, M))
        }
    }
    return w
}
  , TC = function(t) {
    if (!t)
        return Ke;
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
        throw new TypeError("Encoder has to be a function.");
    var e = t.charset || Ke.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var i = fl.default;
    if (typeof t.format < "u") {
        if (!vC.call(fl.formatters, t.format))
            throw new TypeError("Unknown format option provided.");
        i = t.format
    }
    var r = fl.formatters[i]
      , n = Ke.filter;
    return (typeof t.filter == "function" || us(t.filter)) && (n = t.filter),
    {
        addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Ke.addQueryPrefix,
        allowDots: typeof t.allowDots > "u" ? Ke.allowDots : !!t.allowDots,
        charset: e,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Ke.charsetSentinel,
        delimiter: typeof t.delimiter > "u" ? Ke.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : Ke.encode,
        encoder: typeof t.encoder == "function" ? t.encoder : Ke.encoder,
        encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Ke.encodeValuesOnly,
        filter: n,
        format: i,
        formatter: r,
        serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Ke.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Ke.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Ke.strictNullHandling
    }
}
  , DC = function(s, t) {
    var e = s, i = TC(t), r, n;
    typeof i.filter == "function" ? (n = i.filter,
    e = n("", e)) : us(i.filter) && (n = i.filter,
    r = n);
    var o = [];
    if (typeof e != "object" || e === null)
        return "";
    var a;
    t && t.arrayFormat in T_ ? a = t.arrayFormat : t && "indices"in t ? a = t.indices ? "indices" : "repeat" : a = "indices";
    var l = T_[a];
    if (t && "commaRoundTrip"in t && typeof t.commaRoundTrip != "boolean")
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var h = l === "comma" && t && t.commaRoundTrip;
    r || (r = Object.keys(e)),
    i.sort && r.sort(i.sort);
    for (var u = Jx(), c = 0; c < r.length; ++c) {
        var d = r[c];
        i.skipNulls && e[d] === null || t1(o, EC(e[d], d, l, h, i.strictNullHandling, i.skipNulls, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, u))
    }
    var f = o.join(i.delimiter)
      , p = i.addQueryPrefix === !0 ? "?" : "";
    return i.charsetSentinel && (i.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"),
    f.length > 0 ? p + f : ""
}
  , ea = Qx
  , Kf = Object.prototype.hasOwnProperty
  , AC = Array.isArray
  , Me = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: ea.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1
}
  , SC = function(s) {
    return s.replace(/&#(\d+);/g, function(t, e) {
        return String.fromCharCode(parseInt(e, 10))
    })
}
  , e1 = function(s, t) {
    return s && typeof s == "string" && t.comma && s.indexOf(",") > -1 ? s.split(",") : s
}
  , CC = "utf8=%26%2310003%3B"
  , PC = "utf8=%E2%9C%93"
  , IC = function(t, e) {
    var i = {
        __proto__: null
    }, r = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, n = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, o = r.split(e.delimiter, n), a = -1, l, h = e.charset;
    if (e.charsetSentinel)
        for (l = 0; l < o.length; ++l)
            o[l].indexOf("utf8=") === 0 && (o[l] === PC ? h = "utf-8" : o[l] === CC && (h = "iso-8859-1"),
            a = l,
            l = o.length);
    for (l = 0; l < o.length; ++l)
        if (l !== a) {
            var u = o[l], c = u.indexOf("]="), d = c === -1 ? u.indexOf("=") : c + 1, f, p;
            d === -1 ? (f = e.decoder(u, Me.decoder, h, "key"),
            p = e.strictNullHandling ? null : "") : (f = e.decoder(u.slice(0, d), Me.decoder, h, "key"),
            p = ea.maybeMap(e1(u.slice(d + 1), e), function(m) {
                return e.decoder(m, Me.decoder, h, "value")
            })),
            p && e.interpretNumericEntities && h === "iso-8859-1" && (p = SC(p)),
            u.indexOf("[]=") > -1 && (p = AC(p) ? [p] : p),
            Kf.call(i, f) ? i[f] = ea.combine(i[f], p) : i[f] = p
        }
    return i
}
  , RC = function(s, t, e, i) {
    for (var r = i ? t : e1(t, e), n = s.length - 1; n >= 0; --n) {
        var o, a = s[n];
        if (a === "[]" && e.parseArrays)
            o = [].concat(r);
        else {
            o = e.plainObjects ? Object.create(null) : {};
            var l = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a
              , h = parseInt(l, 10);
            !e.parseArrays && l === "" ? o = {
                0: r
            } : !isNaN(h) && a !== l && String(h) === l && h >= 0 && e.parseArrays && h <= e.arrayLimit ? (o = [],
            o[h] = r) : l !== "__proto__" && (o[l] = r)
        }
        r = o
    }
    return r
}
  , MC = function(t, e, i, r) {
    if (t) {
        var n = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t
          , o = /(\[[^[\]]*])/
          , a = /(\[[^[\]]*])/g
          , l = i.depth > 0 && o.exec(n)
          , h = l ? n.slice(0, l.index) : n
          , u = [];
        if (h) {
            if (!i.plainObjects && Kf.call(Object.prototype, h) && !i.allowPrototypes)
                return;
            u.push(h)
        }
        for (var c = 0; i.depth > 0 && (l = a.exec(n)) !== null && c < i.depth; ) {
            if (c += 1,
            !i.plainObjects && Kf.call(Object.prototype, l[1].slice(1, -1)) && !i.allowPrototypes)
                return;
            u.push(l[1])
        }
        return l && u.push("[" + n.slice(l.index) + "]"),
        RC(u, e, i, r)
    }
}
  , FC = function(t) {
    if (!t)
        return Me;
    if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function")
        throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var e = typeof t.charset > "u" ? Me.charset : t.charset;
    return {
        allowDots: typeof t.allowDots > "u" ? Me.allowDots : !!t.allowDots,
        allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Me.allowPrototypes,
        allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Me.allowSparse,
        arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Me.arrayLimit,
        charset: e,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Me.charsetSentinel,
        comma: typeof t.comma == "boolean" ? t.comma : Me.comma,
        decoder: typeof t.decoder == "function" ? t.decoder : Me.decoder,
        delimiter: typeof t.delimiter == "string" || ea.isRegExp(t.delimiter) ? t.delimiter : Me.delimiter,
        depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Me.depth,
        ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Me.interpretNumericEntities,
        parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Me.parameterLimit,
        parseArrays: t.parseArrays !== !1,
        plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Me.plainObjects,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Me.strictNullHandling
    }
}
  , BC = function(s, t) {
    var e = FC(t);
    if (s === "" || s === null || typeof s > "u")
        return e.plainObjects ? Object.create(null) : {};
    for (var i = typeof s == "string" ? IC(s, e) : s, r = e.plainObjects ? Object.create(null) : {}, n = Object.keys(i), o = 0; o < n.length; ++o) {
        var a = n[o]
          , l = MC(a, i[a], e, typeof s == "string");
        r = ea.merge(r, l, e)
    }
    return e.allowSparse === !0 ? r : ea.compact(r)
}
  , OC = DC
  , kC = BC
  , LC = Bm
  , NC = {
    formats: LC,
    parse: kC,
    stringify: OC
}
  , UC = IA;
function Tr() {
    this.protocol = null,
    this.slashes = null,
    this.auth = null,
    this.host = null,
    this.port = null,
    this.hostname = null,
    this.hash = null,
    this.search = null,
    this.query = null,
    this.pathname = null,
    this.path = null,
    this.href = null
}
var GC = /^([a-z0-9.+-]+:)/i
  , HC = /:[0-9]*$/
  , $C = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/
  , zC = ["<", ">", '"', "`", " ", "\r", `
`, "	"]
  , VC = ["{", "}", "|", "\\", "^", "`"].concat(zC)
  , Zf = ["'"].concat(VC)
  , A_ = ["%", "/", "?", ";", "#"].concat(Zf)
  , S_ = ["/", "?", "#"]
  , XC = 255
  , C_ = /^[+a-z0-9A-Z_-]{0,63}$/
  , WC = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
  , jC = {
    javascript: !0,
    "javascript:": !0
}
  , Qf = {
    javascript: !0,
    "javascript:": !0
}
  , $o = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}
  , Jf = NC;
function Pc(s, t, e) {
    if (s && typeof s == "object" && s instanceof Tr)
        return s;
    var i = new Tr;
    return i.parse(s, t, e),
    i
}
Tr.prototype.parse = function(s, t, e) {
    if (typeof s != "string")
        throw new TypeError("Parameter 'url' must be a string, not " + typeof s);
    var i = s.indexOf("?")
      , r = i !== -1 && i < s.indexOf("#") ? "?" : "#"
      , n = s.split(r)
      , o = /\\/g;
    n[0] = n[0].replace(o, "/"),
    s = n.join(r);
    var a = s;
    if (a = a.trim(),
    !e && s.split("#").length === 1) {
        var l = $C.exec(a);
        if (l)
            return this.path = a,
            this.href = a,
            this.pathname = l[1],
            l[2] ? (this.search = l[2],
            t ? this.query = Jf.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "",
            this.query = {}),
            this
    }
    var h = GC.exec(a);
    if (h) {
        h = h[0];
        var u = h.toLowerCase();
        this.protocol = u,
        a = a.substr(h.length)
    }
    if (e || h || a.match(/^\/\/[^@/]+@[^@/]+/)) {
        var c = a.substr(0, 2) === "//";
        c && !(h && Qf[h]) && (a = a.substr(2),
        this.slashes = !0)
    }
    if (!Qf[h] && (c || h && !$o[h])) {
        for (var d = -1, f = 0; f < S_.length; f++) {
            var p = a.indexOf(S_[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        var m, g;
        d === -1 ? g = a.lastIndexOf("@") : g = a.lastIndexOf("@", d),
        g !== -1 && (m = a.slice(0, g),
        a = a.slice(g + 1),
        this.auth = decodeURIComponent(m)),
        d = -1;
        for (var f = 0; f < A_.length; f++) {
            var p = a.indexOf(A_[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        d === -1 && (d = a.length),
        this.host = a.slice(0, d),
        a = a.slice(d),
        this.parseHost(),
        this.hostname = this.hostname || "";
        var _ = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!_)
            for (var x = this.hostname.split(/\./), f = 0, y = x.length; f < y; f++) {
                var v = x[f];
                if (v && !v.match(C_)) {
                    for (var E = "", P = 0, w = v.length; P < w; P++)
                        v.charCodeAt(P) > 127 ? E += "x" : E += v[P];
                    if (!E.match(C_)) {
                        var A = x.slice(0, f)
                          , I = x.slice(f + 1)
                          , F = v.match(WC);
                        F && (A.push(F[1]),
                        I.unshift(F[2])),
                        I.length && (a = "/" + I.join(".") + a),
                        this.hostname = A.join(".");
                        break
                    }
                }
            }
        this.hostname.length > XC ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
        _ || (this.hostname = UC.toASCII(this.hostname));
        var O = this.port ? ":" + this.port : ""
          , B = this.hostname || "";
        this.host = B + O,
        this.href += this.host,
        _ && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
        a[0] !== "/" && (a = "/" + a))
    }
    if (!jC[u])
        for (var f = 0, y = Zf.length; f < y; f++) {
            var S = Zf[f];
            if (a.indexOf(S) !== -1) {
                var T = encodeURIComponent(S);
                T === S && (T = escape(S)),
                a = a.split(S).join(T)
            }
        }
    var M = a.indexOf("#");
    M !== -1 && (this.hash = a.substr(M),
    a = a.slice(0, M));
    var D = a.indexOf("?");
    if (D !== -1 ? (this.search = a.substr(D),
    this.query = a.substr(D + 1),
    t && (this.query = Jf.parse(this.query)),
    a = a.slice(0, D)) : t && (this.search = "",
    this.query = {}),
    a && (this.pathname = a),
    $o[u] && this.hostname && !this.pathname && (this.pathname = "/"),
    this.pathname || this.search) {
        var O = this.pathname || ""
          , C = this.search || "";
        this.path = O + C
    }
    return this.href = this.format(),
    this
}
;
function qC(s) {
    return typeof s == "string" && (s = Pc(s)),
    s instanceof Tr ? s.format() : Tr.prototype.format.call(s)
}
Tr.prototype.format = function() {
    var s = this.auth || "";
    s && (s = encodeURIComponent(s),
    s = s.replace(/%3A/i, ":"),
    s += "@");
    var t = this.protocol || ""
      , e = this.pathname || ""
      , i = this.hash || ""
      , r = !1
      , n = "";
    this.host ? r = s + this.host : this.hostname && (r = s + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"),
    this.port && (r += ":" + this.port)),
    this.query && typeof this.query == "object" && Object.keys(this.query).length && (n = Jf.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1
    }));
    var o = this.search || n && "?" + n || "";
    return t && t.substr(-1) !== ":" && (t += ":"),
    this.slashes || (!t || $o[t]) && r !== !1 ? (r = "//" + (r || ""),
    e && e.charAt(0) !== "/" && (e = "/" + e)) : r || (r = ""),
    i && i.charAt(0) !== "#" && (i = "#" + i),
    o && o.charAt(0) !== "?" && (o = "?" + o),
    e = e.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a)
    }),
    o = o.replace("#", "%23"),
    t + r + e + o + i
}
;
function YC(s, t) {
    return Pc(s, !1, !0).resolve(t)
}
Tr.prototype.resolve = function(s) {
    return this.resolveObject(Pc(s, !1, !0)).format()
}
;
Tr.prototype.resolveObject = function(s) {
    if (typeof s == "string") {
        var t = new Tr;
        t.parse(s, !1, !0),
        s = t
    }
    for (var e = new Tr, i = Object.keys(this), r = 0; r < i.length; r++) {
        var n = i[r];
        e[n] = this[n]
    }
    if (e.hash = s.hash,
    s.href === "")
        return e.href = e.format(),
        e;
    if (s.slashes && !s.protocol) {
        for (var o = Object.keys(s), a = 0; a < o.length; a++) {
            var l = o[a];
            l !== "protocol" && (e[l] = s[l])
        }
        return $o[e.protocol] && e.hostname && !e.pathname && (e.pathname = "/",
        e.path = e.pathname),
        e.href = e.format(),
        e
    }
    if (s.protocol && s.protocol !== e.protocol) {
        if (!$o[s.protocol]) {
            for (var h = Object.keys(s), u = 0; u < h.length; u++) {
                var c = h[u];
                e[c] = s[c]
            }
            return e.href = e.format(),
            e
        }
        if (e.protocol = s.protocol,
        !s.host && !Qf[s.protocol]) {
            for (var y = (s.pathname || "").split("/"); y.length && !(s.host = y.shift()); )
                ;
            s.host || (s.host = ""),
            s.hostname || (s.hostname = ""),
            y[0] !== "" && y.unshift(""),
            y.length < 2 && y.unshift(""),
            e.pathname = y.join("/")
        } else
            e.pathname = s.pathname;
        if (e.search = s.search,
        e.query = s.query,
        e.host = s.host || "",
        e.auth = s.auth,
        e.hostname = s.hostname || s.host,
        e.port = s.port,
        e.pathname || e.search) {
            var d = e.pathname || ""
              , f = e.search || "";
            e.path = d + f
        }
        return e.slashes = e.slashes || s.slashes,
        e.href = e.format(),
        e
    }
    var p = e.pathname && e.pathname.charAt(0) === "/"
      , m = s.host || s.pathname && s.pathname.charAt(0) === "/"
      , g = m || p || e.host && s.pathname
      , _ = g
      , x = e.pathname && e.pathname.split("/") || []
      , y = s.pathname && s.pathname.split("/") || []
      , v = e.protocol && !$o[e.protocol];
    if (v && (e.hostname = "",
    e.port = null,
    e.host && (x[0] === "" ? x[0] = e.host : x.unshift(e.host)),
    e.host = "",
    s.protocol && (s.hostname = null,
    s.port = null,
    s.host && (y[0] === "" ? y[0] = s.host : y.unshift(s.host)),
    s.host = null),
    g = g && (y[0] === "" || x[0] === "")),
    m)
        e.host = s.host || s.host === "" ? s.host : e.host,
        e.hostname = s.hostname || s.hostname === "" ? s.hostname : e.hostname,
        e.search = s.search,
        e.query = s.query,
        x = y;
    else if (y.length)
        x || (x = []),
        x.pop(),
        x = x.concat(y),
        e.search = s.search,
        e.query = s.query;
    else if (s.search != null) {
        if (v) {
            e.host = x.shift(),
            e.hostname = e.host;
            var E = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
            E && (e.auth = E.shift(),
            e.hostname = E.shift(),
            e.host = e.hostname)
        }
        return e.search = s.search,
        e.query = s.query,
        (e.pathname !== null || e.search !== null) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")),
        e.href = e.format(),
        e
    }
    if (!x.length)
        return e.pathname = null,
        e.search ? e.path = "/" + e.search : e.path = null,
        e.href = e.format(),
        e;
    for (var P = x.slice(-1)[0], w = (e.host || s.host || x.length > 1) && (P === "." || P === "..") || P === "", A = 0, I = x.length; I >= 0; I--)
        P = x[I],
        P === "." ? x.splice(I, 1) : P === ".." ? (x.splice(I, 1),
        A++) : A && (x.splice(I, 1),
        A--);
    if (!g && !_)
        for (; A--; A)
            x.unshift("..");
    g && x[0] !== "" && (!x[0] || x[0].charAt(0) !== "/") && x.unshift(""),
    w && x.join("/").substr(-1) !== "/" && x.push("");
    var F = x[0] === "" || x[0] && x[0].charAt(0) === "/";
    if (v) {
        e.hostname = F ? "" : x.length ? x.shift() : "",
        e.host = e.hostname;
        var E = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
        E && (e.auth = E.shift(),
        e.hostname = E.shift(),
        e.host = e.hostname)
    }
    return g = g || e.host && x.length,
    g && !F && x.unshift(""),
    x.length > 0 ? e.pathname = x.join("/") : (e.pathname = null,
    e.path = null),
    (e.pathname !== null || e.search !== null) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")),
    e.auth = s.auth || e.auth,
    e.slashes = e.slashes || s.slashes,
    e.href = e.format(),
    e
}
;
Tr.prototype.parseHost = function() {
    var s = this.host
      , t = HC.exec(s);
    t && (t = t[0],
    t !== ":" && (this.port = t.substr(1)),
    s = s.substr(0, s.length - t.length)),
    s && (this.hostname = s)
}
;
var KC = Pc
  , ZC = YC
  , QC = qC;
const P_ = {};
function Et(s, t, e=3) {
    if (P_[t])
        return;
    let i = new Error().stack;
    typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${s}`) : (i = i.split(`
`).splice(e).join(`
`),
    console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${s}`),
    console.warn(i),
    console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${s}`),
    console.warn(i))),
    P_[t] = !0
}
const JC = {
    get parse() {
        return Et("7.3.0", "utils.url.parse is deprecated, use native URL API instead."),
        KC
    },
    get format() {
        return Et("7.3.0", "utils.url.format is deprecated, use native URL API instead."),
        QC
    },
    get resolve() {
        return Et("7.3.0", "utils.url.resolve is deprecated, use native URL API instead."),
        ZC
    }
};
function dr(s) {
    if (typeof s != "string")
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(s)}`)
}
function wa(s) {
    return s.split("?")[0].split("#")[0]
}
function tP(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}
function eP(s, t, e) {
    return s.replace(new RegExp(tP(t),"g"), e)
}
function iP(s, t) {
    let e = ""
      , i = 0
      , r = -1
      , n = 0
      , o = -1;
    for (let a = 0; a <= s.length; ++a) {
        if (a < s.length)
            o = s.charCodeAt(a);
        else {
            if (o === 47)
                break;
            o = 47
        }
        if (o === 47) {
            if (!(r === a - 1 || n === 1))
                if (r !== a - 1 && n === 2) {
                    if (e.length < 2 || i !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
                        if (e.length > 2) {
                            const l = e.lastIndexOf("/");
                            if (l !== e.length - 1) {
                                l === -1 ? (e = "",
                                i = 0) : (e = e.slice(0, l),
                                i = e.length - 1 - e.lastIndexOf("/")),
                                r = a,
                                n = 0;
                                continue
                            }
                        } else if (e.length === 2 || e.length === 1) {
                            e = "",
                            i = 0,
                            r = a,
                            n = 0;
                            continue
                        }
                    }
                    t && (e.length > 0 ? e += "/.." : e = "..",
                    i = 2)
                } else
                    e.length > 0 ? e += `/${s.slice(r + 1, a)}` : e = s.slice(r + 1, a),
                    i = a - r - 1;
            r = a,
            n = 0
        } else
            o === 46 && n !== -1 ? ++n : n = -1
    }
    return e
}
const Ee = {
    toPosix(s) {
        return eP(s, "\\", "/")
    },
    isUrl(s) {
        return /^https?:/.test(this.toPosix(s))
    },
    isDataUrl(s) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(s)
    },
    isBlobUrl(s) {
        return s.startsWith("blob:")
    },
    hasProtocol(s) {
        return /^[^/:]+:/.test(this.toPosix(s))
    },
    getProtocol(s) {
        dr(s),
        s = this.toPosix(s);
        const t = /^file:\/\/\//.exec(s);
        if (t)
            return t[0];
        const e = /^[^/:]+:\/{0,2}/.exec(s);
        return e ? e[0] : ""
    },
    toAbsolute(s, t, e) {
        if (dr(s),
        this.isDataUrl(s) || this.isBlobUrl(s))
            return s;
        const i = wa(this.toPosix(t ?? nt.ADAPTER.getBaseUrl()))
          , r = wa(this.toPosix(e ?? this.rootname(i)));
        return s = this.toPosix(s),
        s.startsWith("/") ? Ee.join(r, s.slice(1)) : this.isAbsolute(s) ? s : this.join(i, s)
    },
    normalize(s) {
        if (dr(s),
        s.length === 0)
            return ".";
        if (this.isDataUrl(s) || this.isBlobUrl(s))
            return s;
        s = this.toPosix(s);
        let t = "";
        const e = s.startsWith("/");
        this.hasProtocol(s) && (t = this.rootname(s),
        s = s.slice(t.length));
        const i = s.endsWith("/");
        return s = iP(s, !1),
        s.length > 0 && i && (s += "/"),
        e ? `/${s}` : t + s
    },
    isAbsolute(s) {
        return dr(s),
        s = this.toPosix(s),
        this.hasProtocol(s) ? !0 : s.startsWith("/")
    },
    join(...s) {
        if (s.length === 0)
            return ".";
        let t;
        for (let e = 0; e < s.length; ++e) {
            const i = s[e];
            if (dr(i),
            i.length > 0)
                if (t === void 0)
                    t = i;
                else {
                    const r = s[e - 1] ?? "";
                    this.joinExtensions.includes(this.extname(r).toLowerCase()) ? t += `/../${i}` : t += `/${i}`
                }
        }
        return t === void 0 ? "." : this.normalize(t)
    },
    dirname(s) {
        if (dr(s),
        s.length === 0)
            return ".";
        s = this.toPosix(s);
        let t = s.charCodeAt(0);
        const e = t === 47;
        let i = -1
          , r = !0;
        const n = this.getProtocol(s)
          , o = s;
        s = s.slice(n.length);
        for (let a = s.length - 1; a >= 1; --a)
            if (t = s.charCodeAt(a),
            t === 47) {
                if (!r) {
                    i = a;
                    break
                }
            } else
                r = !1;
        return i === -1 ? e ? "/" : this.isUrl(o) ? n + s : n : e && i === 1 ? "//" : n + s.slice(0, i)
    },
    rootname(s) {
        dr(s),
        s = this.toPosix(s);
        let t = "";
        if (s.startsWith("/") ? t = "/" : t = this.getProtocol(s),
        this.isUrl(s)) {
            const e = s.indexOf("/", t.length);
            e !== -1 ? t = s.slice(0, e) : t = s,
            t.endsWith("/") || (t += "/")
        }
        return t
    },
    basename(s, t) {
        dr(s),
        t && dr(t),
        s = wa(this.toPosix(s));
        let e = 0, i = -1, r = !0, n;
        if (t !== void 0 && t.length > 0 && t.length <= s.length) {
            if (t.length === s.length && t === s)
                return "";
            let o = t.length - 1
              , a = -1;
            for (n = s.length - 1; n >= 0; --n) {
                const l = s.charCodeAt(n);
                if (l === 47) {
                    if (!r) {
                        e = n + 1;
                        break
                    }
                } else
                    a === -1 && (r = !1,
                    a = n + 1),
                    o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (i = n) : (o = -1,
                    i = a))
            }
            return e === i ? i = a : i === -1 && (i = s.length),
            s.slice(e, i)
        }
        for (n = s.length - 1; n >= 0; --n)
            if (s.charCodeAt(n) === 47) {
                if (!r) {
                    e = n + 1;
                    break
                }
            } else
                i === -1 && (r = !1,
                i = n + 1);
        return i === -1 ? "" : s.slice(e, i)
    },
    extname(s) {
        dr(s),
        s = wa(this.toPosix(s));
        let t = -1
          , e = 0
          , i = -1
          , r = !0
          , n = 0;
        for (let o = s.length - 1; o >= 0; --o) {
            const a = s.charCodeAt(o);
            if (a === 47) {
                if (!r) {
                    e = o + 1;
                    break
                }
                continue
            }
            i === -1 && (r = !1,
            i = o + 1),
            a === 46 ? t === -1 ? t = o : n !== 1 && (n = 1) : t !== -1 && (n = -1)
        }
        return t === -1 || i === -1 || n === 0 || n === 1 && t === i - 1 && t === e + 1 ? "" : s.slice(t, i)
    },
    parse(s) {
        dr(s);
        const t = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (s.length === 0)
            return t;
        s = wa(this.toPosix(s));
        let e = s.charCodeAt(0);
        const i = this.isAbsolute(s);
        let r;
        t.root = this.rootname(s),
        i || this.hasProtocol(s) ? r = 1 : r = 0;
        let n = -1
          , o = 0
          , a = -1
          , l = !0
          , h = s.length - 1
          , u = 0;
        for (; h >= r; --h) {
            if (e = s.charCodeAt(h),
            e === 47) {
                if (!l) {
                    o = h + 1;
                    break
                }
                continue
            }
            a === -1 && (l = !1,
            a = h + 1),
            e === 46 ? n === -1 ? n = h : u !== 1 && (u = 1) : n !== -1 && (u = -1)
        }
        return n === -1 || a === -1 || u === 0 || u === 1 && n === a - 1 && n === o + 1 ? a !== -1 && (o === 0 && i ? t.base = t.name = s.slice(1, a) : t.base = t.name = s.slice(o, a)) : (o === 0 && i ? (t.name = s.slice(1, n),
        t.base = s.slice(1, a)) : (t.name = s.slice(o, n),
        t.base = s.slice(o, a)),
        t.ext = s.slice(n, a)),
        t.dir = this.dirname(s),
        t
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
};
let Sd;
async function i1() {
    return Sd ?? (Sd = (async()=>{
        const s = document.createElement("canvas").getContext("webgl");
        if (!s)
            return _i.UNPACK;
        const t = await new Promise(n=>{
            const o = document.createElement("video");
            o.onloadeddata = ()=>n(o),
            o.onerror = ()=>n(null),
            o.autoplay = !1,
            o.crossOrigin = "anonymous",
            o.preload = "auto",
            o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",
            o.load()
        }
        );
        if (!t)
            return _i.UNPACK;
        const e = s.createTexture();
        s.bindTexture(s.TEXTURE_2D, e);
        const i = s.createFramebuffer();
        s.bindFramebuffer(s.FRAMEBUFFER, i),
        s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e, 0),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, s.NONE),
        s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, t);
        const r = new Uint8Array(4);
        return s.readPixels(0, 0, 1, 1, s.RGBA, s.UNSIGNED_BYTE, r),
        s.deleteFramebuffer(i),
        s.deleteTexture(e),
        s.getExtension("WEBGL_lose_context")?.loseContext(),
        r[0] <= r[3] ? _i.PMA : _i.UNPACK
    }
    )()),
    Sd
}
function rP() {
    Et("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
}
function sP() {
    Et("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`)
}
let Cd;
function r1() {
    return typeof Cd > "u" && (Cd = function() {
        const s = {
            stencil: !0,
            failIfMajorPerformanceCaveat: nt.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!nt.ADAPTER.getWebGLRenderingContext())
                return !1;
            const t = nt.ADAPTER.createCanvas();
            let e = t.getContext("webgl", s) || t.getContext("experimental-webgl", s);
            const i = !!e?.getContextAttributes()?.stencil;
            if (e) {
                const r = e.getExtension("WEBGL_lose_context");
                r && r.loseContext()
            }
            return e = null,
            i
        } catch {
            return !1
        }
    }()),
    Cd
}
var nP = {
    grad: .9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
}
  , ns = function(s) {
    return typeof s == "string" ? s.length > 0 : typeof s == "number"
}
  , ke = function(s, t, e) {
    return t === void 0 && (t = 0),
    e === void 0 && (e = Math.pow(10, t)),
    Math.round(e * s) / e + 0
}
  , nr = function(s, t, e) {
    return t === void 0 && (t = 0),
    e === void 0 && (e = 1),
    s > e ? e : s > t ? s : t
}
  , s1 = function(s) {
    return (s = isFinite(s) ? s % 360 : 0) > 0 ? s : s + 360
}
  , I_ = function(s) {
    return {
        r: nr(s.r, 0, 255),
        g: nr(s.g, 0, 255),
        b: nr(s.b, 0, 255),
        a: nr(s.a)
    }
}
  , Pd = function(s) {
    return {
        r: ke(s.r),
        g: ke(s.g),
        b: ke(s.b),
        a: ke(s.a, 3)
    }
}
  , oP = /^#([0-9a-f]{3,8})$/i
  , Mh = function(s) {
    var t = s.toString(16);
    return t.length < 2 ? "0" + t : t
}
  , n1 = function(s) {
    var t = s.r
      , e = s.g
      , i = s.b
      , r = s.a
      , n = Math.max(t, e, i)
      , o = n - Math.min(t, e, i)
      , a = o ? n === t ? (e - i) / o : n === e ? 2 + (i - t) / o : 4 + (t - e) / o : 0;
    return {
        h: 60 * (a < 0 ? a + 6 : a),
        s: n ? o / n * 100 : 0,
        v: n / 255 * 100,
        a: r
    }
}
  , o1 = function(s) {
    var t = s.h
      , e = s.s
      , i = s.v
      , r = s.a;
    t = t / 360 * 6,
    e /= 100,
    i /= 100;
    var n = Math.floor(t)
      , o = i * (1 - e)
      , a = i * (1 - (t - n) * e)
      , l = i * (1 - (1 - t + n) * e)
      , h = n % 6;
    return {
        r: 255 * [i, a, o, o, l, i][h],
        g: 255 * [l, i, i, a, o, o][h],
        b: 255 * [o, o, l, i, i, a][h],
        a: r
    }
}
  , R_ = function(s) {
    return {
        h: s1(s.h),
        s: nr(s.s, 0, 100),
        l: nr(s.l, 0, 100),
        a: nr(s.a)
    }
}
  , M_ = function(s) {
    return {
        h: ke(s.h),
        s: ke(s.s),
        l: ke(s.l),
        a: ke(s.a, 3)
    }
}
  , F_ = function(s) {
    return o1((e = (t = s).s,
    {
        h: t.h,
        s: (e *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0 ? 2 * e / (i + e) * 100 : 0,
        v: i + e,
        a: t.a
    }));
    var t, e, i
}
  , pl = function(s) {
    return {
        h: (t = n1(s)).h,
        s: (r = (200 - (e = t.s)) * (i = t.v) / 100) > 0 && r < 200 ? e * i / 100 / (r <= 100 ? r : 200 - r) * 100 : 0,
        l: r / 2,
        a: t.a
    };
    var t, e, i, r
}
  , aP = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , lP = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , hP = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , uP = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i
  , tp = {
    string: [[function(s) {
        var t = oP.exec(s);
        return t ? (s = t[1]).length <= 4 ? {
            r: parseInt(s[0] + s[0], 16),
            g: parseInt(s[1] + s[1], 16),
            b: parseInt(s[2] + s[2], 16),
            a: s.length === 4 ? ke(parseInt(s[3] + s[3], 16) / 255, 2) : 1
        } : s.length === 6 || s.length === 8 ? {
            r: parseInt(s.substr(0, 2), 16),
            g: parseInt(s.substr(2, 2), 16),
            b: parseInt(s.substr(4, 2), 16),
            a: s.length === 8 ? ke(parseInt(s.substr(6, 2), 16) / 255, 2) : 1
        } : null : null
    }
    , "hex"], [function(s) {
        var t = hP.exec(s) || uP.exec(s);
        return t ? t[2] !== t[4] || t[4] !== t[6] ? null : I_({
            r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
            g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
            b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
            a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
        }) : null
    }
    , "rgb"], [function(s) {
        var t = aP.exec(s) || lP.exec(s);
        if (!t)
            return null;
        var e, i, r = R_({
            h: (e = t[1],
            i = t[2],
            i === void 0 && (i = "deg"),
            Number(e) * (nP[i] || 1)),
            s: Number(t[3]),
            l: Number(t[4]),
            a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
        });
        return F_(r)
    }
    , "hsl"]],
    object: [[function(s) {
        var t = s.r
          , e = s.g
          , i = s.b
          , r = s.a
          , n = r === void 0 ? 1 : r;
        return ns(t) && ns(e) && ns(i) ? I_({
            r: Number(t),
            g: Number(e),
            b: Number(i),
            a: Number(n)
        }) : null
    }
    , "rgb"], [function(s) {
        var t = s.h
          , e = s.s
          , i = s.l
          , r = s.a
          , n = r === void 0 ? 1 : r;
        if (!ns(t) || !ns(e) || !ns(i))
            return null;
        var o = R_({
            h: Number(t),
            s: Number(e),
            l: Number(i),
            a: Number(n)
        });
        return F_(o)
    }
    , "hsl"], [function(s) {
        var t = s.h
          , e = s.s
          , i = s.v
          , r = s.a
          , n = r === void 0 ? 1 : r;
        if (!ns(t) || !ns(e) || !ns(i))
            return null;
        var o = function(a) {
            return {
                h: s1(a.h),
                s: nr(a.s, 0, 100),
                v: nr(a.v, 0, 100),
                a: nr(a.a)
            }
        }({
            h: Number(t),
            s: Number(e),
            v: Number(i),
            a: Number(n)
        });
        return o1(o)
    }
    , "hsv"]]
}
  , B_ = function(s, t) {
    for (var e = 0; e < t.length; e++) {
        var i = t[e][0](s);
        if (i)
            return [i, t[e][1]]
    }
    return [null, void 0]
}
  , cP = function(s) {
    return typeof s == "string" ? B_(s.trim(), tp.string) : typeof s == "object" && s !== null ? B_(s, tp.object) : [null, void 0]
}
  , Id = function(s, t) {
    var e = pl(s);
    return {
        h: e.h,
        s: nr(e.s + 100 * t, 0, 100),
        l: e.l,
        a: e.a
    }
}
  , Rd = function(s) {
    return (299 * s.r + 587 * s.g + 114 * s.b) / 1e3 / 255
}
  , O_ = function(s, t) {
    var e = pl(s);
    return {
        h: e.h,
        s: e.s,
        l: nr(e.l + 100 * t, 0, 100),
        a: e.a
    }
}
  , ep = function() {
    function s(t) {
        this.parsed = cP(t)[0],
        this.rgba = this.parsed || {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        }
    }
    return s.prototype.isValid = function() {
        return this.parsed !== null
    }
    ,
    s.prototype.brightness = function() {
        return ke(Rd(this.rgba), 2)
    }
    ,
    s.prototype.isDark = function() {
        return Rd(this.rgba) < .5
    }
    ,
    s.prototype.isLight = function() {
        return Rd(this.rgba) >= .5
    }
    ,
    s.prototype.toHex = function() {
        return t = Pd(this.rgba),
        e = t.r,
        i = t.g,
        r = t.b,
        o = (n = t.a) < 1 ? Mh(ke(255 * n)) : "",
        "#" + Mh(e) + Mh(i) + Mh(r) + o;
        var t, e, i, r, n, o
    }
    ,
    s.prototype.toRgb = function() {
        return Pd(this.rgba)
    }
    ,
    s.prototype.toRgbString = function() {
        return t = Pd(this.rgba),
        e = t.r,
        i = t.g,
        r = t.b,
        (n = t.a) < 1 ? "rgba(" + e + ", " + i + ", " + r + ", " + n + ")" : "rgb(" + e + ", " + i + ", " + r + ")";
        var t, e, i, r, n
    }
    ,
    s.prototype.toHsl = function() {
        return M_(pl(this.rgba))
    }
    ,
    s.prototype.toHslString = function() {
        return t = M_(pl(this.rgba)),
        e = t.h,
        i = t.s,
        r = t.l,
        (n = t.a) < 1 ? "hsla(" + e + ", " + i + "%, " + r + "%, " + n + ")" : "hsl(" + e + ", " + i + "%, " + r + "%)";
        var t, e, i, r, n
    }
    ,
    s.prototype.toHsv = function() {
        return t = n1(this.rgba),
        {
            h: ke(t.h),
            s: ke(t.s),
            v: ke(t.v),
            a: ke(t.a, 3)
        };
        var t
    }
    ,
    s.prototype.invert = function() {
        return Or({
            r: 255 - (t = this.rgba).r,
            g: 255 - t.g,
            b: 255 - t.b,
            a: t.a
        });
        var t
    }
    ,
    s.prototype.saturate = function(t) {
        return t === void 0 && (t = .1),
        Or(Id(this.rgba, t))
    }
    ,
    s.prototype.desaturate = function(t) {
        return t === void 0 && (t = .1),
        Or(Id(this.rgba, -t))
    }
    ,
    s.prototype.grayscale = function() {
        return Or(Id(this.rgba, -1))
    }
    ,
    s.prototype.lighten = function(t) {
        return t === void 0 && (t = .1),
        Or(O_(this.rgba, t))
    }
    ,
    s.prototype.darken = function(t) {
        return t === void 0 && (t = .1),
        Or(O_(this.rgba, -t))
    }
    ,
    s.prototype.rotate = function(t) {
        return t === void 0 && (t = 15),
        this.hue(this.hue() + t)
    }
    ,
    s.prototype.alpha = function(t) {
        return typeof t == "number" ? Or({
            r: (e = this.rgba).r,
            g: e.g,
            b: e.b,
            a: t
        }) : ke(this.rgba.a, 3);
        var e
    }
    ,
    s.prototype.hue = function(t) {
        var e = pl(this.rgba);
        return typeof t == "number" ? Or({
            h: t,
            s: e.s,
            l: e.l,
            a: e.a
        }) : ke(e.h)
    }
    ,
    s.prototype.isEqual = function(t) {
        return this.toHex() === Or(t).toHex()
    }
    ,
    s
}()
  , Or = function(s) {
    return s instanceof ep ? s : new ep(s)
}
  , k_ = []
  , dP = function(s) {
    s.forEach(function(t) {
        k_.indexOf(t) < 0 && (t(ep, tp),
        k_.push(t))
    })
};
function fP(s, t) {
    var e = {
        white: "#ffffff",
        bisque: "#ffe4c4",
        blue: "#0000ff",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        azure: "#f0ffff",
        whitesmoke: "#f5f5f5",
        papayawhip: "#ffefd5",
        plum: "#dda0dd",
        blanchedalmond: "#ffebcd",
        black: "#000000",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gainsboro: "#dcdcdc",
        cornsilk: "#fff8dc",
        cornflowerblue: "#6495ed",
        burlywood: "#deb887",
        aquamarine: "#7fffd4",
        beige: "#f5f5dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkkhaki: "#bdb76b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        peachpuff: "#ffdab9",
        darkmagenta: "#8b008b",
        darkred: "#8b0000",
        darkorchid: "#9932cc",
        darkorange: "#ff8c00",
        darkslateblue: "#483d8b",
        gray: "#808080",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        wheat: "#f5deb3",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        ghostwhite: "#f8f8ff",
        darkviolet: "#9400d3",
        magenta: "#ff00ff",
        green: "#008000",
        dodgerblue: "#1e90ff",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        blueviolet: "#8a2be2",
        forestgreen: "#228b22",
        lawngreen: "#7cfc00",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        fuchsia: "#ff00ff",
        brown: "#a52a2a",
        maroon: "#800000",
        mediumblue: "#0000cd",
        lightcoral: "#f08080",
        darkturquoise: "#00ced1",
        lightcyan: "#e0ffff",
        ivory: "#fffff0",
        lightyellow: "#ffffe0",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        linen: "#faf0e6",
        mediumaquamarine: "#66cdaa",
        lemonchiffon: "#fffacd",
        lime: "#00ff00",
        khaki: "#f0e68c",
        mediumseagreen: "#3cb371",
        limegreen: "#32cd32",
        mediumspringgreen: "#00fa9a",
        lightskyblue: "#87cefa",
        lightblue: "#add8e6",
        midnightblue: "#191970",
        lightpink: "#ffb6c1",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        mintcream: "#f5fffa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        navajowhite: "#ffdead",
        navy: "#000080",
        mediumvioletred: "#c71585",
        powderblue: "#b0e0e6",
        palegoldenrod: "#eee8aa",
        oldlace: "#fdf5e6",
        paleturquoise: "#afeeee",
        mediumturquoise: "#48d1cc",
        mediumorchid: "#ba55d3",
        rebeccapurple: "#663399",
        lightsteelblue: "#b0c4de",
        mediumslateblue: "#7b68ee",
        thistle: "#d8bfd8",
        tan: "#d2b48c",
        orchid: "#da70d6",
        mediumpurple: "#9370db",
        purple: "#800080",
        pink: "#ffc0cb",
        skyblue: "#87ceeb",
        springgreen: "#00ff7f",
        palegreen: "#98fb98",
        red: "#ff0000",
        yellow: "#ffff00",
        slateblue: "#6a5acd",
        lavenderblush: "#fff0f5",
        peru: "#cd853f",
        palevioletred: "#db7093",
        violet: "#ee82ee",
        teal: "#008080",
        slategray: "#708090",
        slategrey: "#708090",
        aliceblue: "#f0f8ff",
        darkseagreen: "#8fbc8f",
        darkolivegreen: "#556b2f",
        greenyellow: "#adff2f",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        tomato: "#ff6347",
        silver: "#c0c0c0",
        sienna: "#a0522d",
        lavender: "#e6e6fa",
        lightgreen: "#90ee90",
        orange: "#ffa500",
        orangered: "#ff4500",
        steelblue: "#4682b4",
        royalblue: "#4169e1",
        turquoise: "#40e0d0",
        yellowgreen: "#9acd32",
        salmon: "#fa8072",
        saddlebrown: "#8b4513",
        sandybrown: "#f4a460",
        rosybrown: "#bc8f8f",
        darksalmon: "#e9967a",
        lightgoldenrodyellow: "#fafad2",
        snow: "#fffafa",
        lightgrey: "#d3d3d3",
        lightgray: "#d3d3d3",
        dimgray: "#696969",
        dimgrey: "#696969",
        olivedrab: "#6b8e23",
        olive: "#808000"
    }
      , i = {};
    for (var r in e)
        i[e[r]] = r;
    var n = {};
    s.prototype.toName = function(o) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
            return "transparent";
        var a, l, h = i[this.toHex()];
        if (h)
            return h;
        if (o?.closest) {
            var u = this.toRgb()
              , c = 1 / 0
              , d = "black";
            if (!n.length)
                for (var f in e)
                    n[f] = new s(e[f]).toRgb();
            for (var p in e) {
                var m = (a = u,
                l = n[p],
                Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
                m < c && (c = m,
                d = p)
            }
            return d
        }
    }
    ,
    t.string.push([function(o) {
        var a = o.toLowerCase()
          , l = a === "transparent" ? "#0000" : e[a];
        return l ? new s(l).toRgb() : null
    }
    , "name"])
}
dP([fP]);
const po = class uu {
    constructor(t=16777215) {
        this._value = null,
        this._components = new Float32Array(4),
        this._components.fill(1),
        this._int = 16777215,
        this.value = t
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(t) {
        return this.value = t,
        this
    }
    set value(t) {
        if (t instanceof uu)
            this._value = this.cloneSource(t._value),
            this._int = t._int,
            this._components.set(t._components);
        else {
            if (t === null)
                throw new Error("Cannot set PIXI.Color#value to null");
            (this._value === null || !this.isSourceEqual(this._value, t)) && (this.normalize(t),
            this._value = this.cloneSource(t))
        }
    }
    get value() {
        return this._value
    }
    cloneSource(t) {
        return typeof t == "string" || typeof t == "number" || t instanceof Number || t === null ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : typeof t == "object" && t !== null ? {
            ...t
        } : t
    }
    isSourceEqual(t, e) {
        const i = typeof t;
        if (i !== typeof e)
            return !1;
        if (i === "number" || i === "string" || t instanceof Number)
            return t === e;
        if (Array.isArray(t) && Array.isArray(e) || ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
            return t.length !== e.length ? !1 : t.every((r,n)=>r === e[n]);
        if (t !== null && e !== null) {
            const r = Object.keys(t)
              , n = Object.keys(e);
            return r.length !== n.length ? !1 : r.every(o=>t[o] === e[o])
        }
        return t === e
    }
    toRgba() {
        const [t,e,i,r] = this._components;
        return {
            r: t,
            g: e,
            b: i,
            a: r
        }
    }
    toRgb() {
        const [t,e,i] = this._components;
        return {
            r: t,
            g: e,
            b: i
        }
    }
    toRgbaString() {
        const [t,e,i] = this.toUint8RgbArray();
        return `rgba(${t},${e},${i},${this.alpha})`
    }
    toUint8RgbArray(t) {
        const [e,i,r] = this._components;
        return t = t ?? [],
        t[0] = Math.round(e * 255),
        t[1] = Math.round(i * 255),
        t[2] = Math.round(r * 255),
        t
    }
    toRgbArray(t) {
        t = t ?? [];
        const [e,i,r] = this._components;
        return t[0] = e,
        t[1] = i,
        t[2] = r,
        t
    }
    toNumber() {
        return this._int
    }
    toLittleEndianNumber() {
        const t = this._int;
        return (t >> 16) + (t & 65280) + ((t & 255) << 16)
    }
    multiply(t) {
        const [e,i,r,n] = uu.temp.setValue(t)._components;
        return this._components[0] *= e,
        this._components[1] *= i,
        this._components[2] *= r,
        this._components[3] *= n,
        this.refreshInt(),
        this._value = null,
        this
    }
    premultiply(t, e=!0) {
        return e && (this._components[0] *= t,
        this._components[1] *= t,
        this._components[2] *= t),
        this._components[3] = t,
        this.refreshInt(),
        this._value = null,
        this
    }
    toPremultiplied(t, e=!0) {
        if (t === 1)
            return (255 << 24) + this._int;
        if (t === 0)
            return e ? 0 : this._int;
        let i = this._int >> 16 & 255
          , r = this._int >> 8 & 255
          , n = this._int & 255;
        return e && (i = i * t + .5 | 0,
        r = r * t + .5 | 0,
        n = n * t + .5 | 0),
        (t * 255 << 24) + (i << 16) + (r << 8) + n
    }
    toHex() {
        const t = this._int.toString(16);
        return `#${"000000".substring(0, 6 - t.length) + t}`
    }
    toHexa() {
        const t = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - t.length) + t
    }
    setAlpha(t) {
        return this._components[3] = this._clamp(t),
        this
    }
    round(t) {
        const [e,i,r] = this._components;
        return this._components[0] = Math.round(e * t) / t,
        this._components[1] = Math.round(i * t) / t,
        this._components[2] = Math.round(r * t) / t,
        this.refreshInt(),
        this._value = null,
        this
    }
    toArray(t) {
        t = t ?? [];
        const [e,i,r,n] = this._components;
        return t[0] = e,
        t[1] = i,
        t[2] = r,
        t[3] = n,
        t
    }
    normalize(t) {
        let e, i, r, n;
        if ((typeof t == "number" || t instanceof Number) && t >= 0 && t <= 16777215) {
            const o = t;
            e = (o >> 16 & 255) / 255,
            i = (o >> 8 & 255) / 255,
            r = (o & 255) / 255,
            n = 1
        } else if ((Array.isArray(t) || t instanceof Float32Array) && t.length >= 3 && t.length <= 4)
            t = this._clamp(t),
            [e,i,r,n=1] = t;
        else if ((t instanceof Uint8Array || t instanceof Uint8ClampedArray) && t.length >= 3 && t.length <= 4)
            t = this._clamp(t, 0, 255),
            [e,i,r,n=255] = t,
            e /= 255,
            i /= 255,
            r /= 255,
            n /= 255;
        else if (typeof t == "string" || typeof t == "object") {
            if (typeof t == "string") {
                const a = uu.HEX_PATTERN.exec(t);
                a && (t = `#${a[2]}`)
            }
            const o = Or(t);
            o.isValid() && ({r: e, g: i, b: r, a: n} = o.rgba,
            e /= 255,
            i /= 255,
            r /= 255)
        }
        if (e !== void 0)
            this._components[0] = e,
            this._components[1] = i,
            this._components[2] = r,
            this._components[3] = n,
            this.refreshInt();
        else
            throw new Error(`Unable to convert color ${t}`)
    }
    refreshInt() {
        this._clamp(this._components);
        const [t,e,i] = this._components;
        this._int = (t * 255 << 16) + (e * 255 << 8) + (i * 255 | 0)
    }
    _clamp(t, e=0, i=1) {
        return typeof t == "number" ? Math.min(Math.max(t, e), i) : (t.forEach((r,n)=>{
            t[n] = Math.min(Math.max(r, e), i)
        }
        ),
        t)
    }
}
;
po.shared = new po,
po.temp = new po,
po.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let zt = po;
function pP(s, t=[]) {
    return Et("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"),
    zt.shared.setValue(s).toRgbArray(t)
}
function a1(s) {
    return Et("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
    zt.shared.setValue(s).toHex()
}
function mP(s) {
    return Et("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"),
    zt.shared.setValue(s).toNumber()
}
function l1(s) {
    return Et("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
    zt.shared.setValue(s).toNumber()
}
function gP() {
    const s = []
      , t = [];
    for (let i = 0; i < 32; i++)
        s[i] = i,
        t[i] = i;
    s[_t.NORMAL_NPM] = _t.NORMAL,
    s[_t.ADD_NPM] = _t.ADD,
    s[_t.SCREEN_NPM] = _t.SCREEN,
    t[_t.NORMAL] = _t.NORMAL_NPM,
    t[_t.ADD] = _t.ADD_NPM,
    t[_t.SCREEN] = _t.SCREEN_NPM;
    const e = [];
    return e.push(t),
    e.push(s),
    e
}
const Om = gP();
function km(s, t) {
    return Om[t ? 1 : 0][s]
}
function _P(s, t, e, i=!0) {
    return Et("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"),
    zt.shared.setValue(s).premultiply(t, i).toArray(e ?? new Float32Array(4))
}
function yP(s, t) {
    return Et("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"),
    zt.shared.setValue(s).toPremultiplied(t)
}
function vP(s, t, e, i=!0) {
    return Et("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"),
    zt.shared.setValue(s).premultiply(t, i).toArray(e ?? new Float32Array(4))
}
const h1 = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function u1(s, t=null) {
    const e = s * 6;
    if (t = t || new Uint16Array(e),
    t.length !== e)
        throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${e}`);
    for (let i = 0, r = 0; i < e; i += 6,
    r += 4)
        t[i + 0] = r + 0,
        t[i + 1] = r + 1,
        t[i + 2] = r + 2,
        t[i + 3] = r + 0,
        t[i + 4] = r + 2,
        t[i + 5] = r + 3;
    return t
}
function Ic(s) {
    if (s.BYTES_PER_ELEMENT === 4)
        return s instanceof Float32Array ? "Float32Array" : s instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (s.BYTES_PER_ELEMENT === 2) {
        if (s instanceof Uint16Array)
            return "Uint16Array"
    } else if (s.BYTES_PER_ELEMENT === 1 && s instanceof Uint8Array)
        return "Uint8Array";
    return null
}
const xP = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function bP(s, t) {
    let e = 0
      , i = 0;
    const r = {};
    for (let l = 0; l < s.length; l++)
        i += t[l],
        e += s[l].length;
    const n = new ArrayBuffer(e * 4);
    let o = null
      , a = 0;
    for (let l = 0; l < s.length; l++) {
        const h = t[l]
          , u = s[l]
          , c = Ic(u);
        r[c] || (r[c] = new xP[c](n)),
        o = r[c];
        for (let d = 0; d < u.length; d++) {
            const f = (d / h | 0) * i + a
              , p = d % h;
            o[f + p] = u[d]
        }
        a += h
    }
    return new Float32Array(n)
}
function Rl(s) {
    return s += s === 0 ? 1 : 0,
    --s,
    s |= s >>> 1,
    s |= s >>> 2,
    s |= s >>> 4,
    s |= s >>> 8,
    s |= s >>> 16,
    s + 1
}
function ip(s) {
    return !(s & s - 1) && !!s
}
function rp(s) {
    let t = (s > 65535 ? 1 : 0) << 4;
    s >>>= t;
    let e = (s > 255 ? 1 : 0) << 3;
    return s >>>= e,
    t |= e,
    e = (s > 15 ? 1 : 0) << 2,
    s >>>= e,
    t |= e,
    e = (s > 3 ? 1 : 0) << 1,
    s >>>= e,
    t |= e,
    t | s >> 1
}
function Nn(s, t, e) {
    const i = s.length;
    let r;
    if (t >= i || e === 0)
        return;
    e = t + e > i ? i - t : e;
    const n = i - e;
    for (r = t; r < n; ++r)
        s[r] = s[r + e];
    s.length = n
}
function gs(s) {
    return s === 0 ? 0 : s < 0 ? -1 : 1
}
let wP = 0;
function Js() {
    return ++wP
}
const sp = class {
    constructor(s, t, e, i) {
        this.left = s,
        this.top = t,
        this.right = e,
        this.bottom = i
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
}
;
sp.EMPTY = new sp(0,0,0,0);
let np = sp;
const op = {}
  , ci = Object.create(null)
  , Bi = Object.create(null);
function EP() {
    let s;
    for (s in ci)
        ci[s].destroy();
    for (s in Bi)
        Bi[s].destroy()
}
function TP() {
    let s;
    for (s in ci)
        delete ci[s];
    for (s in Bi)
        delete Bi[s]
}
class c1 {
    constructor(t, e, i) {
        this._canvas = nt.ADAPTER.createCanvas(),
        this._context = this._canvas.getContext("2d"),
        this.resolution = i || nt.RESOLUTION,
        this.resize(t, e)
    }
    clear() {
        this._checkDestroyed(),
        this._context.setTransform(1, 0, 0, 1, 0, 0),
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(t, e) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t * this.resolution),
        this._canvas.height = Math.round(e * this.resolution)
    }
    destroy() {
        this._context = null,
        this._canvas = null
    }
    get width() {
        return this._checkDestroyed(),
        this._canvas.width
    }
    set width(t) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t)
    }
    get height() {
        return this._checkDestroyed(),
        this._canvas.height
    }
    set height(t) {
        this._checkDestroyed(),
        this._canvas.height = Math.round(t)
    }
    get canvas() {
        return this._checkDestroyed(),
        this._canvas
    }
    get context() {
        return this._checkDestroyed(),
        this._context
    }
    _checkDestroyed() {
        if (this._canvas === null)
            throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}
function L_(s, t, e) {
    for (let i = 0, r = 4 * e * t; i < t; ++i,
    r += 4)
        if (s[r + 3] !== 0)
            return !1;
    return !0
}
function N_(s, t, e, i, r) {
    const n = 4 * t;
    for (let o = i, a = i * n + 4 * e; o <= r; ++o,
    a += n)
        if (s[a + 3] !== 0)
            return !1;
    return !0
}
function d1(s) {
    const {width: t, height: e} = s
      , i = s.getContext("2d", {
        willReadFrequently: !0
    });
    if (i === null)
        throw new TypeError("Failed to get canvas 2D context");
    const r = i.getImageData(0, 0, t, e).data;
    let n = 0
      , o = 0
      , a = t - 1
      , l = e - 1;
    for (; o < e && L_(r, t, o); )
        ++o;
    if (o === e)
        return np.EMPTY;
    for (; L_(r, t, l); )
        --l;
    for (; N_(r, t, n, o, l); )
        ++n;
    for (; N_(r, t, a, o, l); )
        --a;
    return ++a,
    ++l,
    new np(n,o,a,l)
}
function f1(s) {
    const t = d1(s)
      , {width: e, height: i} = t;
    let r = null;
    if (!t.isEmpty()) {
        const n = s.getContext("2d");
        if (n === null)
            throw new TypeError("Failed to get canvas 2D context");
        r = n.getImageData(t.left, t.top, e, i)
    }
    return {
        width: e,
        height: i,
        data: r
    }
}
function DP(s) {
    const t = h1.exec(s);
    if (t)
        return {
            mediaType: t[1] ? t[1].toLowerCase() : void 0,
            subType: t[2] ? t[2].toLowerCase() : void 0,
            charset: t[3] ? t[3].toLowerCase() : void 0,
            encoding: t[4] ? t[4].toLowerCase() : void 0,
            data: t[5]
        }
}
function p1(s, t=globalThis.location) {
    if (s.startsWith("data:"))
        return "";
    t = t || globalThis.location;
    const e = new URL(s,document.baseURI);
    return e.hostname !== t.hostname || e.port !== t.port || e.protocol !== t.protocol ? "anonymous" : ""
}
function is(s, t=1) {
    const e = nt.RETINA_PREFIX?.exec(s);
    return e ? parseFloat(e[1]) : t
}
const AP = Object.freeze(Object.defineProperty({
    __proto__: null,
    BaseTextureCache: Bi,
    BoundingBox: np,
    CanvasRenderTarget: c1,
    DATA_URI: h1,
    EventEmitter: na,
    ProgramCache: op,
    TextureCache: ci,
    clearTextureCache: TP,
    correctBlendMode: km,
    createIndicesForQuads: u1,
    decomposeDataUri: DP,
    deprecation: Et,
    destroyTextureCache: EP,
    detectVideoAlphaMode: i1,
    determineCrossOrigin: p1,
    earcut: Lx,
    getBufferType: Ic,
    getCanvasBoundingBox: d1,
    getResolutionOfUrl: is,
    hex2rgb: pP,
    hex2string: a1,
    interleaveTypedArrays: bP,
    isMobile: br,
    isPow2: ip,
    isWebGLSupported: r1,
    log2: rp,
    nextPow2: Rl,
    path: Ee,
    premultiplyBlendMode: Om,
    premultiplyRgba: _P,
    premultiplyTint: yP,
    premultiplyTintToRgba: vP,
    removeItems: Nn,
    rgb2hex: l1,
    sayHello: sP,
    sign: gs,
    skipHello: rP,
    string2hex: mP,
    trimCanvas: f1,
    uid: Js,
    url: JC
}, Symbol.toStringTag, {
    value: "Module"
}));
var it = (s=>(s.Renderer = "renderer",
s.Application = "application",
s.RendererSystem = "renderer-webgl-system",
s.RendererPlugin = "renderer-webgl-plugin",
s.CanvasRendererSystem = "renderer-canvas-system",
s.CanvasRendererPlugin = "renderer-canvas-plugin",
s.Asset = "asset",
s.LoadParser = "load-parser",
s.ResolveParser = "resolve-parser",
s.CacheParser = "cache-parser",
s.DetectionParser = "detection-parser",
s))(it || {});
const ap = s=>{
    if (typeof s == "function" || typeof s == "object" && s.extension) {
        if (!s.extension)
            throw new Error("Extension class must have an extension object");
        s = {
            ...typeof s.extension != "object" ? {
                type: s.extension
            } : s.extension,
            ref: s
        }
    }
    if (typeof s == "object")
        s = {
            ...s
        };
    else
        throw new Error("Invalid extension type");
    return typeof s.type == "string" && (s.type = [s.type]),
    s
}
  , U_ = (s,t)=>ap(s).priority ?? t
  , ct = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...s) {
        return s.map(ap).forEach(t=>{
            t.type.forEach(e=>this._removeHandlers[e]?.(t))
        }
        ),
        this
    },
    add(...s) {
        return s.map(ap).forEach(t=>{
            t.type.forEach(e=>{
                const i = this._addHandlers
                  , r = this._queue;
                i[e] ? i[e]?.(t) : (r[e] = r[e] || [],
                r[e]?.push(t))
            }
            )
        }
        ),
        this
    },
    handle(s, t, e) {
        const i = this._addHandlers
          , r = this._removeHandlers;
        if (i[s] || r[s])
            throw new Error(`Extension type ${s} already has a handler`);
        i[s] = t,
        r[s] = e;
        const n = this._queue;
        return n[s] && (n[s]?.forEach(o=>t(o)),
        delete n[s]),
        this
    },
    handleByMap(s, t) {
        return this.handle(s, e=>{
            e.name && (t[e.name] = e.ref)
        }
        , e=>{
            e.name && delete t[e.name]
        }
        )
    },
    handleByList(s, t, e=-1) {
        return this.handle(s, i=>{
            t.includes(i.ref) || (t.push(i.ref),
            t.sort((r,n)=>U_(n, e) - U_(r, e)))
        }
        , i=>{
            const r = t.indexOf(i.ref);
            r !== -1 && t.splice(r, 1)
        }
        )
    }
};
class Ju {
    constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t,
        this.uint32View = new Uint32Array(this.rawBinaryData),
        this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
        this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
        this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
        this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)),
        this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
        this._int32View
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        this.rawBinaryData = null,
        this._int8View = null,
        this._uint8View = null,
        this._int16View = null,
        this._uint16View = null,
        this._int32View = null,
        this.uint32View = null,
        this.float32View = null
    }
    static sizeOf(t) {
        switch (t) {
        case "int8":
        case "uint8":
            return 1;
        case "int16":
        case "uint16":
            return 2;
        case "int32":
        case "uint32":
        case "float32":
            return 4;
        default:
            throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const SP = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
function CP(s) {
    let t = "";
    for (let e = 0; e < s; ++e)
        e > 0 && (t += `
else `),
        e < s - 1 && (t += `if(test == ${e}.0){}`);
    return t
}
function m1(s, t) {
    if (s === 0)
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const e = t.createShader(t.FRAGMENT_SHADER);
    for (; ; ) {
        const i = SP.replace(/%forloop%/gi, CP(s));
        if (t.shaderSource(e, i),
        t.compileShader(e),
        !t.getShaderParameter(e, t.COMPILE_STATUS))
            s = s / 2 | 0;
        else
            break
    }
    return s
}
const Md = 0
  , Fd = 1
  , Bd = 2
  , Od = 3
  , kd = 4
  , Ld = 5;
class Sr {
    constructor() {
        this.data = 0,
        this.blendMode = _t.NORMAL,
        this.polygonOffset = 0,
        this.blend = !0,
        this.depthMask = !0
    }
    get blend() {
        return !!(this.data & 1 << Md)
    }
    set blend(t) {
        !!(this.data & 1 << Md) !== t && (this.data ^= 1 << Md)
    }
    get offsets() {
        return !!(this.data & 1 << Fd)
    }
    set offsets(t) {
        !!(this.data & 1 << Fd) !== t && (this.data ^= 1 << Fd)
    }
    get culling() {
        return !!(this.data & 1 << Bd)
    }
    set culling(t) {
        !!(this.data & 1 << Bd) !== t && (this.data ^= 1 << Bd)
    }
    get depthTest() {
        return !!(this.data & 1 << Od)
    }
    set depthTest(t) {
        !!(this.data & 1 << Od) !== t && (this.data ^= 1 << Od)
    }
    get depthMask() {
        return !!(this.data & 1 << Ld)
    }
    set depthMask(t) {
        !!(this.data & 1 << Ld) !== t && (this.data ^= 1 << Ld)
    }
    get clockwiseFrontFace() {
        return !!(this.data & 1 << kd)
    }
    set clockwiseFrontFace(t) {
        !!(this.data & 1 << kd) !== t && (this.data ^= 1 << kd)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        this.blend = t !== _t.NONE,
        this._blendMode = t
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        this.offsets = !!t,
        this._polygonOffset = t
    }
    static for2d() {
        const t = new Sr;
        return t.depthTest = !1,
        t.blend = !0,
        t
    }
}
Sr.prototype.toString = function() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
}
;
const tc = [];
function Lm(s, t) {
    if (!s)
        return null;
    let e = "";
    if (typeof s == "string") {
        const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(s);
        i && (e = i[1].toLowerCase())
    }
    for (let i = tc.length - 1; i >= 0; --i) {
        const r = tc[i];
        if (r.test && r.test(s, e))
            return new r(s,t)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class Vi {
    constructor(t) {
        this.items = [],
        this._name = t,
        this._aliasCount = 0
    }
    emit(t, e, i, r, n, o, a, l) {
        if (arguments.length > 8)
            throw new Error("max arguments reached");
        const {name: h, items: u} = this;
        this._aliasCount++;
        for (let c = 0, d = u.length; c < d; c++)
            u[c][h](t, e, i, r, n, o, a, l);
        return u === this.items && this._aliasCount--,
        this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0,
        this.items = this.items.slice(0))
    }
    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(),
        this.remove(t),
        this.items.push(t)),
        this
    }
    remove(t) {
        const e = this.items.indexOf(t);
        return e !== -1 && (this.ensureNonAliasedItems(),
        this.items.splice(e, 1)),
        this
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return this.ensureNonAliasedItems(),
        this.items.length = 0,
        this
    }
    destroy() {
        this.removeAll(),
        this.items.length = 0,
        this._name = ""
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(Vi.prototype, {
    dispatch: {
        value: Vi.prototype.emit
    },
    run: {
        value: Vi.prototype.emit
    }
});
class ia {
    constructor(t=0, e=0) {
        this._width = t,
        this._height = e,
        this.destroyed = !1,
        this.internal = !1,
        this.onResize = new Vi("setRealSize"),
        this.onUpdate = new Vi("update"),
        this.onError = new Vi("onError")
    }
    bind(t) {
        this.onResize.add(t),
        this.onUpdate.add(t),
        this.onError.add(t),
        (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(t) {
        this.onResize.remove(t),
        this.onUpdate.remove(t),
        this.onError.remove(t)
    }
    resize(t, e) {
        (t !== this._width || e !== this._height) && (this._width = t,
        this._height = e,
        this.onResize.emit(t, e))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, e, i) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed || (this.destroyed = !0,
        this.dispose(),
        this.onError.removeAll(),
        this.onError = null,
        this.onResize.removeAll(),
        this.onResize = null,
        this.onUpdate.removeAll(),
        this.onUpdate = null)
    }
    static test(t, e) {
        return !1
    }
}
class jl extends ia {
    constructor(t, e) {
        const {width: i, height: r} = e || {};
        if (!i || !r)
            throw new Error("BufferResource width or height invalid");
        super(i, r),
        this.data = t,
        this.unpackAlignment = e.unpackAlignment ?? 4
    }
    upload(t, e, i) {
        const r = t.gl;
        r.pixelStorei(r.UNPACK_ALIGNMENT, this.unpackAlignment),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === _i.UNPACK);
        const n = e.realWidth
          , o = e.realHeight;
        return i.width === n && i.height === o ? r.texSubImage2D(e.target, 0, 0, 0, n, o, e.format, i.type, this.data) : (i.width = n,
        i.height = o,
        r.texImage2D(e.target, 0, i.internalFormat, n, o, 0, e.format, i.type, this.data)),
        !0
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return t === null || t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array
    }
}
const PP = {
    scaleMode: Wr.NEAREST,
    alphaMode: _i.NPM
}
  , lp = class mo extends na {
    constructor(t=null, e=null) {
        super(),
        e = Object.assign({}, mo.defaultOptions, e);
        const {alphaMode: i, mipmap: r, anisotropicLevel: n, scaleMode: o, width: a, height: l, wrapMode: h, format: u, type: c, target: d, resolution: f, resourceOptions: p} = e;
        t && !(t instanceof ia) && (t = Lm(t, p),
        t.internal = !0),
        this.resolution = f || nt.RESOLUTION,
        this.width = Math.round((a || 0) * this.resolution) / this.resolution,
        this.height = Math.round((l || 0) * this.resolution) / this.resolution,
        this._mipmap = r,
        this.anisotropicLevel = n,
        this._wrapMode = h,
        this._scaleMode = o,
        this.format = u,
        this.type = c,
        this.target = d,
        this.alphaMode = i,
        this.uid = Js(),
        this.touched = 0,
        this.isPowerOfTwo = !1,
        this._refreshPOT(),
        this._glTextures = {},
        this.dirtyId = 0,
        this.dirtyStyleId = 0,
        this.cacheId = null,
        this.valid = a > 0 && l > 0,
        this.textureCacheIds = [],
        this.destroyed = !1,
        this.resource = null,
        this._batchEnabled = 0,
        this._batchLocation = 0,
        this.parentTextureArray = null,
        this.setResource(t)
    }
    get realWidth() {
        return Math.round(this.width * this.resolution)
    }
    get realHeight() {
        return Math.round(this.height * this.resolution)
    }
    get mipmap() {
        return this._mipmap
    }
    set mipmap(t) {
        this._mipmap !== t && (this._mipmap = t,
        this.dirtyStyleId++)
    }
    get scaleMode() {
        return this._scaleMode
    }
    set scaleMode(t) {
        this._scaleMode !== t && (this._scaleMode = t,
        this.dirtyStyleId++)
    }
    get wrapMode() {
        return this._wrapMode
    }
    set wrapMode(t) {
        this._wrapMode !== t && (this._wrapMode = t,
        this.dirtyStyleId++)
    }
    setStyle(t, e) {
        let i;
        return t !== void 0 && t !== this.scaleMode && (this.scaleMode = t,
        i = !0),
        e !== void 0 && e !== this.mipmap && (this.mipmap = e,
        i = !0),
        i && this.dirtyStyleId++,
        this
    }
    setSize(t, e, i) {
        return i = i || this.resolution,
        this.setRealSize(t * i, e * i, i)
    }
    setRealSize(t, e, i) {
        return this.resolution = i || this.resolution,
        this.width = Math.round(t) / this.resolution,
        this.height = Math.round(e) / this.resolution,
        this._refreshPOT(),
        this.update(),
        this
    }
    _refreshPOT() {
        this.isPowerOfTwo = ip(this.realWidth) && ip(this.realHeight)
    }
    setResolution(t) {
        const e = this.resolution;
        return e === t ? this : (this.resolution = t,
        this.valid && (this.width = Math.round(this.width * e) / t,
        this.height = Math.round(this.height * e) / t,
        this.emit("update", this)),
        this._refreshPOT(),
        this)
    }
    setResource(t) {
        if (this.resource === t)
            return this;
        if (this.resource)
            throw new Error("Resource can be set only once");
        return t.bind(this),
        this.resource = t,
        this
    }
    update() {
        this.valid ? (this.dirtyId++,
        this.dirtyStyleId++,
        this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0,
        this.emit("loaded", this),
        this.emit("update", this))
    }
    onError(t) {
        this.emit("error", this, t)
    }
    destroy() {
        this.resource && (this.resource.unbind(this),
        this.resource.internal && this.resource.destroy(),
        this.resource = null),
        this.cacheId && (delete Bi[this.cacheId],
        delete ci[this.cacheId],
        this.cacheId = null),
        this.valid = !1,
        this.dispose(),
        mo.removeFromCache(this),
        this.textureCacheIds = null,
        this.destroyed = !0,
        this.emit("destroyed", this),
        this.removeAllListeners()
    }
    dispose() {
        this.emit("dispose", this)
    }
    castToBaseTexture() {
        return this
    }
    static from(t, e, i=nt.STRICT_TEXTURE_CACHE) {
        const r = typeof t == "string";
        let n = null;
        if (r)
            n = t;
        else {
            if (!t._pixiId) {
                const a = e?.pixiIdPrefix || "pixiid";
                t._pixiId = `${a}_${Js()}`
            }
            n = t._pixiId
        }
        let o = Bi[n];
        if (r && i && !o)
            throw new Error(`The cacheId "${n}" does not exist in BaseTextureCache.`);
        return o || (o = new mo(t,e),
        o.cacheId = n,
        mo.addToCache(o, n)),
        o
    }
    static fromBuffer(t, e, i, r) {
        t = t || new Float32Array(e * i * 4);
        const n = new jl(t,{
            width: e,
            height: i,
            ...r?.resourceOptions
        });
        let o, a;
        return t instanceof Float32Array ? (o = J.RGBA,
        a = ft.FLOAT) : t instanceof Int32Array ? (o = J.RGBA_INTEGER,
        a = ft.INT) : t instanceof Uint32Array ? (o = J.RGBA_INTEGER,
        a = ft.UNSIGNED_INT) : t instanceof Int16Array ? (o = J.RGBA_INTEGER,
        a = ft.SHORT) : t instanceof Uint16Array ? (o = J.RGBA_INTEGER,
        a = ft.UNSIGNED_SHORT) : t instanceof Int8Array ? (o = J.RGBA,
        a = ft.BYTE) : (o = J.RGBA,
        a = ft.UNSIGNED_BYTE),
        n.internal = !0,
        new mo(n,Object.assign({}, PP, {
            type: a,
            format: o
        }, r))
    }
    static addToCache(t, e) {
        e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
        Bi[e] && Bi[e] !== t && console.warn(`BaseTexture added to the cache with an id [${e}] that already had an entry`),
        Bi[e] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const e = Bi[t];
            if (e) {
                const i = e.textureCacheIds.indexOf(t);
                return i > -1 && e.textureCacheIds.splice(i, 1),
                delete Bi[t],
                e
            }
        } else if (t?.textureCacheIds) {
            for (let e = 0; e < t.textureCacheIds.length; ++e)
                delete Bi[t.textureCacheIds[e]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
}
;
lp.defaultOptions = {
    mipmap: Ar.POW2,
    anisotropicLevel: 0,
    scaleMode: Wr.LINEAR,
    wrapMode: Jr.CLAMP,
    alphaMode: _i.UNPACK,
    target: On.TEXTURE_2D,
    format: J.RGBA,
    type: ft.UNSIGNED_BYTE
},
lp._globalBatch = 0;
let At = lp;
class ec {
    constructor() {
        this.texArray = null,
        this.blend = 0,
        this.type = xr.TRIANGLES,
        this.start = 0,
        this.size = 0,
        this.data = null
    }
}
let IP = 0;
class ce {
    constructor(t, e=!0, i=!1) {
        this.data = t || new Float32Array(1),
        this._glBuffers = {},
        this._updateID = 0,
        this.index = i,
        this.static = e,
        this.id = IP++,
        this.disposeRunner = new Vi("disposeBuffer")
    }
    update(t) {
        t instanceof Array && (t = new Float32Array(t)),
        this.data = t || this.data,
        this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.data = null
    }
    set index(t) {
        this.type = t ? Er.ELEMENT_ARRAY_BUFFER : Er.ARRAY_BUFFER
    }
    get index() {
        return this.type === Er.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)),
        new ce(t)
    }
}
class Ml {
    constructor(t, e=0, i=!1, r=ft.FLOAT, n, o, a, l=1) {
        this.buffer = t,
        this.size = e,
        this.normalized = i,
        this.type = r,
        this.stride = n,
        this.start = o,
        this.instance = a,
        this.divisor = l
    }
    destroy() {
        this.buffer = null
    }
    static from(t, e, i, r, n) {
        return new Ml(t,e,i,r,n)
    }
}
const RP = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function MP(s, t) {
    let e = 0
      , i = 0;
    const r = {};
    for (let l = 0; l < s.length; l++)
        i += t[l],
        e += s[l].length;
    const n = new ArrayBuffer(e * 4);
    let o = null
      , a = 0;
    for (let l = 0; l < s.length; l++) {
        const h = t[l]
          , u = s[l]
          , c = Ic(u);
        r[c] || (r[c] = new RP[c](n)),
        o = r[c];
        for (let d = 0; d < u.length; d++) {
            const f = (d / h | 0) * i + a
              , p = d % h;
            o[f + p] = u[d]
        }
        a += h
    }
    return new Float32Array(n)
}
const G_ = {
    5126: 4,
    5123: 2,
    5121: 1
};
let FP = 0;
const BP = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
};
class ws {
    constructor(t=[], e={}) {
        this.buffers = t,
        this.indexBuffer = null,
        this.attributes = e,
        this.glVertexArrayObjects = {},
        this.id = FP++,
        this.instanced = !1,
        this.instanceCount = 1,
        this.disposeRunner = new Vi("disposeGeometry"),
        this.refCount = 0
    }
    addAttribute(t, e, i=0, r=!1, n, o, a, l=!1) {
        if (!e)
            throw new Error("You must pass a buffer when creating an attribute");
        e instanceof ce || (e instanceof Array && (e = new Float32Array(e)),
        e = new ce(e));
        const h = t.split("|");
        if (h.length > 1) {
            for (let c = 0; c < h.length; c++)
                this.addAttribute(h[c], e, i, r, n);
            return this
        }
        let u = this.buffers.indexOf(e);
        return u === -1 && (this.buffers.push(e),
        u = this.buffers.length - 1),
        this.attributes[t] = new Ml(u,i,r,n,o,a,l),
        this.instanced = this.instanced || l,
        this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return t instanceof ce || (t instanceof Array && (t = new Uint16Array(t)),
        t = new ce(t)),
        t.type = Er.ELEMENT_ARRAY_BUFFER,
        this.indexBuffer = t,
        this.buffers.includes(t) || this.buffers.push(t),
        this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
            return this;
        const t = []
          , e = []
          , i = new ce;
        let r;
        for (r in this.attributes) {
            const n = this.attributes[r]
              , o = this.buffers[n.buffer];
            t.push(o.data),
            e.push(n.size * G_[n.type] / 4),
            n.buffer = 0
        }
        for (i.data = MP(t, e),
        r = 0; r < this.buffers.length; r++)
            this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy();
        return this.buffers = [i],
        this.indexBuffer && this.buffers.push(this.indexBuffer),
        this
    }
    getSize() {
        for (const t in this.attributes) {
            const e = this.attributes[t];
            return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.buffers = null,
        this.indexBuffer = null,
        this.attributes = null
    }
    clone() {
        const t = new ws;
        for (let e = 0; e < this.buffers.length; e++)
            t.buffers[e] = new ce(this.buffers[e].data.slice(0));
        for (const e in this.attributes) {
            const i = this.attributes[e];
            t.attributes[e] = new Ml(i.buffer,i.size,i.normalized,i.type,i.stride,i.start,i.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)],
        t.indexBuffer.type = Er.ELEMENT_ARRAY_BUFFER),
        t
    }
    static merge(t) {
        const e = new ws
          , i = []
          , r = []
          , n = [];
        let o;
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++)
                r[l] = r[l] || 0,
                r[l] += o.buffers[l].data.length,
                n[l] = 0
        }
        for (let a = 0; a < o.buffers.length; a++)
            i[a] = new BP[Ic(o.buffers[a].data)](r[a]),
            e.buffers[a] = new ce(i[a]);
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++)
                i[l].set(o.buffers[l].data, n[l]),
                n[l] += o.buffers[l].data.length
        }
        if (e.attributes = o.attributes,
        o.indexBuffer) {
            e.indexBuffer = e.buffers[o.buffers.indexOf(o.indexBuffer)],
            e.indexBuffer.type = Er.ELEMENT_ARRAY_BUFFER;
            let a = 0
              , l = 0
              , h = 0
              , u = 0;
            for (let c = 0; c < o.buffers.length; c++)
                if (o.buffers[c] !== o.indexBuffer) {
                    u = c;
                    break
                }
            for (const c in o.attributes) {
                const d = o.attributes[c];
                (d.buffer | 0) === u && (l += d.size * G_[d.type] / 4)
            }
            for (let c = 0; c < t.length; c++) {
                const d = t[c].indexBuffer.data;
                for (let f = 0; f < d.length; f++)
                    e.indexBuffer.data[f + h] += a;
                a += t[c].buffers[u].data.length / l,
                h += d.length
            }
        }
        return e
    }
}
class Nm extends ws {
    constructor(t=!1) {
        super(),
        this._buffer = new ce(null,t,!1),
        this._indexBuffer = new ce(null,t,!0),
        this.addAttribute("aVertexPosition", this._buffer, 2, !1, ft.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, ft.FLOAT).addAttribute("aColor", this._buffer, 4, !0, ft.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, ft.FLOAT).addIndex(this._indexBuffer)
    }
}
const Fl = Math.PI * 2
  , g1 = 180 / Math.PI
  , _1 = Math.PI / 180;
var Ne = (s=>(s[s.POLY = 0] = "POLY",
s[s.RECT = 1] = "RECT",
s[s.CIRC = 2] = "CIRC",
s[s.ELIP = 3] = "ELIP",
s[s.RREC = 4] = "RREC",
s))(Ne || {});
class Nt {
    constructor(t=0, e=0) {
        this.x = 0,
        this.y = 0,
        this.x = t,
        this.y = e
    }
    clone() {
        return new Nt(this.x,this.y)
    }
    copyFrom(t) {
        return this.set(t.x, t.y),
        this
    }
    copyTo(t) {
        return t.set(this.x, this.y),
        t
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t=0, e=t) {
        return this.x = t,
        this.y = e,
        this
    }
}
Nt.prototype.toString = function() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`
}
;
const Fh = [new Nt, new Nt, new Nt, new Nt];
class St {
    constructor(t=0, e=0, i=0, r=0) {
        this.x = Number(t),
        this.y = Number(e),
        this.width = Number(i),
        this.height = Number(r),
        this.type = Ne.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new St(0,0,0,0)
    }
    clone() {
        return new St(this.x,this.y,this.width,this.height)
    }
    copyFrom(t) {
        return this.x = t.x,
        this.y = t.y,
        this.width = t.width,
        this.height = t.height,
        this
    }
    copyTo(t) {
        return t.x = this.x,
        t.y = this.y,
        t.width = this.width,
        t.height = this.height,
        t
    }
    contains(t, e) {
        return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height
    }
    intersects(t, e) {
        if (!e) {
            const A = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= A)
                return !1;
            const I = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > I
        }
        const i = this.left
          , r = this.right
          , n = this.top
          , o = this.bottom;
        if (r <= i || o <= n)
            return !1;
        const a = Fh[0].set(t.left, t.top)
          , l = Fh[1].set(t.left, t.bottom)
          , h = Fh[2].set(t.right, t.top)
          , u = Fh[3].set(t.right, t.bottom);
        if (h.x <= a.x || l.y <= a.y)
            return !1;
        const c = Math.sign(e.a * e.d - e.b * e.c);
        if (c === 0 || (e.apply(a, a),
        e.apply(l, l),
        e.apply(h, h),
        e.apply(u, u),
        Math.max(a.x, l.x, h.x, u.x) <= i || Math.min(a.x, l.x, h.x, u.x) >= r || Math.max(a.y, l.y, h.y, u.y) <= n || Math.min(a.y, l.y, h.y, u.y) >= o))
            return !1;
        const d = c * (l.y - a.y)
          , f = c * (a.x - l.x)
          , p = d * i + f * n
          , m = d * r + f * n
          , g = d * i + f * o
          , _ = d * r + f * o;
        if (Math.max(p, m, g, _) <= d * a.x + f * a.y || Math.min(p, m, g, _) >= d * u.x + f * u.y)
            return !1;
        const x = c * (a.y - h.y)
          , y = c * (h.x - a.x)
          , v = x * i + y * n
          , E = x * r + y * n
          , P = x * i + y * o
          , w = x * r + y * o;
        return !(Math.max(v, E, P, w) <= x * a.x + y * a.y || Math.min(v, E, P, w) >= x * u.x + y * u.y)
    }
    pad(t=0, e=t) {
        return this.x -= t,
        this.y -= e,
        this.width += t * 2,
        this.height += e * 2,
        this
    }
    fit(t) {
        const e = Math.max(this.x, t.x)
          , i = Math.min(this.x + this.width, t.x + t.width)
          , r = Math.max(this.y, t.y)
          , n = Math.min(this.y + this.height, t.y + t.height);
        return this.x = e,
        this.width = Math.max(i - e, 0),
        this.y = r,
        this.height = Math.max(n - r, 0),
        this
    }
    ceil(t=1, e=.001) {
        const i = Math.ceil((this.x + this.width - e) * t) / t
          , r = Math.ceil((this.y + this.height - e) * t) / t;
        return this.x = Math.floor((this.x + e) * t) / t,
        this.y = Math.floor((this.y + e) * t) / t,
        this.width = i - this.x,
        this.height = r - this.y,
        this
    }
    enlarge(t) {
        const e = Math.min(this.x, t.x)
          , i = Math.max(this.x + this.width, t.x + t.width)
          , r = Math.min(this.y, t.y)
          , n = Math.max(this.y + this.height, t.y + t.height);
        return this.x = e,
        this.width = i - e,
        this.y = r,
        this.height = n - r,
        this
    }
}
St.prototype.toString = function() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
;
class ql {
    constructor(t=0, e=0, i=0) {
        this.x = t,
        this.y = e,
        this.radius = i,
        this.type = Ne.CIRC
    }
    clone() {
        return new ql(this.x,this.y,this.radius)
    }
    contains(t, e) {
        if (this.radius <= 0)
            return !1;
        const i = this.radius * this.radius;
        let r = this.x - t
          , n = this.y - e;
        return r *= r,
        n *= n,
        r + n <= i
    }
    getBounds() {
        return new St(this.x - this.radius,this.y - this.radius,this.radius * 2,this.radius * 2)
    }
}
ql.prototype.toString = function() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
}
;
class Yl {
    constructor(t=0, e=0, i=0, r=0) {
        this.x = t,
        this.y = e,
        this.width = i,
        this.height = r,
        this.type = Ne.ELIP
    }
    clone() {
        return new Yl(this.x,this.y,this.width,this.height)
    }
    contains(t, e) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        let i = (t - this.x) / this.width
          , r = (e - this.y) / this.height;
        return i *= i,
        r *= r,
        i + r <= 1
    }
    getBounds() {
        return new St(this.x - this.width,this.y - this.height,this.width,this.height)
    }
}
Yl.prototype.toString = function() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
;
class js {
    constructor(...t) {
        let e = Array.isArray(t[0]) ? t[0] : t;
        if (typeof e[0] != "number") {
            const i = [];
            for (let r = 0, n = e.length; r < n; r++)
                i.push(e[r].x, e[r].y);
            e = i
        }
        this.points = e,
        this.type = Ne.POLY,
        this.closeStroke = !0
    }
    clone() {
        const t = this.points.slice()
          , e = new js(t);
        return e.closeStroke = this.closeStroke,
        e
    }
    contains(t, e) {
        let i = !1;
        const r = this.points.length / 2;
        for (let n = 0, o = r - 1; n < r; o = n++) {
            const a = this.points[n * 2]
              , l = this.points[n * 2 + 1]
              , h = this.points[o * 2]
              , u = this.points[o * 2 + 1];
            l > e != u > e && t < (h - a) * ((e - l) / (u - l)) + a && (i = !i)
        }
        return i
    }
}
js.prototype.toString = function() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((s,t)=>`${s}, ${t}`, "")}]`
}
;
class Kl {
    constructor(t=0, e=0, i=0, r=0, n=20) {
        this.x = t,
        this.y = e,
        this.width = i,
        this.height = r,
        this.radius = n,
        this.type = Ne.RREC
    }
    clone() {
        return new Kl(this.x,this.y,this.width,this.height,this.radius)
    }
    contains(t, e) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
            const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (e >= this.y + i && e <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i)
                return !0;
            let r = t - (this.x + i)
              , n = e - (this.y + i);
            const o = i * i;
            if (r * r + n * n <= o || (r = t - (this.x + this.width - i),
            r * r + n * n <= o) || (n = e - (this.y + this.height - i),
            r * r + n * n <= o) || (r = t - (this.x + i),
            r * r + n * n <= o))
                return !0
        }
        return !1
    }
}
Kl.prototype.toString = function() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
}
;
class Qt {
    constructor(t=1, e=0, i=0, r=1, n=0, o=0) {
        this.array = null,
        this.a = t,
        this.b = e,
        this.c = i,
        this.d = r,
        this.tx = n,
        this.ty = o
    }
    fromArray(t) {
        this.a = t[0],
        this.b = t[1],
        this.c = t[3],
        this.d = t[4],
        this.tx = t[2],
        this.ty = t[5]
    }
    set(t, e, i, r, n, o) {
        return this.a = t,
        this.b = e,
        this.c = i,
        this.d = r,
        this.tx = n,
        this.ty = o,
        this
    }
    toArray(t, e) {
        this.array || (this.array = new Float32Array(9));
        const i = e || this.array;
        return t ? (i[0] = this.a,
        i[1] = this.b,
        i[2] = 0,
        i[3] = this.c,
        i[4] = this.d,
        i[5] = 0,
        i[6] = this.tx,
        i[7] = this.ty,
        i[8] = 1) : (i[0] = this.a,
        i[1] = this.c,
        i[2] = this.tx,
        i[3] = this.b,
        i[4] = this.d,
        i[5] = this.ty,
        i[6] = 0,
        i[7] = 0,
        i[8] = 1),
        i
    }
    apply(t, e) {
        e = e || new Nt;
        const i = t.x
          , r = t.y;
        return e.x = this.a * i + this.c * r + this.tx,
        e.y = this.b * i + this.d * r + this.ty,
        e
    }
    applyInverse(t, e) {
        e = e || new Nt;
        const i = 1 / (this.a * this.d + this.c * -this.b)
          , r = t.x
          , n = t.y;
        return e.x = this.d * i * r + -this.c * i * n + (this.ty * this.c - this.tx * this.d) * i,
        e.y = this.a * i * n + -this.b * i * r + (-this.ty * this.a + this.tx * this.b) * i,
        e
    }
    translate(t, e) {
        return this.tx += t,
        this.ty += e,
        this
    }
    scale(t, e) {
        return this.a *= t,
        this.d *= e,
        this.c *= t,
        this.b *= e,
        this.tx *= t,
        this.ty *= e,
        this
    }
    rotate(t) {
        const e = Math.cos(t)
          , i = Math.sin(t)
          , r = this.a
          , n = this.c
          , o = this.tx;
        return this.a = r * e - this.b * i,
        this.b = r * i + this.b * e,
        this.c = n * e - this.d * i,
        this.d = n * i + this.d * e,
        this.tx = o * e - this.ty * i,
        this.ty = o * i + this.ty * e,
        this
    }
    append(t) {
        const e = this.a
          , i = this.b
          , r = this.c
          , n = this.d;
        return this.a = t.a * e + t.b * r,
        this.b = t.a * i + t.b * n,
        this.c = t.c * e + t.d * r,
        this.d = t.c * i + t.d * n,
        this.tx = t.tx * e + t.ty * r + this.tx,
        this.ty = t.tx * i + t.ty * n + this.ty,
        this
    }
    setTransform(t, e, i, r, n, o, a, l, h) {
        return this.a = Math.cos(a + h) * n,
        this.b = Math.sin(a + h) * n,
        this.c = -Math.sin(a - l) * o,
        this.d = Math.cos(a - l) * o,
        this.tx = t - (i * this.a + r * this.c),
        this.ty = e - (i * this.b + r * this.d),
        this
    }
    prepend(t) {
        const e = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const i = this.a
              , r = this.c;
            this.a = i * t.a + this.b * t.c,
            this.b = i * t.b + this.b * t.d,
            this.c = r * t.a + this.d * t.c,
            this.d = r * t.b + this.d * t.d
        }
        return this.tx = e * t.a + this.ty * t.c + t.tx,
        this.ty = e * t.b + this.ty * t.d + t.ty,
        this
    }
    decompose(t) {
        const e = this.a
          , i = this.b
          , r = this.c
          , n = this.d
          , o = t.pivot
          , a = -Math.atan2(-r, n)
          , l = Math.atan2(i, e)
          , h = Math.abs(a + l);
        return h < 1e-5 || Math.abs(Fl - h) < 1e-5 ? (t.rotation = l,
        t.skew.x = t.skew.y = 0) : (t.rotation = 0,
        t.skew.x = a,
        t.skew.y = l),
        t.scale.x = Math.sqrt(e * e + i * i),
        t.scale.y = Math.sqrt(r * r + n * n),
        t.position.x = this.tx + (o.x * e + o.y * r),
        t.position.y = this.ty + (o.x * i + o.y * n),
        t
    }
    invert() {
        const t = this.a
          , e = this.b
          , i = this.c
          , r = this.d
          , n = this.tx
          , o = t * r - e * i;
        return this.a = r / o,
        this.b = -e / o,
        this.c = -i / o,
        this.d = t / o,
        this.tx = (i * this.ty - r * n) / o,
        this.ty = -(t * this.ty - e * n) / o,
        this
    }
    identity() {
        return this.a = 1,
        this.b = 0,
        this.c = 0,
        this.d = 1,
        this.tx = 0,
        this.ty = 0,
        this
    }
    clone() {
        const t = new Qt;
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyTo(t) {
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyFrom(t) {
        return this.a = t.a,
        this.b = t.b,
        this.c = t.c,
        this.d = t.d,
        this.tx = t.tx,
        this.ty = t.ty,
        this
    }
    static get IDENTITY() {
        return new Qt
    }
    static get TEMP_MATRIX() {
        return new Qt
    }
}
Qt.prototype.toString = function() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
}
;
const gn = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
  , _n = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
  , yn = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
  , vn = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
  , hp = []
  , y1 = []
  , Bh = Math.sign;
function OP() {
    for (let s = 0; s < 16; s++) {
        const t = [];
        hp.push(t);
        for (let e = 0; e < 16; e++) {
            const i = Bh(gn[s] * gn[e] + yn[s] * _n[e])
              , r = Bh(_n[s] * gn[e] + vn[s] * _n[e])
              , n = Bh(gn[s] * yn[e] + yn[s] * vn[e])
              , o = Bh(_n[s] * yn[e] + vn[s] * vn[e]);
            for (let a = 0; a < 16; a++)
                if (gn[a] === i && _n[a] === r && yn[a] === n && vn[a] === o) {
                    t.push(a);
                    break
                }
        }
    }
    for (let s = 0; s < 16; s++) {
        const t = new Qt;
        t.set(gn[s], _n[s], yn[s], vn[s], 0, 0),
        y1.push(t)
    }
}
OP();
const ie = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: s=>gn[s],
    uY: s=>_n[s],
    vX: s=>yn[s],
    vY: s=>vn[s],
    inv: s=>s & 8 ? s & 15 : -s & 7,
    add: (s,t)=>hp[s][t],
    sub: (s,t)=>hp[s][ie.inv(t)],
    rotate180: s=>s ^ 4,
    isVertical: s=>(s & 3) === 2,
    byDirection: (s,t)=>Math.abs(s) * 2 <= Math.abs(t) ? t >= 0 ? ie.S : ie.N : Math.abs(t) * 2 <= Math.abs(s) ? s > 0 ? ie.E : ie.W : t > 0 ? s > 0 ? ie.SE : ie.SW : s > 0 ? ie.NE : ie.NW,
    matrixAppendRotationInv: (s,t,e=0,i=0)=>{
        const r = y1[ie.inv(t)];
        r.tx = e,
        r.ty = i,
        s.append(r)
    }
};
class jr {
    constructor(t, e, i=0, r=0) {
        this._x = i,
        this._y = r,
        this.cb = t,
        this.scope = e
    }
    clone(t=this.cb, e=this.scope) {
        return new jr(t,e,this._x,this._y)
    }
    set(t=0, e=t) {
        return (this._x !== t || this._y !== e) && (this._x = t,
        this._y = e,
        this.cb.call(this.scope)),
        this
    }
    copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x,
        this._y = t.y,
        this.cb.call(this.scope)),
        this
    }
    copyTo(t) {
        return t.set(this._x, this._y),
        t
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && (this._x = t,
        this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && (this._y = t,
        this.cb.call(this.scope))
    }
}
jr.prototype.toString = function() {
    return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`
}
;
const up = class {
    constructor() {
        this.worldTransform = new Qt,
        this.localTransform = new Qt,
        this.position = new jr(this.onChange,this,0,0),
        this.scale = new jr(this.onChange,this,1,1),
        this.pivot = new jr(this.onChange,this,0,0),
        this.skew = new jr(this.updateSkew,this,0,0),
        this._rotation = 0,
        this._cx = 1,
        this._sx = 0,
        this._cy = 0,
        this._sy = 1,
        this._localID = 0,
        this._currentLocalID = 0,
        this._worldID = 0,
        this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y),
        this._sx = Math.sin(this._rotation + this.skew.y),
        this._cy = -Math.sin(this._rotation - this.skew.x),
        this._sy = Math.cos(this._rotation - this.skew.x),
        this._localID++
    }
    updateLocalTransform() {
        const s = this.localTransform;
        this._localID !== this._currentLocalID && (s.a = this._cx * this.scale.x,
        s.b = this._sx * this.scale.x,
        s.c = this._cy * this.scale.y,
        s.d = this._sy * this.scale.y,
        s.tx = this.position.x - (this.pivot.x * s.a + this.pivot.y * s.c),
        s.ty = this.position.y - (this.pivot.x * s.b + this.pivot.y * s.d),
        this._currentLocalID = this._localID,
        this._parentID = -1)
    }
    updateTransform(s) {
        const t = this.localTransform;
        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x,
        t.b = this._sx * this.scale.x,
        t.c = this._cy * this.scale.y,
        t.d = this._sy * this.scale.y,
        t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c),
        t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d),
        this._currentLocalID = this._localID,
        this._parentID = -1),
        this._parentID !== s._worldID) {
            const e = s.worldTransform
              , i = this.worldTransform;
            i.a = t.a * e.a + t.b * e.c,
            i.b = t.a * e.b + t.b * e.d,
            i.c = t.c * e.a + t.d * e.c,
            i.d = t.c * e.b + t.d * e.d,
            i.tx = t.tx * e.a + t.ty * e.c + e.tx,
            i.ty = t.tx * e.b + t.ty * e.d + e.ty,
            this._parentID = s._worldID,
            this._worldID++
        }
    }
    setFromMatrix(s) {
        s.decompose(this),
        this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(s) {
        this._rotation !== s && (this._rotation = s,
        this.updateSkew())
    }
}
;
up.IDENTITY = new up;
let Zl = up;
Zl.prototype.toString = function() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
}
;
var kP = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`
  , LP = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
function H_(s, t, e) {
    const i = s.createShader(t);
    return s.shaderSource(i, e),
    s.compileShader(i),
    i
}
function Nd(s) {
    const t = new Array(s);
    for (let e = 0; e < t.length; e++)
        t[e] = !1;
    return t
}
function v1(s, t) {
    switch (s) {
    case "float":
        return 0;
    case "vec2":
        return new Float32Array(2 * t);
    case "vec3":
        return new Float32Array(3 * t);
    case "vec4":
        return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
        return 0;
    case "ivec2":
        return new Int32Array(2 * t);
    case "ivec3":
        return new Int32Array(3 * t);
    case "ivec4":
        return new Int32Array(4 * t);
    case "uvec2":
        return new Uint32Array(2 * t);
    case "uvec3":
        return new Uint32Array(3 * t);
    case "uvec4":
        return new Uint32Array(4 * t);
    case "bool":
        return !1;
    case "bvec2":
        return Nd(2 * t);
    case "bvec3":
        return Nd(3 * t);
    case "bvec4":
        return Nd(4 * t);
    case "mat2":
        return new Float32Array([1, 0, 0, 1]);
    case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const Un = [{
    test: s=>s.type === "float" && s.size === 1 && !s.isArray,
    code: s=>`
            if(uv["${s}"] !== ud["${s}"].value)
            {
                ud["${s}"].value = uv["${s}"]
                gl.uniform1f(ud["${s}"].location, uv["${s}"])
            }
            `
}, {
    test: (s,t)=>(s.type === "sampler2D" || s.type === "samplerCube" || s.type === "sampler2DArray") && s.size === 1 && !s.isArray && (t == null || t.castToBaseTexture !== void 0),
    code: s=>`t = syncData.textureCount++;

            renderer.texture.bind(uv["${s}"], t);

            if(ud["${s}"].value !== t)
            {
                ud["${s}"].value = t;
                gl.uniform1i(ud["${s}"].location, t);
; // eslint-disable-line max-len
            }`
}, {
    test: (s,t)=>s.type === "mat3" && s.size === 1 && !s.isArray && t.a !== void 0,
    code: s=>`
            gl.uniformMatrix3fv(ud["${s}"].location, false, uv["${s}"].toArray(true));
            `,
    codeUbo: s=>`
                var ${s}_matrix = uv.${s}.toArray(true);

                data[offset] = ${s}_matrix[0];
                data[offset+1] = ${s}_matrix[1];
                data[offset+2] = ${s}_matrix[2];
        
                data[offset + 4] = ${s}_matrix[3];
                data[offset + 5] = ${s}_matrix[4];
                data[offset + 6] = ${s}_matrix[5];
        
                data[offset + 8] = ${s}_matrix[6];
                data[offset + 9] = ${s}_matrix[7];
                data[offset + 10] = ${s}_matrix[8];
            `
}, {
    test: (s,t)=>s.type === "vec2" && s.size === 1 && !s.isArray && t.x !== void 0,
    code: s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${s}"].location, v.x, v.y);
                }`,
    codeUbo: s=>`
                v = uv.${s};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
}, {
    test: s=>s.type === "vec2" && s.size === 1 && !s.isArray,
    code: s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${s}"].location, v[0], v[1]);
                }
            `
}, {
    test: (s,t)=>s.type === "vec4" && s.size === 1 && !s.isArray && t.width !== void 0,
    code: s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${s}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: s=>`
                    v = uv.${s};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
}, {
    test: (s,t)=>s.type === "vec4" && s.size === 1 && !s.isArray && t.red !== void 0,
    code: s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${s}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: s=>`
                    v = uv.${s};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
}, {
    test: (s,t)=>s.type === "vec3" && s.size === 1 && !s.isArray && t.red !== void 0,
    code: s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${s}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: s=>`
                    v = uv.${s};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
}, {
    test: s=>s.type === "vec4" && s.size === 1 && !s.isArray,
    code: s=>`
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${s}"].location, v[0], v[1], v[2], v[3])
                }`
}]
  , NP = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}
  , UP = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
};
function GP(s, t) {
    const e = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i in s.uniforms) {
        const r = t[i];
        if (!r) {
            s.uniforms[i]?.group === !0 && (s.uniforms[i].ubo ? e.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `) : e.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `));
            continue
        }
        const n = s.uniforms[i];
        let o = !1;
        for (let a = 0; a < Un.length; a++)
            if (Un[a].test(r, n)) {
                e.push(Un[a].code(i, n)),
                o = !0;
                break
            }
        if (!o) {
            const a = (r.size === 1 && !r.isArray ? NP : UP)[r.type].replace("location", `ud["${i}"].location`);
            e.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${a};`)
        }
    }
    return new Function("ud","uv","renderer","syncData",e.join(`
`))
}
const x1 = {};
let Oh = x1;
function b1() {
    if (Oh === x1 || Oh?.isContextLost()) {
        const s = nt.ADAPTER.createCanvas();
        let t;
        nt.PREFER_ENV >= rn.WEBGL2 && (t = s.getContext("webgl2", {})),
        t || (t = s.getContext("webgl", {}) || s.getContext("experimental-webgl", {}),
        t ? t.getExtension("WEBGL_draw_buffers") : t = null),
        Oh = t
    }
    return Oh
}
let kh;
function HP() {
    if (!kh) {
        kh = Hi.MEDIUM;
        const s = b1();
        if (s && s.getShaderPrecisionFormat) {
            const t = s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT);
            t && (kh = t.precision ? Hi.HIGH : Hi.MEDIUM)
        }
    }
    return kh
}
function $_(s, t) {
    const e = s.getShaderSource(t).split(`
`).map((h,u)=>`${u}: ${h}`)
      , i = s.getShaderInfoLog(t)
      , r = i.split(`
`)
      , n = {}
      , o = r.map(h=>parseFloat(h.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(h=>h && !n[h] ? (n[h] = !0,
    !0) : !1)
      , a = [""];
    o.forEach(h=>{
        e[h - 1] = `%c${e[h - 1]}%c`,
        a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    }
    );
    const l = e.join(`
`);
    a[0] = l,
    console.error(i),
    console.groupCollapsed("click to view full shader code"),
    console.warn(...a),
    console.groupEnd()
}
function $P(s, t, e, i) {
    s.getProgramParameter(t, s.LINK_STATUS) || (s.getShaderParameter(e, s.COMPILE_STATUS) || $_(s, e),
    s.getShaderParameter(i, s.COMPILE_STATUS) || $_(s, i),
    console.error("PixiJS Error: Could not initialize shader."),
    s.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", s.getProgramInfoLog(t)))
}
const zP = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};
function w1(s) {
    return zP[s]
}
let Lh = null;
const z_ = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function E1(s, t) {
    if (!Lh) {
        const e = Object.keys(z_);
        Lh = {};
        for (let i = 0; i < e.length; ++i) {
            const r = e[i];
            Lh[s[r]] = z_[r]
        }
    }
    return Lh[t]
}
function V_(s, t, e) {
    if (s.substring(0, 9) !== "precision") {
        let i = t;
        return t === Hi.HIGH && e !== Hi.HIGH && (i = Hi.MEDIUM),
        `precision ${i} float;
${s}`
    } else if (e !== Hi.HIGH && s.substring(0, 15) === "precision highp")
        return s.replace("precision highp", "precision mediump");
    return s
}
let Ea;
function T1() {
    if (typeof Ea == "boolean")
        return Ea;
    try {
        Ea = new Function("param1","param2","param3","return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        Ea = !1
    }
    return Ea
}
let VP = 0;
const Nh = {}
  , cp = class go {
    constructor(t, e, i="pixi-shader", r={}) {
        this.extra = {},
        this.id = VP++,
        this.vertexSrc = t || go.defaultVertexSrc,
        this.fragmentSrc = e || go.defaultFragmentSrc,
        this.vertexSrc = this.vertexSrc.trim(),
        this.fragmentSrc = this.fragmentSrc.trim(),
        this.extra = r,
        this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"),
        Nh[i] ? (Nh[i]++,
        i += `-${Nh[i]}`) : Nh[i] = 1,
        this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`,
        this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`,
        this.vertexSrc = V_(this.vertexSrc, go.defaultVertexPrecision, Hi.HIGH),
        this.fragmentSrc = V_(this.fragmentSrc, go.defaultFragmentPrecision, HP())),
        this.glPrograms = {},
        this.syncUniforms = null
    }
    static get defaultVertexSrc() {
        return LP
    }
    static get defaultFragmentSrc() {
        return kP
    }
    static from(t, e, i) {
        const r = t + e;
        let n = op[r];
        return n || (op[r] = n = new go(t,e,i)),
        n
    }
}
;
cp.defaultVertexPrecision = Hi.HIGH,
cp.defaultFragmentPrecision = br.apple.device ? Hi.HIGH : Hi.MEDIUM;
let qr = cp
  , XP = 0;
class ar {
    constructor(t, e, i) {
        this.group = !0,
        this.syncUniforms = {},
        this.dirtyId = 0,
        this.id = XP++,
        this.static = !!e,
        this.ubo = !!i,
        t instanceof ce ? (this.buffer = t,
        this.buffer.type = Er.UNIFORM_BUFFER,
        this.autoManage = !1,
        this.ubo = !0) : (this.uniforms = t,
        this.ubo && (this.buffer = new ce(new Float32Array(1)),
        this.buffer.type = Er.UNIFORM_BUFFER,
        this.autoManage = !0))
    }
    update() {
        this.dirtyId++,
        !this.autoManage && this.buffer && this.buffer.update()
    }
    add(t, e, i) {
        if (!this.ubo)
            this.uniforms[t] = new ar(e,i);
        else
            throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }
    static from(t, e, i) {
        return new ar(t,e,i)
    }
    static uboFrom(t, e) {
        return new ar(t,e ?? !0,!0)
    }
}
class Dr {
    constructor(t, e) {
        this.uniformBindCount = 0,
        this.program = t,
        e ? e instanceof ar ? this.uniformGroup = e : this.uniformGroup = new ar(e) : this.uniformGroup = new ar({}),
        this.disposeRunner = new Vi("disposeShader")
    }
    checkUniformExists(t, e) {
        if (e.uniforms[t])
            return !0;
        for (const i in e.uniforms) {
            const r = e.uniforms[i];
            if (r.group === !0 && this.checkUniformExists(t, r))
                return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null,
        this.disposeRunner.emit(this),
        this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, e, i) {
        const r = qr.from(t, e);
        return new Dr(r,i)
    }
}
class D1 {
    constructor(t, e) {
        if (this.vertexSrc = t,
        this.fragTemplate = e,
        this.programCache = {},
        this.defaultGroupCache = {},
        !e.includes("%count%"))
            throw new Error('Fragment template must contain "%count%".');
        if (!e.includes("%forloop%"))
            throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const i = new Int32Array(t);
            for (let n = 0; n < t; n++)
                i[n] = n;
            this.defaultGroupCache[t] = ar.from({
                uSamplers: i
            }, !0);
            let r = this.fragTemplate;
            r = r.replace(/%count%/gi, `${t}`),
            r = r.replace(/%forloop%/gi, this.generateSampleSrc(t)),
            this.programCache[t] = new qr(this.vertexSrc,r)
        }
        const e = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Qt,
            default: this.defaultGroupCache[t]
        };
        return new Dr(this.programCache[t],e)
    }
    generateSampleSrc(t) {
        let e = "";
        e += `
`,
        e += `
`;
        for (let i = 0; i < t; i++)
            i > 0 && (e += `
else `),
            i < t - 1 && (e += `if(vTextureId < ${i}.5)`),
            e += `
{`,
            e += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`,
            e += `
}`;
        return e += `
`,
        e += `
`,
        e
    }
}
class ic {
    constructor() {
        this.elements = [],
        this.ids = [],
        this.count = 0
    }
    clear() {
        for (let t = 0; t < this.count; t++)
            this.elements[t] = null;
        this.count = 0
    }
}
function WP() {
    return !br.apple.device
}
function jP(s) {
    let t = !0;
    const e = nt.ADAPTER.getNavigator();
    if (br.tablet || br.phone) {
        if (br.apple.device) {
            const i = e.userAgent.match(/OS (\d+)_(\d+)?/);
            i && parseInt(i[1], 10) < 11 && (t = !1)
        }
        if (br.android.device) {
            const i = e.userAgent.match(/Android\s([0-9.]*)/);
            i && parseInt(i[1], 10) < 7 && (t = !1)
        }
    }
    return t ? s : 4
}
class Ql {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
var qP = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`
  , YP = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const ka = class mr extends Ql {
    constructor(t) {
        super(t),
        this.setShaderGenerator(),
        this.geometryClass = Nm,
        this.vertexSize = 6,
        this.state = Sr.for2d(),
        this.size = mr.defaultBatchSize * 4,
        this._vertexCount = 0,
        this._indexCount = 0,
        this._bufferedElements = [],
        this._bufferedTextures = [],
        this._bufferSize = 0,
        this._shader = null,
        this._packedGeometries = [],
        this._packedGeometryPoolSize = 2,
        this._flushId = 0,
        this._aBuffers = {},
        this._iBuffers = {},
        this.maxTextures = 1,
        this.renderer.on("prerender", this.onPrerender, this),
        t.runners.contextChange.add(this),
        this._dcIndex = 0,
        this._aIndex = 0,
        this._iIndex = 0,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures ?? jP(32),
        this._defaultMaxTextures
    }
    static set defaultMaxTextures(t) {
        this._defaultMaxTextures = t
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? WP(),
        this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(t) {
        this._canUploadSameBuffer = t
    }
    get MAX_TEXTURES() {
        return Et("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),
        this.maxTextures
    }
    static get defaultVertexSrc() {
        return YP
    }
    static get defaultFragmentTemplate() {
        return qP
    }
    setShaderGenerator({vertex: t=mr.defaultVertexSrc, fragment: e=mr.defaultFragmentTemplate}={}) {
        this.shaderGenerator = new D1(t,e)
    }
    contextChange() {
        const t = this.renderer.gl;
        nt.PREFER_ENV === rn.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), mr.defaultMaxTextures),
        this.maxTextures = m1(this.maxTextures, t)),
        this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let e = 0; e < this._packedGeometryPoolSize; e++)
            this._packedGeometries[e] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const {_drawCallPool: t, _textureArrayPool: e} = mr
          , i = this.size / 4
          , r = Math.floor(i / this.maxTextures) + 1;
        for (; t.length < i; )
            t.push(new ec);
        for (; e.length < r; )
            e.push(new ic);
        for (let n = 0; n < this.maxTextures; n++)
            this._tempBoundTextures[n] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(t) {
        t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(),
        this._vertexCount += t.vertexData.length / 2,
        this._indexCount += t.indices.length,
        this._bufferedTextures[this._bufferSize] = t._texture.baseTexture,
        this._bufferedElements[this._bufferSize++] = t)
    }
    buildTexturesAndDrawCalls() {
        const {_bufferedTextures: t, maxTextures: e} = this
          , i = mr._textureArrayPool
          , r = this.renderer.batch
          , n = this._tempBoundTextures
          , o = this.renderer.textureGC.count;
        let a = ++At._globalBatch
          , l = 0
          , h = i[0]
          , u = 0;
        r.copyBoundTextures(n, e);
        for (let c = 0; c < this._bufferSize; ++c) {
            const d = t[c];
            t[c] = null,
            d._batchEnabled !== a && (h.count >= e && (r.boundArray(h, n, a, e),
            this.buildDrawCalls(h, u, c),
            u = c,
            h = i[++l],
            ++a),
            d._batchEnabled = a,
            d.touched = o,
            h.elements[h.count++] = d)
        }
        h.count > 0 && (r.boundArray(h, n, a, e),
        this.buildDrawCalls(h, u, this._bufferSize),
        ++l,
        ++a);
        for (let c = 0; c < n.length; c++)
            n[c] = null;
        At._globalBatch = a
    }
    buildDrawCalls(t, e, i) {
        const {_bufferedElements: r, _attributeBuffer: n, _indexBuffer: o, vertexSize: a} = this
          , l = mr._drawCallPool;
        let h = this._dcIndex
          , u = this._aIndex
          , c = this._iIndex
          , d = l[h];
        d.start = this._iIndex,
        d.texArray = t;
        for (let f = e; f < i; ++f) {
            const p = r[f]
              , m = p._texture.baseTexture
              , g = Om[m.alphaMode ? 1 : 0][p.blendMode];
            r[f] = null,
            e < f && d.blend !== g && (d.size = c - d.start,
            e = f,
            d = l[++h],
            d.texArray = t,
            d.start = c),
            this.packInterleavedGeometry(p, n, o, u, c),
            u += p.vertexData.length / 2 * a,
            c += p.indices.length,
            d.blend = g
        }
        e < i && (d.size = c - d.start,
        ++h),
        this._dcIndex = h,
        this._aIndex = u,
        this._iIndex = c
    }
    bindAndClearTexArray(t) {
        const e = this.renderer.texture;
        for (let i = 0; i < t.count; i++)
            e.bind(t.elements[i], t.ids[i]),
            t.elements[i] = null;
        t.count = 0
    }
    updateGeometry() {
        const {_packedGeometries: t, _attributeBuffer: e, _indexBuffer: i} = this;
        mr.canUploadSameBuffer ? (t[this._flushId]._buffer.update(e.rawBinaryData),
        t[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++,
        t[this._flushId] = new this.geometryClass),
        t[this._flushId]._buffer.update(e.rawBinaryData),
        t[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.bind(t[this._flushId]),
        this.renderer.geometry.updateBuffers(),
        this._flushId++)
    }
    drawBatches() {
        const t = this._dcIndex
          , {gl: e, state: i} = this.renderer
          , r = mr._drawCallPool;
        let n = null;
        for (let o = 0; o < t; o++) {
            const {texArray: a, type: l, size: h, start: u, blend: c} = r[o];
            n !== a && (n = a,
            this.bindAndClearTexArray(a)),
            this.state.blendMode = c,
            i.set(this.state),
            e.drawElements(l, h, e.UNSIGNED_SHORT, u * 2)
        }
    }
    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount),
        this._indexBuffer = this.getIndexBuffer(this._indexCount),
        this._aIndex = 0,
        this._iIndex = 0,
        this._dcIndex = 0,
        this.buildTexturesAndDrawCalls(),
        this.updateGeometry(),
        this.drawBatches(),
        this._bufferSize = 0,
        this._vertexCount = 0,
        this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state),
        this.renderer.texture.ensureSamplerType(this.maxTextures),
        this.renderer.shader.bind(this._shader),
        mr.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let t = 0; t < this._packedGeometryPoolSize; t++)
            this._packedGeometries[t] && this._packedGeometries[t].destroy();
        this.renderer.off("prerender", this.onPrerender, this),
        this._aBuffers = null,
        this._iBuffers = null,
        this._packedGeometries = null,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._shader && (this._shader.destroy(),
        this._shader = null),
        super.destroy()
    }
    getAttributeBuffer(t) {
        const e = Rl(Math.ceil(t / 8))
          , i = rp(e)
          , r = e * 8;
        this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
        let n = this._aBuffers[r];
        return n || (this._aBuffers[r] = n = new Ju(r * this.vertexSize * 4)),
        n
    }
    getIndexBuffer(t) {
        const e = Rl(Math.ceil(t / 12))
          , i = rp(e)
          , r = e * 12;
        this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
        let n = this._iBuffers[i];
        return n || (this._iBuffers[i] = n = new Uint16Array(r)),
        n
    }
    packInterleavedGeometry(t, e, i, r, n) {
        const {uint32View: o, float32View: a} = e
          , l = r / this.vertexSize
          , h = t.uvs
          , u = t.indices
          , c = t.vertexData
          , d = t._texture.baseTexture._batchLocation
          , f = Math.min(t.worldAlpha, 1)
          , p = zt.shared.setValue(t._tintRGB).toPremultiplied(f, t._texture.baseTexture.alphaMode > 0);
        for (let m = 0; m < c.length; m += 2)
            a[r++] = c[m],
            a[r++] = c[m + 1],
            a[r++] = h[m],
            a[r++] = h[m + 1],
            o[r++] = p,
            a[r++] = d;
        for (let m = 0; m < u.length; m++)
            i[n++] = l + u[m]
    }
}
;
ka.defaultBatchSize = 4096,
ka.extension = {
    name: "batch",
    type: it.RendererPlugin
},
ka._drawCallPool = [],
ka._textureArrayPool = [];
let Rs = ka;
ct.add(Rs);
var KP = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`
  , ZP = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const dp = class La extends Dr {
    constructor(t, e, i) {
        const r = qr.from(t || La.defaultVertexSrc, e || La.defaultFragmentSrc);
        super(r, i),
        this.padding = 0,
        this.resolution = La.defaultResolution,
        this.multisample = La.defaultMultisample,
        this.enabled = !0,
        this.autoFit = !0,
        this.state = new Sr
    }
    apply(t, e, i, r, n) {
        t.applyFilter(this, e, i, r)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._resolution = t
    }
    static get defaultVertexSrc() {
        return ZP
    }
    static get defaultFragmentSrc() {
        return KP
    }
}
;
dp.defaultResolution = 1,
dp.defaultMultisample = ge.NONE;
let ti = dp;
class Bl {
    constructor() {
        this.clearBeforeRender = !0,
        this._backgroundColor = new zt(0),
        this.alpha = 1
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender;
        const {backgroundColor: e, background: i, backgroundAlpha: r} = t
          , n = i ?? e;
        n !== void 0 && (this.color = n),
        this.alpha = r
    }
    get color() {
        return this._backgroundColor.value
    }
    set color(t) {
        this._backgroundColor.setValue(t)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(t) {
        this._backgroundColor.setAlpha(t)
    }
    get backgroundColor() {
        return this._backgroundColor
    }
    destroy() {}
}
Bl.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
},
Bl.extension = {
    type: [it.RendererSystem, it.CanvasRendererSystem],
    name: "background"
};
ct.add(Bl);
class Um {
    constructor(t) {
        this.renderer = t,
        this.emptyRenderer = new Ql(t),
        this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(),
        this.currentRenderer = t,
        this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, e) {
        const {boundTextures: i} = this.renderer.texture;
        for (let r = e - 1; r >= 0; --r)
            t[r] = i[r] || null,
            t[r] && (t[r]._batchLocation = r)
    }
    boundArray(t, e, i, r) {
        const {elements: n, ids: o, count: a} = t;
        let l = 0;
        for (let h = 0; h < a; h++) {
            const u = n[h]
              , c = u._batchLocation;
            if (c >= 0 && c < r && e[c] === u) {
                o[h] = c;
                continue
            }
            for (; l < r; ) {
                const d = e[l];
                if (d && d._batchEnabled === i && d._batchLocation === l) {
                    l++;
                    continue
                }
                o[h] = l,
                u._batchLocation = l,
                e[l] = u;
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
Um.extension = {
    type: it.RendererSystem,
    name: "batch"
};
ct.add(Um);
let X_ = 0;
class Ol {
    constructor(t) {
        this.renderer = t,
        this.webGLVersion = 1,
        this.extensions = {},
        this.supports = {
            uint32Indices: !1
        },
        this.handleContextLost = this.handleContextLost.bind(this),
        this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        this.gl = t,
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = X_++
    }
    init(t) {
        if (t.context)
            this.initFromContext(t.context);
        else {
            const e = this.renderer.background.alpha < 1
              , i = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer,
            this.useContextAlpha = t.useContextAlpha,
            this.powerPreference = t.powerPreference,
            this.initFromOptions({
                alpha: e,
                premultipliedAlpha: i,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }
    initFromContext(t) {
        this.gl = t,
        this.validateContext(t),
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = X_++,
        this.renderer.runners.contextChange.emit(t);
        const e = this.renderer.view;
        e.addEventListener !== void 0 && (e.addEventListener("webglcontextlost", this.handleContextLost, !1),
        e.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(t) {
        const e = this.createContext(this.renderer.view, t);
        this.initFromContext(e)
    }
    createContext(t, e) {
        let i;
        if (nt.PREFER_ENV >= rn.WEBGL2 && (i = t.getContext("webgl2", e)),
        i)
            this.webGLVersion = 2;
        else if (this.webGLVersion = 1,
        i = t.getContext("webgl", e) || t.getContext("experimental-webgl", e),
        !i)
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = i,
        this.getExtensions(),
        this.gl
    }
    getExtensions() {
        const {gl: t} = this
          , e = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc"),
            bptc: t.getExtension("EXT_texture_compression_bptc")
        };
        this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
            colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(t) {
        t.preventDefault(),
        setTimeout(()=>{
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }
        , 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view;
        this.renderer = null,
        t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost),
        t.removeEventListener("webglcontextrestored", this.handleContextRestored)),
        this.gl.useProgram(null),
        this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const e = t.getContextAttributes()
          , i = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        i && (this.webGLVersion = 2),
        e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const r = i || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = r,
        r || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
Ol.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: "default"
},
Ol.extension = {
    type: it.RendererSystem,
    name: "context"
};
ct.add(Ol);
class rc {
    constructor(t, e) {
        if (this.width = Math.round(t),
        this.height = Math.round(e),
        !this.width || !this.height)
            throw new Error("Framebuffer width or height is zero");
        this.stencil = !1,
        this.depth = !1,
        this.dirtyId = 0,
        this.dirtyFormat = 0,
        this.dirtySize = 0,
        this.depthTexture = null,
        this.colorTextures = [],
        this.glFramebuffers = {},
        this.disposeRunner = new Vi("disposeFramebuffer"),
        this.multisample = ge.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t=0, e) {
        return this.colorTextures[t] = e || new At(null,{
            scaleMode: Wr.NEAREST,
            resolution: 1,
            mipmap: Ar.OFF,
            width: this.width,
            height: this.height
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    addDepthTexture(t) {
        return this.depthTexture = t || new At(null,{
            scaleMode: Wr.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: Ar.OFF,
            format: J.DEPTH_COMPONENT,
            type: ft.UNSIGNED_SHORT
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableDepth() {
        return this.depth = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableStencil() {
        return this.stencil = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    resize(t, e) {
        if (t = Math.round(t),
        e = Math.round(e),
        !t || !e)
            throw new Error("Framebuffer width and height must not be zero");
        if (!(t === this.width && e === this.height)) {
            this.width = t,
            this.height = e,
            this.dirtyId++,
            this.dirtySize++;
            for (let i = 0; i < this.colorTextures.length; i++) {
                const r = this.colorTextures[i]
                  , n = r.resolution;
                r.setSize(t / n, e / n)
            }
            if (this.depthTexture) {
                const i = this.depthTexture.resolution;
                this.depthTexture.setSize(t / i, e / i)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(),
        this.depthTexture = null,
        ++this.dirtyId,
        ++this.dirtyFormat)
    }
}
class Gm extends At {
    constructor(t={}) {
        if (typeof t == "number") {
            const e = arguments[0]
              , i = arguments[1]
              , r = arguments[2]
              , n = arguments[3];
            t = {
                width: e,
                height: i,
                scaleMode: r,
                resolution: n
            }
        }
        t.width = t.width ?? 100,
        t.height = t.height ?? 100,
        t.multisample ?? (t.multisample = ge.NONE),
        super(null, t),
        this.mipmap = Ar.OFF,
        this.valid = !0,
        this._clear = new zt([0, 0, 0, 0]),
        this.framebuffer = new rc(this.realWidth,this.realHeight).addColorTexture(0, this),
        this.framebuffer.multisample = t.multisample,
        this.maskStack = [],
        this.filterStack = [{}]
    }
    set clearColor(t) {
        this._clear.setValue(t)
    }
    get clearColor() {
        return this._clear.value
    }
    get clear() {
        return this._clear
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, e) {
        this.framebuffer.resize(t * this.resolution, e * this.resolution),
        this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(),
        super.dispose()
    }
    destroy() {
        super.destroy(),
        this.framebuffer.destroyDepthTexture(),
        this.framebuffer = null
    }
}
class rs extends ia {
    constructor(t) {
        const e = t
          , i = e.naturalWidth || e.videoWidth || e.displayWidth || e.width
          , r = e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
        super(i, r),
        this.source = t,
        this.noSubImage = !1
    }
    static crossOrigin(t, e, i) {
        i === void 0 && !e.startsWith("data:") ? t.crossOrigin = p1(e) : i !== !1 && (t.crossOrigin = typeof i == "string" ? i : "anonymous")
    }
    upload(t, e, i, r) {
        const n = t.gl
          , o = e.realWidth
          , a = e.realHeight;
        if (r = r || this.source,
        typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) {
            if (!r.complete || r.naturalWidth === 0)
                return !1
        } else if (typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement && r.readyState <= 1)
            return !1;
        return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === _i.UNPACK),
        !this.noSubImage && e.target === n.TEXTURE_2D && i.width === o && i.height === a ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, i.type, r) : (i.width = o,
        i.height = a,
        n.texImage2D(e.target, 0, i.internalFormat, e.format, i.type, r)),
        !0
    }
    update() {
        if (this.destroyed)
            return;
        const t = this.source
          , e = t.naturalWidth || t.videoWidth || t.width
          , i = t.naturalHeight || t.videoHeight || t.height;
        this.resize(e, i),
        super.update()
    }
    dispose() {
        this.source = null
    }
}
class Hm extends rs {
    constructor(t, e) {
        if (e = e || {},
        typeof t == "string") {
            const i = new Image;
            rs.crossOrigin(i, t, e.crossorigin),
            i.src = t,
            t = i
        }
        super(t),
        !t.complete && this._width && this._height && (this._width = 0,
        this._height = 0),
        this.url = t.src,
        this._process = null,
        this.preserveBitmap = !1,
        this.createBitmap = (e.createBitmap ?? nt.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap,
        this.alphaMode = typeof e.alphaMode == "number" ? e.alphaMode : null,
        this.bitmap = null,
        this._load = null,
        e.autoLoad !== !1 && this.load()
    }
    load(t) {
        return this._load ? this._load : (t !== void 0 && (this.createBitmap = t),
        this._load = new Promise((e,i)=>{
            const r = this.source;
            this.url = r.src;
            const n = ()=>{
                this.destroyed || (r.onload = null,
                r.onerror = null,
                this.update(),
                this._load = null,
                this.createBitmap ? e(this.process()) : e(this))
            }
            ;
            r.complete && r.src ? n() : (r.onload = n,
            r.onerror = o=>{
                i(o),
                this.onError.emit(o)
            }
            )
        }
        ),
        this._load)
    }
    process() {
        const t = this.source;
        if (this._process !== null)
            return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap)
            return Promise.resolve(this);
        const e = globalThis.createImageBitmap
          , i = !t.crossOrigin || t.crossOrigin === "anonymous";
        return this._process = fetch(t.src, {
            mode: i ? "cors" : "no-cors"
        }).then(r=>r.blob()).then(r=>e(r, 0, 0, t.width, t.height, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === _i.UNPACK ? "premultiply" : "none"
        })).then(r=>this.destroyed ? Promise.reject() : (this.bitmap = r,
        this.update(),
        this._process = null,
        Promise.resolve(this))),
        this._process
    }
    upload(t, e, i) {
        if (typeof this.alphaMode == "number" && (e.alphaMode = this.alphaMode),
        !this.createBitmap)
            return super.upload(t, e, i);
        if (!this.bitmap && (this.process(),
        !this.bitmap))
            return !1;
        if (super.upload(t, e, i, this.bitmap),
        !this.preserveBitmap) {
            let r = !0;
            const n = e._glTextures;
            for (const o in n) {
                const a = n[o];
                if (a !== i && a.dirtyId !== e.dirtyId) {
                    r = !1;
                    break
                }
            }
            r && (this.bitmap.close && this.bitmap.close(),
            this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null,
        this.source.onerror = null,
        super.dispose(),
        this.bitmap && (this.bitmap.close(),
        this.bitmap = null),
        this._process = null,
        this._load = null
    }
    static test(t) {
        return typeof HTMLImageElement < "u" && (typeof t == "string" || t instanceof HTMLImageElement)
    }
}
class Rc {
    constructor() {
        this.x0 = 0,
        this.y0 = 0,
        this.x1 = 1,
        this.y1 = 0,
        this.x2 = 1,
        this.y2 = 1,
        this.x3 = 0,
        this.y3 = 1,
        this.uvsFloat32 = new Float32Array(8)
    }
    set(t, e, i) {
        const r = e.width
          , n = e.height;
        if (i) {
            const o = t.width / 2 / r
              , a = t.height / 2 / n
              , l = t.x / r + o
              , h = t.y / n + a;
            i = ie.add(i, ie.NW),
            this.x0 = l + o * ie.uX(i),
            this.y0 = h + a * ie.uY(i),
            i = ie.add(i, 2),
            this.x1 = l + o * ie.uX(i),
            this.y1 = h + a * ie.uY(i),
            i = ie.add(i, 2),
            this.x2 = l + o * ie.uX(i),
            this.y2 = h + a * ie.uY(i),
            i = ie.add(i, 2),
            this.x3 = l + o * ie.uX(i),
            this.y3 = h + a * ie.uY(i)
        } else
            this.x0 = t.x / r,
            this.y0 = t.y / n,
            this.x1 = (t.x + t.width) / r,
            this.y1 = t.y / n,
            this.x2 = (t.x + t.width) / r,
            this.y2 = (t.y + t.height) / n,
            this.x3 = t.x / r,
            this.y3 = (t.y + t.height) / n;
        this.uvsFloat32[0] = this.x0,
        this.uvsFloat32[1] = this.y0,
        this.uvsFloat32[2] = this.x1,
        this.uvsFloat32[3] = this.y1,
        this.uvsFloat32[4] = this.x2,
        this.uvsFloat32[5] = this.y2,
        this.uvsFloat32[6] = this.x3,
        this.uvsFloat32[7] = this.y3
    }
}
Rc.prototype.toString = function() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
}
;
const W_ = new Rc;
function Uh(s) {
    s.destroy = function() {}
    ,
    s.on = function() {}
    ,
    s.once = function() {}
    ,
    s.emit = function() {}
}
class st extends na {
    constructor(t, e, i, r, n, o, a) {
        if (super(),
        this.noFrame = !1,
        e || (this.noFrame = !0,
        e = new St(0,0,1,1)),
        t instanceof st && (t = t.baseTexture),
        this.baseTexture = t,
        this._frame = e,
        this.trim = r,
        this.valid = !1,
        this.destroyed = !1,
        this._uvs = W_,
        this.uvMatrix = null,
        this.orig = i || e,
        this._rotate = Number(n || 0),
        n === !0)
            this._rotate = 2;
        else if (this._rotate % 2 !== 0)
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new Nt(o.x,o.y) : new Nt(0,0),
        this.defaultBorders = a,
        this._updateID = 0,
        this.textureCacheIds = [],
        t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = e : t.once("loaded", this.onBaseTextureUpdated, this),
        this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid)
                return;
            this._frame.width = t.width,
            this._frame.height = t.height,
            this.valid = !0,
            this.updateUvs()
        } else
            this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {resource: e} = this.baseTexture;
                e?.url && ci[e.url] && st.removeFromCache(e.url),
                this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
            this.baseTexture.off("update", this.onBaseTextureUpdated, this),
            this.baseTexture = null
        }
        this._frame = null,
        this._uvs = null,
        this.trim = null,
        this.orig = null,
        this.valid = !1,
        st.removeFromCache(this),
        this.textureCacheIds = null,
        this.destroyed = !0,
        this.emit("destroyed", this),
        this.removeAllListeners()
    }
    clone() {
        const t = this._frame.clone()
          , e = this._frame === this.orig ? t : this.orig.clone()
          , i = new st(this.baseTexture,!this.noFrame && t,e,this.trim?.clone(),this.rotate,this.defaultAnchor,this.defaultBorders);
        return this.noFrame && (i._frame = t),
        i
    }
    updateUvs() {
        this._uvs === W_ && (this._uvs = new Rc),
        this._uvs.set(this._frame, this.baseTexture, this.rotate),
        this._updateID++
    }
    static from(t, e={}, i=nt.STRICT_TEXTURE_CACHE) {
        const r = typeof t == "string";
        let n = null;
        if (r)
            n = t;
        else if (t instanceof At) {
            if (!t.cacheId) {
                const a = e?.pixiIdPrefix || "pixiid";
                t.cacheId = `${a}-${Js()}`,
                At.addToCache(t, t.cacheId)
            }
            n = t.cacheId
        } else {
            if (!t._pixiId) {
                const a = e?.pixiIdPrefix || "pixiid";
                t._pixiId = `${a}_${Js()}`
            }
            n = t._pixiId
        }
        let o = ci[n];
        if (r && i && !o)
            throw new Error(`The cacheId "${n}" does not exist in TextureCache.`);
        return !o && !(t instanceof At) ? (e.resolution || (e.resolution = is(t)),
        o = new st(new At(t,e)),
        o.baseTexture.cacheId = n,
        At.addToCache(o.baseTexture, n),
        st.addToCache(o, n)) : !o && t instanceof At && (o = new st(t),
        st.addToCache(o, n)),
        o
    }
    static fromURL(t, e) {
        const i = Object.assign({
            autoLoad: !1
        }, e?.resourceOptions)
          , r = st.from(t, Object.assign({
            resourceOptions: i
        }, e), !1)
          , n = r.baseTexture.resource;
        return r.baseTexture.valid ? Promise.resolve(r) : n.load().then(()=>Promise.resolve(r))
    }
    static fromBuffer(t, e, i, r) {
        return new st(At.fromBuffer(t, e, i, r))
    }
    static fromLoader(t, e, i, r) {
        const n = new At(t,Object.assign({
            scaleMode: At.defaultOptions.scaleMode,
            resolution: is(e)
        }, r))
          , {resource: o} = n;
        o instanceof Hm && (o.url = e);
        const a = new st(n);
        return i || (i = e),
        At.addToCache(a.baseTexture, i),
        st.addToCache(a, i),
        i !== e && (At.addToCache(a.baseTexture, e),
        st.addToCache(a, e)),
        a.baseTexture.valid ? Promise.resolve(a) : new Promise(l=>{
            a.baseTexture.once("loaded", ()=>l(a))
        }
        )
    }
    static addToCache(t, e) {
        e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
        ci[e] && ci[e] !== t && console.warn(`Texture added to the cache with an id [${e}] that already had an entry`),
        ci[e] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const e = ci[t];
            if (e) {
                const i = e.textureCacheIds.indexOf(t);
                return i > -1 && e.textureCacheIds.splice(i, 1),
                delete ci[t],
                e
            }
        } else if (t?.textureCacheIds) {
            for (let e = 0; e < t.textureCacheIds.length; ++e)
                ci[t.textureCacheIds[e]] === t && delete ci[t.textureCacheIds[e]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        this._frame = t,
        this.noFrame = !1;
        const {x: e, y: i, width: r, height: n} = t
          , o = e + r > this.baseTexture.width
          , a = i + n > this.baseTexture.height;
        if (o || a) {
            const l = o && a ? "and" : "or"
              , h = `X: ${e} + ${r} = ${e + r} > ${this.baseTexture.width}`
              , u = `Y: ${i} + ${n} = ${i + n} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${h} ${l} ${u}`)
        }
        this.valid = r && n && this.baseTexture.valid,
        !this.trim && !this.rotate && (this.orig = t),
        this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        this._rotate = t,
        this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return st._EMPTY || (st._EMPTY = new st(new At),
        Uh(st._EMPTY),
        Uh(st._EMPTY.baseTexture)),
        st._EMPTY
    }
    static get WHITE() {
        if (!st._WHITE) {
            const t = nt.ADAPTER.createCanvas(16, 16)
              , e = t.getContext("2d");
            t.width = 16,
            t.height = 16,
            e.fillStyle = "white",
            e.fillRect(0, 0, 16, 16),
            st._WHITE = new st(At.from(t)),
            Uh(st._WHITE),
            Uh(st._WHITE.baseTexture)
        }
        return st._WHITE
    }
}
class nn extends st {
    constructor(t, e) {
        super(t, e),
        this.valid = !0,
        this.filterFrame = null,
        this.filterPoolKey = null,
        this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, e, i=!0) {
        const r = this.baseTexture.resolution
          , n = Math.round(t * r) / r
          , o = Math.round(e * r) / r;
        this.valid = n > 0 && o > 0,
        this._frame.width = this.orig.width = n,
        this._frame.height = this.orig.height = o,
        i && this.baseTexture.resize(n, o),
        this.updateUvs()
    }
    setResolution(t) {
        const {baseTexture: e} = this;
        e.resolution !== t && (e.setResolution(t),
        this.resize(e.width, e.height, !1))
    }
    static create(t) {
        return new nn(new Gm(t))
    }
}
class $m {
    constructor(t) {
        this.texturePool = {},
        this.textureOptions = t || {},
        this.enableFullScreen = !1,
        this._pixelsWidth = 0,
        this._pixelsHeight = 0
    }
    createTexture(t, e, i=ge.NONE) {
        const r = new Gm(Object.assign({
            width: t,
            height: e,
            resolution: 1,
            multisample: i
        }, this.textureOptions));
        return new nn(r)
    }
    getOptimalTexture(t, e, i=1, r=ge.NONE) {
        let n;
        t = Math.max(Math.ceil(t * i - 1e-6), 1),
        e = Math.max(Math.ceil(e * i - 1e-6), 1),
        !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = Rl(t),
        e = Rl(e),
        n = ((t & 65535) << 16 | e & 65535) >>> 0,
        r > 1 && (n += r * 4294967296)) : n = r > 1 ? -r : -1,
        this.texturePool[n] || (this.texturePool[n] = []);
        let o = this.texturePool[n].pop();
        return o || (o = this.createTexture(t, e, r)),
        o.filterPoolKey = n,
        o.setResolution(i),
        o
    }
    getFilterTexture(t, e, i) {
        const r = this.getOptimalTexture(t.width, t.height, e || t.resolution, i || ge.NONE);
        return r.filterFrame = t.filterFrame,
        r
    }
    returnTexture(t) {
        const e = t.filterPoolKey;
        t.filterFrame = null,
        this.texturePool[e].push(t)
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (t = t !== !1,
        t)
            for (const e in this.texturePool) {
                const i = this.texturePool[e];
                if (i)
                    for (let r = 0; r < i.length; r++)
                        i[r].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const e in this.texturePool) {
                if (!(Number(e) < 0))
                    continue;
                const i = this.texturePool[e];
                if (i)
                    for (let r = 0; r < i.length; r++)
                        i[r].destroy(!0);
                this.texturePool[e] = []
            }
            this._pixelsWidth = t.width,
            this._pixelsHeight = t.height
        }
    }
}
$m.SCREEN_KEY = -1;
class A1 extends ws {
    constructor() {
        super(),
        this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class zm extends ws {
    constructor() {
        super(),
        this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]),
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        this.vertexBuffer = new ce(this.vertices),
        this.uvBuffer = new ce(this.uvs),
        this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(t, e) {
        let i = 0
          , r = 0;
        return this.uvs[0] = i,
        this.uvs[1] = r,
        this.uvs[2] = i + e.width / t.width,
        this.uvs[3] = r,
        this.uvs[4] = i + e.width / t.width,
        this.uvs[5] = r + e.height / t.height,
        this.uvs[6] = i,
        this.uvs[7] = r + e.height / t.height,
        i = e.x,
        r = e.y,
        this.vertices[0] = i,
        this.vertices[1] = r,
        this.vertices[2] = i + e.width,
        this.vertices[3] = r,
        this.vertices[4] = i + e.width,
        this.vertices[5] = r + e.height,
        this.vertices[6] = i,
        this.vertices[7] = r + e.height,
        this.invalidate(),
        this
    }
    invalidate() {
        return this.vertexBuffer._updateID++,
        this.uvBuffer._updateID++,
        this
    }
}
class S1 {
    constructor() {
        this.renderTexture = null,
        this.target = null,
        this.legacy = !1,
        this.resolution = 1,
        this.multisample = ge.NONE,
        this.sourceFrame = new St,
        this.destinationFrame = new St,
        this.bindingSourceFrame = new St,
        this.bindingDestinationFrame = new St,
        this.filters = [],
        this.transform = null
    }
    clear() {
        this.target = null,
        this.filters = null,
        this.renderTexture = null
    }
}
const Gh = [new Nt, new Nt, new Nt, new Nt]
  , Ud = new Qt;
class Vm {
    constructor(t) {
        this.renderer = t,
        this.defaultFilterStack = [{}],
        this.texturePool = new $m,
        this.statePool = [],
        this.quad = new A1,
        this.quadUv = new zm,
        this.tempRect = new St,
        this.activeState = {},
        this.globalUniforms = new ar({
            outputFrame: new St,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        },!0),
        this.forceClear = !1,
        this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, e) {
        const i = this.renderer
          , r = this.defaultFilterStack
          , n = this.statePool.pop() || new S1
          , o = i.renderTexture;
        let a, l;
        if (o.current) {
            const g = o.current;
            a = g.resolution,
            l = g.multisample
        } else
            a = i.resolution,
            l = i.multisample;
        let h = e[0].resolution || a
          , u = e[0].multisample ?? l
          , c = e[0].padding
          , d = e[0].autoFit
          , f = e[0].legacy ?? !0;
        for (let g = 1; g < e.length; g++) {
            const _ = e[g];
            h = Math.min(h, _.resolution || a),
            u = Math.min(u, _.multisample ?? l),
            c = this.useMaxPadding ? Math.max(c, _.padding) : c + _.padding,
            d = d && _.autoFit,
            f = f || (_.legacy ?? !0)
        }
        r.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current),
        r.push(n),
        n.resolution = h,
        n.multisample = u,
        n.legacy = f,
        n.target = t,
        n.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
        n.sourceFrame.pad(c);
        const p = this.tempRect.copyFrom(o.sourceFrame);
        i.projection.transform && this.transformAABB(Ud.copyFrom(i.projection.transform).invert(), p),
        d ? (n.sourceFrame.fit(p),
        (n.sourceFrame.width <= 0 || n.sourceFrame.height <= 0) && (n.sourceFrame.width = 0,
        n.sourceFrame.height = 0)) : n.sourceFrame.intersects(p) || (n.sourceFrame.width = 0,
        n.sourceFrame.height = 0),
        this.roundFrame(n.sourceFrame, o.current ? o.current.resolution : i.resolution, o.sourceFrame, o.destinationFrame, i.projection.transform),
        n.renderTexture = this.getOptimalFilterTexture(n.sourceFrame.width, n.sourceFrame.height, h, u),
        n.filters = e,
        n.destinationFrame.width = n.renderTexture.width,
        n.destinationFrame.height = n.renderTexture.height;
        const m = this.tempRect;
        m.x = 0,
        m.y = 0,
        m.width = n.sourceFrame.width,
        m.height = n.sourceFrame.height,
        n.renderTexture.filterFrame = n.sourceFrame,
        n.bindingSourceFrame.copyFrom(o.sourceFrame),
        n.bindingDestinationFrame.copyFrom(o.destinationFrame),
        n.transform = i.projection.transform,
        i.projection.transform = null,
        o.bind(n.renderTexture, n.sourceFrame, m),
        i.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const t = this.defaultFilterStack
          , e = t.pop()
          , i = e.filters;
        this.activeState = e;
        const r = this.globalUniforms.uniforms;
        r.outputFrame = e.sourceFrame,
        r.resolution = e.resolution;
        const n = r.inputSize
          , o = r.inputPixel
          , a = r.inputClamp;
        if (n[0] = e.destinationFrame.width,
        n[1] = e.destinationFrame.height,
        n[2] = 1 / n[0],
        n[3] = 1 / n[1],
        o[0] = Math.round(n[0] * e.resolution),
        o[1] = Math.round(n[1] * e.resolution),
        o[2] = 1 / o[0],
        o[3] = 1 / o[1],
        a[0] = .5 * o[2],
        a[1] = .5 * o[3],
        a[2] = e.sourceFrame.width * n[2] - .5 * o[2],
        a[3] = e.sourceFrame.height * n[3] - .5 * o[3],
        e.legacy) {
            const h = r.filterArea;
            h[0] = e.destinationFrame.width,
            h[1] = e.destinationFrame.height,
            h[2] = e.sourceFrame.x,
            h[3] = e.sourceFrame.y,
            r.filterClamp = r.inputClamp
        }
        this.globalUniforms.update();
        const l = t[t.length - 1];
        if (this.renderer.framebuffer.blit(),
        i.length === 1)
            i[0].apply(this, e.renderTexture, l.renderTexture, yr.BLEND, e),
            this.returnFilterTexture(e.renderTexture);
        else {
            let h = e.renderTexture
              , u = this.getOptimalFilterTexture(h.width, h.height, e.resolution);
            u.filterFrame = h.filterFrame;
            let c = 0;
            for (c = 0; c < i.length - 1; ++c) {
                c === 1 && e.multisample > 1 && (u = this.getOptimalFilterTexture(h.width, h.height, e.resolution),
                u.filterFrame = h.filterFrame),
                i[c].apply(this, h, u, yr.CLEAR, e);
                const d = h;
                h = u,
                u = d
            }
            i[c].apply(this, h, l.renderTexture, yr.BLEND, e),
            c > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture),
            this.returnFilterTexture(h),
            this.returnFilterTexture(u)
        }
        e.clear(),
        this.statePool.push(e)
    }
    bindAndClear(t, e=yr.CLEAR) {
        const {renderTexture: i, state: r} = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null,
        t?.filterFrame) {
            const o = this.tempRect;
            o.x = 0,
            o.y = 0,
            o.width = t.filterFrame.width,
            o.height = t.filterFrame.height,
            i.bind(t, t.filterFrame, o)
        } else
            t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? i.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const n = r.stateId & 1 || this.forceClear;
        (e === yr.CLEAR || e === yr.BLIT && n) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, e, i, r) {
        const n = this.renderer;
        n.state.set(t.state),
        this.bindAndClear(i, r),
        t.uniforms.uSampler = e,
        t.uniforms.filterGlobals = this.globalUniforms,
        n.shader.bind(t),
        t.legacy = !!t.program.attributeData.aTextureCoord,
        t.legacy ? (this.quadUv.map(e._frame, e.filterFrame),
        n.geometry.bind(this.quadUv),
        n.geometry.draw(xr.TRIANGLES)) : (n.geometry.bind(this.quad),
        n.geometry.draw(xr.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(t, e) {
        const {sourceFrame: i, destinationFrame: r} = this.activeState
          , {orig: n} = e._texture
          , o = t.set(r.width, 0, 0, r.height, i.x, i.y)
          , a = e.worldTransform.copyTo(Qt.TEMP_MATRIX);
        return a.invert(),
        o.prepend(a),
        o.scale(1 / n.width, 1 / n.height),
        o.translate(e.anchor.x, e.anchor.y),
        o
    }
    destroy() {
        this.renderer = null,
        this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(t, e, i=1, r=ge.NONE) {
        return this.texturePool.getOptimalTexture(t, e, i, r)
    }
    getFilterTexture(t, e, i) {
        if (typeof t == "number") {
            const n = t;
            t = e,
            e = n
        }
        t = t || this.activeState.renderTexture;
        const r = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, i || ge.NONE);
        return r.filterFrame = t.filterFrame,
        r
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, e) {
        const i = Gh[0]
          , r = Gh[1]
          , n = Gh[2]
          , o = Gh[3];
        i.set(e.left, e.top),
        r.set(e.left, e.bottom),
        n.set(e.right, e.top),
        o.set(e.right, e.bottom),
        t.apply(i, i),
        t.apply(r, r),
        t.apply(n, n),
        t.apply(o, o);
        const a = Math.min(i.x, r.x, n.x, o.x)
          , l = Math.min(i.y, r.y, n.y, o.y)
          , h = Math.max(i.x, r.x, n.x, o.x)
          , u = Math.max(i.y, r.y, n.y, o.y);
        e.x = a,
        e.y = l,
        e.width = h - a,
        e.height = u - l
    }
    roundFrame(t, e, i, r, n) {
        if (!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)) {
            if (n) {
                const {a: o, b: a, c: l, d: h} = n;
                if ((Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(h) > 1e-4))
                    return
            }
            n = n ? Ud.copyFrom(n) : Ud.identity(),
            n.translate(-i.x, -i.y).scale(r.width / i.width, r.height / i.height).translate(r.x, r.y),
            this.transformAABB(n, t),
            t.ceil(e),
            this.transformAABB(n.invert(), t)
        }
    }
}
Vm.extension = {
    type: it.RendererSystem,
    name: "filter"
};
ct.add(Vm);
class C1 {
    constructor(t) {
        this.framebuffer = t,
        this.stencil = null,
        this.dirtyId = -1,
        this.dirtyFormat = -1,
        this.dirtySize = -1,
        this.multisample = ge.NONE,
        this.msaaBuffer = null,
        this.blitFramebuffer = null,
        this.mipLevel = 0
    }
}
const QP = new St;
class Xm {
    constructor(t) {
        this.renderer = t,
        this.managedFramebuffers = [],
        this.unknownFramebuffer = new rc(10,10),
        this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.current = this.unknownFramebuffer,
        this.viewport = new St,
        this.hasMRT = !0,
        this.writeDepthTexture = !0,
        this.renderer.context.webGLVersion === 1) {
            let e = this.renderer.context.extensions.drawBuffers
              , i = this.renderer.context.extensions.depthTexture;
            nt.PREFER_ENV === rn.WEBGL_LEGACY && (e = null,
            i = null),
            e ? t.drawBuffers = r=>e.drawBuffersWEBGL(r) : (this.hasMRT = !1,
            t.drawBuffers = ()=>{}
            ),
            i || (this.writeDepthTexture = !1)
        } else
            this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }
    bind(t, e, i=0) {
        const {gl: r} = this;
        if (t) {
            const n = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t,
            r.bindFramebuffer(r.FRAMEBUFFER, n.framebuffer)),
            n.mipLevel !== i && (t.dirtyId++,
            t.dirtyFormat++,
            n.mipLevel = i),
            n.dirtyId !== t.dirtyId && (n.dirtyId = t.dirtyId,
            n.dirtyFormat !== t.dirtyFormat ? (n.dirtyFormat = t.dirtyFormat,
            n.dirtySize = t.dirtySize,
            this.updateFramebuffer(t, i)) : n.dirtySize !== t.dirtySize && (n.dirtySize = t.dirtySize,
            this.resizeFramebuffer(t)));
            for (let o = 0; o < t.colorTextures.length; o++) {
                const a = t.colorTextures[o];
                this.renderer.texture.unbind(a.parentTextureArray || a)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
            e) {
                const o = e.width >> i
                  , a = e.height >> i
                  , l = o / e.width;
                this.setViewport(e.x * l, e.y * l, o, a)
            } else {
                const o = t.width >> i
                  , a = t.height >> i;
                this.setViewport(0, 0, o, a)
            }
        } else
            this.current && (this.current = null,
            r.bindFramebuffer(r.FRAMEBUFFER, null)),
            e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(t, e, i, r) {
        const n = this.viewport;
        t = Math.round(t),
        e = Math.round(e),
        i = Math.round(i),
        r = Math.round(r),
        (n.width !== i || n.height !== r || n.x !== t || n.y !== e) && (n.x = t,
        n.y = e,
        n.width = i,
        n.height = r,
        this.gl.viewport(t, e, i, r))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(t, e, i, r, n=ju.COLOR | ju.DEPTH) {
        const {gl: o} = this;
        o.clearColor(t, e, i, r),
        o.clear(n)
    }
    initFramebuffer(t) {
        const {gl: e} = this
          , i = new C1(e.createFramebuffer());
        return i.multisample = this.detectSamples(t.multisample),
        t.glFramebuffers[this.CONTEXT_UID] = i,
        this.managedFramebuffers.push(t),
        t.disposeRunner.add(this),
        i
    }
    resizeFramebuffer(t) {
        const {gl: e} = this
          , i = t.glFramebuffers[this.CONTEXT_UID];
        if (i.stencil) {
            e.bindRenderbuffer(e.RENDERBUFFER, i.stencil);
            let o;
            this.renderer.context.webGLVersion === 1 ? o = e.DEPTH_STENCIL : t.depth && t.stencil ? o = e.DEPTH24_STENCIL8 : t.depth ? o = e.DEPTH_COMPONENT24 : o = e.STENCIL_INDEX8,
            i.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, o, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, o, t.width, t.height)
        }
        const r = t.colorTextures;
        let n = r.length;
        e.drawBuffers || (n = Math.min(n, 1));
        for (let o = 0; o < n; o++) {
            const a = r[o]
              , l = a.parentTextureArray || a;
            this.renderer.texture.bind(l, 0),
            o === 0 && i.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer),
            e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, e) {
        const {gl: i} = this
          , r = t.glFramebuffers[this.CONTEXT_UID]
          , n = t.colorTextures;
        let o = n.length;
        i.drawBuffers || (o = Math.min(o, 1)),
        r.multisample > 1 && this.canMultisampleFramebuffer(t) ? r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer() : r.msaaBuffer && (i.deleteRenderbuffer(r.msaaBuffer),
        r.msaaBuffer = null,
        r.blitFramebuffer && (r.blitFramebuffer.dispose(),
        r.blitFramebuffer = null));
        const a = [];
        for (let l = 0; l < o; l++) {
            const h = n[l]
              , u = h.parentTextureArray || h;
            this.renderer.texture.bind(u, 0),
            l === 0 && r.msaaBuffer ? (i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
            i.renderbufferStorageMultisample(i.RENDERBUFFER, r.multisample, u._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, r.msaaBuffer)) : (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + l, h.target, u._glTextures[this.CONTEXT_UID].texture, e),
            a.push(i.COLOR_ATTACHMENT0 + l))
        }
        if (a.length > 1 && i.drawBuffers(a),
        t.depthTexture && this.writeDepthTexture) {
            const l = t.depthTexture;
            this.renderer.texture.bind(l, 0),
            i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, e)
        }
        if ((t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture)) {
            r.stencil = r.stencil || i.createRenderbuffer();
            let l, h;
            this.renderer.context.webGLVersion === 1 ? (l = i.DEPTH_STENCIL_ATTACHMENT,
            h = i.DEPTH_STENCIL) : t.depth && t.stencil ? (l = i.DEPTH_STENCIL_ATTACHMENT,
            h = i.DEPTH24_STENCIL8) : t.depth ? (l = i.DEPTH_ATTACHMENT,
            h = i.DEPTH_COMPONENT24) : (l = i.STENCIL_ATTACHMENT,
            h = i.STENCIL_INDEX8),
            i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
            r.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, r.multisample, h, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, h, t.width, t.height),
            i.framebufferRenderbuffer(i.FRAMEBUFFER, l, i.RENDERBUFFER, r.stencil)
        } else
            r.stencil && (i.deleteRenderbuffer(r.stencil),
            r.stencil = null)
    }
    canMultisampleFramebuffer(t) {
        return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
    }
    detectSamples(t) {
        const {msaaSamples: e} = this;
        let i = ge.NONE;
        if (t <= 1 || e === null)
            return i;
        for (let r = 0; r < e.length; r++)
            if (e[r] <= t) {
                i = e[r];
                break
            }
        return i === 1 && (i = ge.NONE),
        i
    }
    blit(t, e, i) {
        const {current: r, renderer: n, gl: o, CONTEXT_UID: a} = this;
        if (n.context.webGLVersion !== 2 || !r)
            return;
        const l = r.glFramebuffers[a];
        if (!l)
            return;
        if (!t) {
            if (!l.msaaBuffer)
                return;
            const u = r.colorTextures[0];
            if (!u)
                return;
            l.blitFramebuffer || (l.blitFramebuffer = new rc(r.width,r.height),
            l.blitFramebuffer.addColorTexture(0, u)),
            t = l.blitFramebuffer,
            t.colorTextures[0] !== u && (t.colorTextures[0] = u,
            t.dirtyId++,
            t.dirtyFormat++),
            (t.width !== r.width || t.height !== r.height) && (t.width = r.width,
            t.height = r.height,
            t.dirtyId++,
            t.dirtySize++)
        }
        e || (e = QP,
        e.width = r.width,
        e.height = r.height),
        i || (i = e);
        const h = e.width === i.width && e.height === i.height;
        this.bind(t),
        o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer),
        o.blitFramebuffer(e.left, e.top, e.right, e.bottom, i.left, i.top, i.right, i.bottom, o.COLOR_BUFFER_BIT, h ? o.NEAREST : o.LINEAR),
        o.bindFramebuffer(o.READ_FRAMEBUFFER, t.glFramebuffers[this.CONTEXT_UID].framebuffer)
    }
    disposeFramebuffer(t, e) {
        const i = t.glFramebuffers[this.CONTEXT_UID]
          , r = this.gl;
        if (!i)
            return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const n = this.managedFramebuffers.indexOf(t);
        n >= 0 && this.managedFramebuffers.splice(n, 1),
        t.disposeRunner.remove(this),
        e || (r.deleteFramebuffer(i.framebuffer),
        i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
        i.stencil && r.deleteRenderbuffer(i.stencil)),
        i.blitFramebuffer && this.disposeFramebuffer(i.blitFramebuffer, e)
    }
    disposeAll(t) {
        const e = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let i = 0; i < e.length; i++)
            this.disposeFramebuffer(e[i], t)
    }
    forceStencil() {
        const t = this.current;
        if (!t)
            return;
        const e = t.glFramebuffers[this.CONTEXT_UID];
        if (!e || e.stencil && t.stencil)
            return;
        t.stencil = !0;
        const i = t.width
          , r = t.height
          , n = this.gl
          , o = e.stencil = n.createRenderbuffer();
        n.bindRenderbuffer(n.RENDERBUFFER, o);
        let a, l;
        this.renderer.context.webGLVersion === 1 ? (a = n.DEPTH_STENCIL_ATTACHMENT,
        l = n.DEPTH_STENCIL) : t.depth ? (a = n.DEPTH_STENCIL_ATTACHMENT,
        l = n.DEPTH24_STENCIL8) : (a = n.STENCIL_ATTACHMENT,
        l = n.STENCIL_INDEX8),
        e.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, e.multisample, l, i, r) : n.renderbufferStorage(n.RENDERBUFFER, l, i, r),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, a, n.RENDERBUFFER, o)
    }
    reset() {
        this.current = this.unknownFramebuffer,
        this.viewport = new St
    }
    destroy() {
        this.renderer = null
    }
}
Xm.extension = {
    type: it.RendererSystem,
    name: "framebuffer"
};
ct.add(Xm);
const Gd = {
    5126: 4,
    5123: 2,
    5121: 1
};
class Wm {
    constructor(t) {
        this.renderer = t,
        this._activeGeometry = null,
        this._activeVao = null,
        this.hasVao = !0,
        this.hasInstance = !0,
        this.canUseUInt32ElementIndex = !1,
        this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl
          , e = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        e.webGLVersion !== 2) {
            let i = this.renderer.context.extensions.vertexArrayObject;
            nt.PREFER_ENV === rn.WEBGL_LEGACY && (i = null),
            i ? (t.createVertexArray = ()=>i.createVertexArrayOES(),
            t.bindVertexArray = r=>i.bindVertexArrayOES(r),
            t.deleteVertexArray = r=>i.deleteVertexArrayOES(r)) : (this.hasVao = !1,
            t.createVertexArray = ()=>null,
            t.bindVertexArray = ()=>null,
            t.deleteVertexArray = ()=>null)
        }
        if (e.webGLVersion !== 2) {
            const i = t.getExtension("ANGLE_instanced_arrays");
            i ? (t.vertexAttribDivisor = (r,n)=>i.vertexAttribDivisorANGLE(r, n),
            t.drawElementsInstanced = (r,n,o,a,l)=>i.drawElementsInstancedANGLE(r, n, o, a, l),
            t.drawArraysInstanced = (r,n,o,a)=>i.drawArraysInstancedANGLE(r, n, o, a)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex
    }
    bind(t, e) {
        e = e || this.renderer.shader.shader;
        const {gl: i} = this;
        let r = t.glVertexArrayObjects[this.CONTEXT_UID]
          , n = !1;
        r || (this.managedGeometries[t.id] = t,
        t.disposeRunner.add(this),
        t.glVertexArrayObjects[this.CONTEXT_UID] = r = {},
        n = !0);
        const o = r[e.program.id] || this.initGeometryVao(t, e, n);
        this._activeGeometry = t,
        this._activeVao !== o && (this._activeVao = o,
        this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, e.program)),
        this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry
          , e = this.renderer.buffer;
        for (let i = 0; i < t.buffers.length; i++) {
            const r = t.buffers[i];
            e.update(r)
        }
    }
    checkCompatibility(t, e) {
        const i = t.attributes
          , r = e.attributeData;
        for (const n in r)
            if (!i[n])
                throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)
    }
    getSignature(t, e) {
        const i = t.attributes
          , r = e.attributeData
          , n = ["g", t.id];
        for (const o in i)
            r[o] && n.push(o, r[o].location);
        return n.join("-")
    }
    initGeometryVao(t, e, i=!0) {
        const r = this.gl
          , n = this.CONTEXT_UID
          , o = this.renderer.buffer
          , a = e.program;
        a.glPrograms[n] || this.renderer.shader.generateProgram(e),
        this.checkCompatibility(t, a);
        const l = this.getSignature(t, a)
          , h = t.glVertexArrayObjects[this.CONTEXT_UID];
        let u = h[l];
        if (u)
            return h[a.id] = u,
            u;
        const c = t.buffers
          , d = t.attributes
          , f = {}
          , p = {};
        for (const m in c)
            f[m] = 0,
            p[m] = 0;
        for (const m in d)
            !d[m].size && a.attributeData[m] ? d[m].size = a.attributeData[m].size : d[m].size || console.warn(`PIXI Geometry attribute '${m}' size cannot be determined (likely the bound shader does not have the attribute)`),
            f[d[m].buffer] += d[m].size * Gd[d[m].type];
        for (const m in d) {
            const g = d[m]
              , _ = g.size;
            g.stride === void 0 && (f[g.buffer] === _ * Gd[g.type] ? g.stride = 0 : g.stride = f[g.buffer]),
            g.start === void 0 && (g.start = p[g.buffer],
            p[g.buffer] += _ * Gd[g.type])
        }
        u = r.createVertexArray(),
        r.bindVertexArray(u);
        for (let m = 0; m < c.length; m++) {
            const g = c[m];
            o.bind(g),
            i && g._glBuffers[n].refCount++
        }
        return this.activateVao(t, a),
        h[a.id] = u,
        h[l] = u,
        r.bindVertexArray(null),
        o.unbind(Er.ARRAY_BUFFER),
        u
    }
    disposeGeometry(t, e) {
        if (!this.managedGeometries[t.id])
            return;
        delete this.managedGeometries[t.id];
        const i = t.glVertexArrayObjects[this.CONTEXT_UID]
          , r = this.gl
          , n = t.buffers
          , o = this.renderer?.buffer;
        if (t.disposeRunner.remove(this),
        !!i) {
            if (o)
                for (let a = 0; a < n.length; a++) {
                    const l = n[a]._glBuffers[this.CONTEXT_UID];
                    l && (l.refCount--,
                    l.refCount === 0 && !e && o.dispose(n[a], e))
                }
            if (!e) {
                for (const a in i)
                    if (a[0] === "g") {
                        const l = i[a];
                        this._activeVao === l && this.unbind(),
                        r.deleteVertexArray(l)
                    }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const e = Object.keys(this.managedGeometries);
        for (let i = 0; i < e.length; i++)
            this.disposeGeometry(this.managedGeometries[e[i]], t)
    }
    activateVao(t, e) {
        const i = this.gl
          , r = this.CONTEXT_UID
          , n = this.renderer.buffer
          , o = t.buffers
          , a = t.attributes;
        t.indexBuffer && n.bind(t.indexBuffer);
        let l = null;
        for (const h in a) {
            const u = a[h]
              , c = o[u.buffer]
              , d = c._glBuffers[r];
            if (e.attributeData[h]) {
                l !== d && (n.bind(c),
                l = d);
                const f = e.attributeData[h].location;
                if (i.enableVertexAttribArray(f),
                i.vertexAttribPointer(f, u.size, u.type || i.FLOAT, u.normalized, u.stride, u.start),
                u.instance)
                    if (this.hasInstance)
                        i.vertexAttribDivisor(f, u.divisor);
                    else
                        throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(t, e, i, r) {
        const {gl: n} = this
          , o = this._activeGeometry;
        if (o.indexBuffer) {
            const a = o.indexBuffer.data.BYTES_PER_ELEMENT
              , l = a === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
            a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? n.drawElementsInstanced(t, e || o.indexBuffer.data.length, l, (i || 0) * a, r || 1) : n.drawElements(t, e || o.indexBuffer.data.length, l, (i || 0) * a) : console.warn("unsupported index buffer type: uint32")
        } else
            o.instanced ? n.drawArraysInstanced(t, i, e || o.getSize(), r || 1) : n.drawArrays(t, i, e || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null),
        this._activeVao = null,
        this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
Wm.extension = {
    type: it.RendererSystem,
    name: "geometry"
};
ct.add(Wm);
const j_ = new Qt;
class Mc {
    constructor(t, e) {
        this._texture = t,
        this.mapCoord = new Qt,
        this.uClampFrame = new Float32Array(4),
        this.uClampOffset = new Float32Array(2),
        this._textureID = -1,
        this._updateID = 0,
        this.clampOffset = 0,
        this.clampMargin = typeof e > "u" ? .5 : e,
        this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture = t,
        this._textureID = -1
    }
    multiplyUvs(t, e) {
        e === void 0 && (e = t);
        const i = this.mapCoord;
        for (let r = 0; r < t.length; r += 2) {
            const n = t[r]
              , o = t[r + 1];
            e[r] = n * i.a + o * i.c + i.tx,
            e[r + 1] = n * i.b + o * i.d + i.ty
        }
        return e
    }
    update(t) {
        const e = this._texture;
        if (!e || !e.valid || !t && this._textureID === e._updateID)
            return !1;
        this._textureID = e._updateID,
        this._updateID++;
        const i = e._uvs;
        this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
        const r = e.orig
          , n = e.trim;
        n && (j_.set(r.width / n.width, 0, 0, r.height / n.height, -n.x / n.width, -n.y / n.height),
        this.mapCoord.append(j_));
        const o = e.baseTexture
          , a = this.uClampFrame
          , l = this.clampMargin / o.resolution
          , h = this.clampOffset;
        return a[0] = (e._frame.x + l + h) / o.width,
        a[1] = (e._frame.y + l + h) / o.height,
        a[2] = (e._frame.x + e._frame.width - l + h) / o.width,
        a[3] = (e._frame.y + e._frame.height - l + h) / o.height,
        this.uClampOffset[0] = h / o.realWidth,
        this.uClampOffset[1] = h / o.realHeight,
        this.isSimple = e._frame.width === o.width && e._frame.height === o.height && e.rotate === 0,
        !0
    }
}
var JP = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`
  , tI = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class P1 extends ti {
    constructor(t, e, i) {
        let r = null;
        typeof t != "string" && e === void 0 && i === void 0 && (r = t,
        t = void 0,
        e = void 0,
        i = void 0),
        super(t || tI, e || JP, i),
        this.maskSprite = r,
        this.maskMatrix = new Qt
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        this._maskSprite = t,
        this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(t, e, i, r) {
        const n = this._maskSprite
          , o = n._texture;
        o.valid && (o.uvMatrix || (o.uvMatrix = new Mc(o,0)),
        o.uvMatrix.update(),
        this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1,
        this.uniforms.mask = o,
        this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, n).prepend(o.uvMatrix.mapCoord),
        this.uniforms.alpha = n.worldAlpha,
        this.uniforms.maskClamp = o.uvMatrix.uClampFrame,
        t.applyFilter(this, e, i, r))
    }
}
class I1 {
    constructor(t=null) {
        this.type = ve.NONE,
        this.autoDetect = !0,
        this.maskObject = t || null,
        this.pooled = !1,
        this.isMaskData = !0,
        this.resolution = null,
        this.multisample = ti.defaultMultisample,
        this.enabled = !0,
        this.colorMask = 15,
        this._filters = null,
        this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null,
        this._scissorRectLocal = null,
        this._colorMask = 15,
        this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null,
        this.type = ve.NONE,
        this.autoDetect = !0),
        this._target = null,
        this._scissorRectLocal = null
    }
    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter,
        this._scissorCounter = t._scissorCounter,
        this._scissorRect = t._scissorRect) : (this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null)
    }
}
class jm {
    constructor(t) {
        this.renderer = t,
        this.enableScissor = !0,
        this.alphaMaskPool = [],
        this.maskDataPool = [],
        this.maskStack = [],
        this.alphaMaskIndex = 0
    }
    setMaskStack(t) {
        this.maskStack = t,
        this.renderer.scissor.setMaskStack(t),
        this.renderer.stencil.setMaskStack(t)
    }
    push(t, e) {
        let i = e;
        if (!i.isMaskData) {
            const n = this.maskDataPool.pop() || new I1;
            n.pooled = !0,
            n.maskObject = e,
            i = n
        }
        const r = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (i.copyCountersOrReset(r),
        i._colorMask = r ? r._colorMask : 15,
        i.autoDetect && this.detect(i),
        i._target = t,
        i.type !== ve.SPRITE && this.maskStack.push(i),
        i.enabled)
            switch (i.type) {
            case ve.SCISSOR:
                this.renderer.scissor.push(i);
                break;
            case ve.STENCIL:
                this.renderer.stencil.push(i);
                break;
            case ve.SPRITE:
                i.copyCountersOrReset(null),
                this.pushSpriteMask(i);
                break;
            case ve.COLOR:
                this.pushColorMask(i);
                break
            }
        i.type === ve.SPRITE && this.maskStack.push(i)
    }
    pop(t) {
        const e = this.maskStack.pop();
        if (!(!e || e._target !== t)) {
            if (e.enabled)
                switch (e.type) {
                case ve.SCISSOR:
                    this.renderer.scissor.pop(e);
                    break;
                case ve.STENCIL:
                    this.renderer.stencil.pop(e.maskObject);
                    break;
                case ve.SPRITE:
                    this.popSpriteMask(e);
                    break;
                case ve.COLOR:
                    this.popColorMask(e);
                    break
                }
            if (e.reset(),
            e.pooled && this.maskDataPool.push(e),
            this.maskStack.length !== 0) {
                const i = this.maskStack[this.maskStack.length - 1];
                i.type === ve.SPRITE && i._filters && (i._filters[0].maskSprite = i.maskObject)
            }
        }
    }
    detect(t) {
        const e = t.maskObject;
        e ? e.isSprite ? t.type = ve.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = ve.SCISSOR : t.type = ve.STENCIL : t.type = ve.COLOR
    }
    pushSpriteMask(t) {
        const {maskObject: e} = t
          , i = t._target;
        let r = t._filters;
        r || (r = this.alphaMaskPool[this.alphaMaskIndex],
        r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new P1])),
        r[0].resolution = t.resolution,
        r[0].multisample = t.multisample,
        r[0].maskSprite = e;
        const n = i.filterArea;
        i.filterArea = e.getBounds(!0),
        this.renderer.filter.push(i, r),
        i.filterArea = n,
        t._filters || this.alphaMaskIndex++
    }
    popSpriteMask(t) {
        this.renderer.filter.pop(),
        t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--,
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(t) {
        const e = t._colorMask
          , i = t._colorMask = e & t.colorMask;
        i !== e && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)
    }
    popColorMask(t) {
        const e = t._colorMask
          , i = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        i !== e && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)
    }
    destroy() {
        this.renderer = null
    }
}
jm.extension = {
    type: it.RendererSystem,
    name: "mask"
};
ct.add(jm);
class R1 {
    constructor(t) {
        this.renderer = t,
        this.maskStack = [],
        this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const {gl: e} = this.renderer
          , i = this.getStackLength();
        this.maskStack = t;
        const r = this.getStackLength();
        r !== i && (r === 0 ? e.disable(this.glConst) : (e.enable(this.glConst),
        this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        this.renderer = null,
        this.maskStack = null
    }
}
const q_ = new Qt
  , Y_ = []
  , M1 = class cu extends R1 {
    constructor(t) {
        super(t),
        this.glConst = nt.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._scissorCounter : 0
    }
    calcScissorRect(t) {
        if (t._scissorRectLocal)
            return;
        const e = t._scissorRect
          , {maskObject: i} = t
          , {renderer: r} = this
          , n = r.renderTexture
          , o = i.getBounds(!0, Y_.pop() ?? new St);
        this.roundFrameToPixels(o, n.current ? n.current.resolution : r.resolution, n.sourceFrame, n.destinationFrame, r.projection.transform),
        e && o.fit(e),
        t._scissorRectLocal = o
    }
    static isMatrixRotated(t) {
        if (!t)
            return !1;
        const {a: e, b: i, c: r, d: n} = t;
        return (Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(n) > 1e-4)
    }
    testScissor(t) {
        const {maskObject: e} = t;
        if (!e.isFastRect || !e.isFastRect() || cu.isMatrixRotated(e.worldTransform) || cu.isMatrixRotated(this.renderer.projection.transform))
            return !1;
        this.calcScissorRect(t);
        const i = t._scissorRectLocal;
        return i.width > 0 && i.height > 0
    }
    roundFrameToPixels(t, e, i, r, n) {
        cu.isMatrixRotated(n) || (n = n ? q_.copyFrom(n) : q_.identity(),
        n.translate(-i.x, -i.y).scale(r.width / i.width, r.height / i.height).translate(r.x, r.y),
        this.renderer.filter.transformAABB(n, t),
        t.fit(r),
        t.x = Math.round(t.x * e),
        t.y = Math.round(t.y * e),
        t.width = Math.round(t.width * e),
        t.height = Math.round(t.height * e))
    }
    push(t) {
        t._scissorRectLocal || this.calcScissorRect(t);
        const {gl: e} = this.renderer;
        t._scissorRect || e.enable(e.SCISSOR_TEST),
        t._scissorCounter++,
        t._scissorRect = t._scissorRectLocal,
        this._useCurrent()
    }
    pop(t) {
        const {gl: e} = this.renderer;
        t && Y_.push(t._scissorRectLocal),
        this.getStackLength() > 0 ? this._useCurrent() : e.disable(e.SCISSOR_TEST)
    }
    _useCurrent() {
        const t = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let e;
        this.renderer.renderTexture.current ? e = t.y : e = this.renderer.height - t.height - t.y,
        this.renderer.gl.scissor(t.x, e, t.width, t.height)
    }
}
;
M1.extension = {
    type: it.RendererSystem,
    name: "scissor"
};
let F1 = M1;
ct.add(F1);
class qm extends R1 {
    constructor(t) {
        super(t),
        this.glConst = nt.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const e = t.maskObject
          , {gl: i} = this.renderer
          , r = t._stencilCounter;
        r === 0 && (this.renderer.framebuffer.forceStencil(),
        i.clearStencil(0),
        i.clear(i.STENCIL_BUFFER_BIT),
        i.enable(i.STENCIL_TEST)),
        t._stencilCounter++;
        const n = t._colorMask;
        n !== 0 && (t._colorMask = 0,
        i.colorMask(!1, !1, !1, !1)),
        i.stencilFunc(i.EQUAL, r, 4294967295),
        i.stencilOp(i.KEEP, i.KEEP, i.INCR),
        e.renderable = !0,
        e.render(this.renderer),
        this.renderer.batch.flush(),
        e.renderable = !1,
        n !== 0 && (t._colorMask = n,
        i.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)),
        this._useCurrent()
    }
    pop(t) {
        const e = this.renderer.gl;
        if (this.getStackLength() === 0)
            e.disable(e.STENCIL_TEST);
        else {
            const i = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null
              , r = i ? i._colorMask : 15;
            r !== 0 && (i._colorMask = 0,
            e.colorMask(!1, !1, !1, !1)),
            e.stencilOp(e.KEEP, e.KEEP, e.DECR),
            t.renderable = !0,
            t.render(this.renderer),
            this.renderer.batch.flush(),
            t.renderable = !1,
            r !== 0 && (i._colorMask = r,
            e.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)),
            this._useCurrent()
        }
    }
    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
        t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}
qm.extension = {
    type: it.RendererSystem,
    name: "stencil"
};
ct.add(qm);
class Ym {
    constructor(t) {
        this.renderer = t,
        this.plugins = {},
        Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1,
                get() {
                    return Et("7.0.0", "renderer.plugins.extract has moved to renderer.extract"),
                    t.extract
                }
            },
            prepare: {
                enumerable: !1,
                get() {
                    return Et("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"),
                    t.prepare
                }
            },
            interaction: {
                enumerable: !1,
                get() {
                    return Et("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"),
                    t.events
                }
            }
        })
    }
    init() {
        const t = this.rendererPlugins;
        for (const e in t)
            this.plugins[e] = new t[e](this.renderer)
    }
    destroy() {
        for (const t in this.plugins)
            this.plugins[t].destroy(),
            this.plugins[t] = null
    }
}
Ym.extension = {
    type: [it.RendererSystem, it.CanvasRendererSystem],
    name: "_plugin"
};
ct.add(Ym);
class Km {
    constructor(t) {
        this.renderer = t,
        this.destinationFrame = null,
        this.sourceFrame = null,
        this.defaultFrame = null,
        this.projectionMatrix = new Qt,
        this.transform = null
    }
    update(t, e, i, r) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame,
        this.sourceFrame = e || this.sourceFrame || t,
        this.calculateProjection(this.destinationFrame, this.sourceFrame, i, r),
        this.transform && this.projectionMatrix.append(this.transform);
        const n = this.renderer;
        n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix,
        n.globalUniforms.update(),
        n.shader.shader && n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)
    }
    calculateProjection(t, e, i, r) {
        const n = this.projectionMatrix
          , o = r ? -1 : 1;
        n.identity(),
        n.a = 1 / e.width * 2,
        n.d = o * (1 / e.height * 2),
        n.tx = -1 - e.x * n.a,
        n.ty = -o - e.y * n.d
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
Km.extension = {
    type: it.RendererSystem,
    name: "projection"
};
ct.add(Km);
const eI = new Zl
  , K_ = new St;
class Zm {
    constructor(t) {
        this.renderer = t,
        this._tempMatrix = new Qt
    }
    generateTexture(t, e) {
        const {region: i, ...r} = e || {}
          , n = i?.copyTo(K_) || t.getLocalBounds(K_, !0)
          , o = r.resolution || this.renderer.resolution;
        n.width = Math.max(n.width, 1 / o),
        n.height = Math.max(n.height, 1 / o),
        r.width = n.width,
        r.height = n.height,
        r.resolution = o,
        r.multisample ?? (r.multisample = this.renderer.multisample);
        const a = nn.create(r);
        this._tempMatrix.tx = -n.x,
        this._tempMatrix.ty = -n.y;
        const l = t.transform;
        return t.transform = eI,
        this.renderer.render(t, {
            renderTexture: a,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }),
        t.transform = l,
        a
    }
    destroy() {}
}
Zm.extension = {
    type: [it.RendererSystem, it.CanvasRendererSystem],
    name: "textureGenerator"
};
ct.add(Zm);
const hn = new St
  , Ta = new St;
class Qm {
    constructor(t) {
        this.renderer = t,
        this.defaultMaskStack = [],
        this.current = null,
        this.sourceFrame = new St,
        this.destinationFrame = new St,
        this.viewportFrame = new St
    }
    contextChange() {
        const t = this.renderer?.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
    }
    bind(t=null, e, i) {
        const r = this.renderer;
        this.current = t;
        let n, o, a;
        t ? (n = t.baseTexture,
        a = n.resolution,
        e || (hn.width = t.frame.width,
        hn.height = t.frame.height,
        e = hn),
        i || (Ta.x = t.frame.x,
        Ta.y = t.frame.y,
        Ta.width = e.width,
        Ta.height = e.height,
        i = Ta),
        o = n.framebuffer) : (a = r.resolution,
        e || (hn.width = r._view.screen.width,
        hn.height = r._view.screen.height,
        e = hn),
        i || (i = hn,
        i.width = e.width,
        i.height = e.height));
        const l = this.viewportFrame;
        l.x = i.x * a,
        l.y = i.y * a,
        l.width = i.width * a,
        l.height = i.height * a,
        t || (l.y = r.view.height - (l.y + l.height)),
        l.ceil(),
        this.renderer.framebuffer.bind(o, l),
        this.renderer.projection.update(i, e, a, !o),
        t ? this.renderer.mask.setMaskStack(n.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
        this.sourceFrame.copyFrom(e),
        this.destinationFrame.copyFrom(i)
    }
    clear(t, e) {
        const i = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor
          , r = zt.shared.setValue(t || i);
        (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && r.premultiply(r.alpha);
        const n = this.destinationFrame
          , o = this.current ? this.current.baseTexture : this.renderer._view.screen
          , a = n.width !== o.width || n.height !== o.height;
        if (a) {
            let {x: l, y: h, width: u, height: c} = this.viewportFrame;
            l = Math.round(l),
            h = Math.round(h),
            u = Math.round(u),
            c = Math.round(c),
            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
            this.renderer.gl.scissor(l, h, u, c)
        }
        this.renderer.framebuffer.clear(r.red, r.green, r.blue, r.alpha, e),
        a && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
Qm.extension = {
    type: it.RendererSystem,
    name: "renderTexture"
};
ct.add(Qm);
class iI {
}
class B1 {
    constructor(t, e) {
        this.program = t,
        this.uniformData = e,
        this.uniformGroups = {},
        this.uniformDirtyGroups = {},
        this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null,
        this.uniformGroups = null,
        this.uniformDirtyGroups = null,
        this.uniformBufferBindings = null,
        this.program = null
    }
}
function rI(s, t) {
    const e = {}
      , i = t.getProgramParameter(s, t.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const n = t.getActiveAttrib(s, r);
        if (n.name.startsWith("gl_"))
            continue;
        const o = E1(t, n.type)
          , a = {
            type: o,
            name: n.name,
            size: w1(o),
            location: t.getAttribLocation(s, n.name)
        };
        e[n.name] = a
    }
    return e
}
function sI(s, t) {
    const e = {}
      , i = t.getProgramParameter(s, t.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; r++) {
        const n = t.getActiveUniform(s, r)
          , o = n.name.replace(/\[.*?\]$/, "")
          , a = !!n.name.match(/\[.*?\]$/)
          , l = E1(t, n.type);
        e[o] = {
            name: o,
            index: r,
            type: l,
            size: n.size,
            isArray: a,
            value: v1(l, n.size)
        }
    }
    return e
}
function O1(s, t) {
    const e = H_(s, s.VERTEX_SHADER, t.vertexSrc)
      , i = H_(s, s.FRAGMENT_SHADER, t.fragmentSrc)
      , r = s.createProgram();
    s.attachShader(r, e),
    s.attachShader(r, i);
    const n = t.extra?.transformFeedbackVaryings;
    if (n && (typeof s.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : s.transformFeedbackVaryings(r, n.names, n.bufferMode === "separate" ? s.SEPARATE_ATTRIBS : s.INTERLEAVED_ATTRIBS)),
    s.linkProgram(r),
    s.getProgramParameter(r, s.LINK_STATUS) || $P(s, r, e, i),
    t.attributeData = rI(r, s),
    t.uniformData = sI(r, s),
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
        const a = Object.keys(t.attributeData);
        a.sort((l,h)=>l > h ? 1 : -1);
        for (let l = 0; l < a.length; l++)
            t.attributeData[a[l]].location = l,
            s.bindAttribLocation(r, l, a[l]);
        s.linkProgram(r)
    }
    s.deleteShader(e),
    s.deleteShader(i);
    const o = {};
    for (const a in t.uniformData) {
        const l = t.uniformData[a];
        o[a] = {
            location: s.getUniformLocation(r, a),
            value: v1(l.type, l.size)
        }
    }
    return new B1(r,o)
}
function nI(s, t, e, i, r) {
    e.buffer.update(r)
}
const oI = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}
  , k1 = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
};
function L1(s) {
    const t = s.map(n=>({
        data: n,
        offset: 0,
        dataLen: 0,
        dirty: 0
    }));
    let e = 0
      , i = 0
      , r = 0;
    for (let n = 0; n < t.length; n++) {
        const o = t[n];
        if (e = k1[o.data.type],
        o.data.size > 1 && (e = Math.max(e, 16) * o.data.size),
        o.dataLen = e,
        i % e !== 0 && i < 16) {
            const a = i % e % 16;
            i += a,
            r += a
        }
        i + e > 16 ? (r = Math.ceil(r / 16) * 16,
        o.offset = r,
        r += e,
        i = e) : (o.offset = r,
        i += e,
        r += e)
    }
    return r = Math.ceil(r / 16) * 16,
    {
        uboElements: t,
        size: r
    }
}
function N1(s, t) {
    const e = [];
    for (const i in s)
        t[i] && e.push(t[i]);
    return e.sort((i,r)=>i.index - r.index),
    e
}
function U1(s, t) {
    if (!s.autoManage)
        return {
            size: 0,
            syncFunc: nI
        };
    const e = N1(s.uniforms, t)
      , {uboElements: i, size: r} = L1(e)
      , n = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < i.length; o++) {
        const a = i[o]
          , l = s.uniforms[a.data.name]
          , h = a.data.name;
        let u = !1;
        for (let c = 0; c < Un.length; c++) {
            const d = Un[c];
            if (d.codeUbo && d.test(a.data, l)) {
                n.push(`offset = ${a.offset / 4};`, Un[c].codeUbo(a.data.name, l)),
                u = !0;
                break
            }
        }
        if (!u)
            if (a.data.size > 1) {
                const c = w1(a.data.type)
                  , d = Math.max(k1[a.data.type] / 16, 1)
                  , f = c / d
                  , p = (4 - f % 4) % 4;
                n.push(`
                cv = ud.${h}.value;
                v = uv.${h};
                offset = ${a.offset / 4};

                t = 0;

                for(var i=0; i < ${a.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `)
            } else {
                const c = oI[a.data.type];
                n.push(`
                cv = ud.${h}.value;
                v = uv.${h};
                offset = ${a.offset / 4};
                ${c};
                `)
            }
    }
    return n.push(`
       renderer.buffer.update(buffer);
    `),
    {
        size: r,
        syncFunc: new Function("ud","uv","renderer","syncData","buffer",n.join(`
`))
    }
}
let aI = 0;
const Hh = {
    textureCount: 0,
    uboCount: 0
};
class Jm {
    constructor(t) {
        this.destroyed = !1,
        this.renderer = t,
        this.systemCheck(),
        this.gl = null,
        this.shader = null,
        this.program = null,
        this.cache = {},
        this._uboCache = {},
        this.id = aI++
    }
    systemCheck() {
        if (!T1())
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(t) {
        this.gl = t,
        this.reset()
    }
    bind(t, e) {
        t.disposeRunner.add(this),
        t.uniforms.globals = this.renderer.globalUniforms;
        const i = t.program
          , r = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t,
        this.program !== i && (this.program = i,
        this.gl.useProgram(r.program)),
        e || (Hh.textureCount = 0,
        Hh.uboCount = 0,
        this.syncUniformGroup(t.uniformGroup, Hh)),
        r
    }
    setUniforms(t) {
        const e = this.shader.program
          , i = e.glPrograms[this.renderer.CONTEXT_UID];
        e.syncUniforms(i.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, e) {
        const i = this.getGlProgram();
        (!t.static || t.dirtyId !== i.uniformDirtyGroups[t.id]) && (i.uniformDirtyGroups[t.id] = t.dirtyId,
        this.syncUniforms(t, i, e))
    }
    syncUniforms(t, e, i) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, i)
    }
    createSyncGroups(t) {
        const e = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[e] || (this.cache[e] = GP(t, this.shader.program.uniformData)),
        t.syncUniforms[this.shader.program.id] = this.cache[e],
        t.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(t, e) {
        const i = this.getGlProgram();
        if (!t.static || t.dirtyId !== 0 || !i.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const r = i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e);
            t.buffer.update(),
            r(i.uniformData, t.uniforms, this.renderer, Hh, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, i.uniformBufferBindings[e])
    }
    createSyncBufferGroup(t, e, i) {
        const {gl: r} = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const n = this.gl.getUniformBlockIndex(e.program, i);
        e.uniformBufferBindings[i] = this.shader.uniformBindCount,
        r.uniformBlockBinding(e.program, n, this.shader.uniformBindCount),
        this.shader.uniformBindCount++;
        const o = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let a = this._uboCache[o];
        if (a || (a = this._uboCache[o] = U1(t, this.shader.program.uniformData)),
        t.autoManage) {
            const l = new Float32Array(a.size / 4);
            t.buffer.update(l)
        }
        return e.uniformGroups[t.id] = a.syncFunc,
        e.uniformGroups[t.id]
    }
    getSignature(t, e, i) {
        const r = t.uniforms
          , n = [`${i}-`];
        for (const o in r)
            n.push(o),
            e[o] && n.push(e[o].type);
        return n.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(t) {
        const e = this.gl
          , i = t.program
          , r = O1(e, i);
        return i.glPrograms[this.renderer.CONTEXT_UID] = r,
        r
    }
    reset() {
        this.program = null,
        this.shader = null
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        this.renderer = null,
        this.destroyed = !0
    }
}
Jm.extension = {
    type: it.RendererSystem,
    name: "shader"
};
ct.add(Jm);
class kl {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const {renderer: e} = this;
        e.runners.init.emit(e.options),
        t.hello && console.log(`PixiJS 7.4.0 - ${e.rendererLogId} - https://pixijs.com`),
        e.resize(e.screen.width, e.screen.height)
    }
    destroy() {}
}
kl.defaultOptions = {
    hello: !1
},
kl.extension = {
    type: [it.RendererSystem, it.CanvasRendererSystem],
    name: "startup"
};
ct.add(kl);
function lI(s, t=[]) {
    return t[_t.NORMAL] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.ADD] = [s.ONE, s.ONE],
    t[_t.MULTIPLY] = [s.DST_COLOR, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.SCREEN] = [s.ONE, s.ONE_MINUS_SRC_COLOR, s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.OVERLAY] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.DARKEN] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.LIGHTEN] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.COLOR_DODGE] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.COLOR_BURN] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.HARD_LIGHT] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.SOFT_LIGHT] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.DIFFERENCE] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.EXCLUSION] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.HUE] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.SATURATION] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.COLOR] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.LUMINOSITY] = [s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.NONE] = [0, 0],
    t[_t.NORMAL_NPM] = [s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.ADD_NPM] = [s.SRC_ALPHA, s.ONE, s.ONE, s.ONE],
    t[_t.SCREEN_NPM] = [s.SRC_ALPHA, s.ONE_MINUS_SRC_COLOR, s.ONE, s.ONE_MINUS_SRC_ALPHA],
    t[_t.SRC_IN] = [s.DST_ALPHA, s.ZERO],
    t[_t.SRC_OUT] = [s.ONE_MINUS_DST_ALPHA, s.ZERO],
    t[_t.SRC_ATOP] = [s.DST_ALPHA, s.ONE_MINUS_SRC_ALPHA],
    t[_t.DST_OVER] = [s.ONE_MINUS_DST_ALPHA, s.ONE],
    t[_t.DST_IN] = [s.ZERO, s.SRC_ALPHA],
    t[_t.DST_OUT] = [s.ZERO, s.ONE_MINUS_SRC_ALPHA],
    t[_t.DST_ATOP] = [s.ONE_MINUS_DST_ALPHA, s.SRC_ALPHA],
    t[_t.XOR] = [s.ONE_MINUS_DST_ALPHA, s.ONE_MINUS_SRC_ALPHA],
    t[_t.SUBTRACT] = [s.ONE, s.ONE, s.ONE, s.ONE, s.FUNC_REVERSE_SUBTRACT, s.FUNC_ADD],
    t
}
const hI = 0
  , uI = 1
  , cI = 2
  , dI = 3
  , fI = 4
  , pI = 5
  , G1 = class fp {
    constructor() {
        this.gl = null,
        this.stateId = 0,
        this.polygonOffset = 0,
        this.blendMode = _t.NONE,
        this._blendEq = !1,
        this.map = [],
        this.map[hI] = this.setBlend,
        this.map[uI] = this.setOffset,
        this.map[cI] = this.setCullFace,
        this.map[dI] = this.setDepthTest,
        this.map[fI] = this.setFrontFace,
        this.map[pI] = this.setDepthMask,
        this.checks = [],
        this.defaultState = new Sr,
        this.defaultState.blend = !0
    }
    contextChange(t) {
        this.gl = t,
        this.blendModes = lI(t),
        this.set(this.defaultState),
        this.reset()
    }
    set(t) {
        if (t = t || this.defaultState,
        this.stateId !== t.data) {
            let e = this.stateId ^ t.data
              , i = 0;
            for (; e; )
                e & 1 && this.map[i].call(this, !!(t.data & 1 << i)),
                e = e >> 1,
                i++;
            this.stateId = t.data
        }
        for (let e = 0; e < this.checks.length; e++)
            this.checks[e](this, t)
    }
    forceState(t) {
        t = t || this.defaultState;
        for (let e = 0; e < this.map.length; e++)
            this.map[e].call(this, !!(t.data & 1 << e));
        for (let e = 0; e < this.checks.length; e++)
            this.checks[e](this, t);
        this.stateId = t.data
    }
    setBlend(t) {
        this.updateCheck(fp.checkBlendMode, t),
        this.gl[t ? "enable" : "disable"](this.gl.BLEND)
    }
    setOffset(t) {
        this.updateCheck(fp.checkPolygonOffset, t),
        this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
    }
    setDepthTest(t) {
        this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
    }
    setDepthMask(t) {
        this.gl.depthMask(t)
    }
    setCullFace(t) {
        this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
    }
    setFrontFace(t) {
        this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
    }
    setBlendMode(t) {
        if (t === this.blendMode)
            return;
        this.blendMode = t;
        const e = this.blendModes[t]
          , i = this.gl;
        e.length === 2 ? i.blendFunc(e[0], e[1]) : i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
        e.length === 6 ? (this._blendEq = !0,
        i.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1,
        i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD))
    }
    setPolygonOffset(t, e) {
        this.gl.polygonOffset(t, e)
    }
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
        this.forceState(this.defaultState),
        this._blendEq = !0,
        this.blendMode = -1,
        this.setBlendMode(0)
    }
    updateCheck(t, e) {
        const i = this.checks.indexOf(t);
        e && i === -1 ? this.checks.push(t) : !e && i !== -1 && this.checks.splice(i, 1)
    }
    static checkBlendMode(t, e) {
        t.setBlendMode(e.blendMode)
    }
    static checkPolygonOffset(t, e) {
        t.setPolygonOffset(1, e.polygonOffset)
    }
    destroy() {
        this.gl = null
    }
}
;
G1.extension = {
    type: it.RendererSystem,
    name: "state"
};
let H1 = G1;
ct.add(H1);
class $1 extends na {
    constructor() {
        super(...arguments),
        this.runners = {},
        this._systemsHash = {}
    }
    setup(t) {
        this.addRunners(...t.runners);
        const e = (t.priority ?? []).filter(r=>t.systems[r])
          , i = [...e, ...Object.keys(t.systems).filter(r=>!e.includes(r))];
        for (const r of i)
            this.addSystem(t.systems[r], r)
    }
    addRunners(...t) {
        t.forEach(e=>{
            this.runners[e] = new Vi(e)
        }
        )
    }
    addSystem(t, e) {
        const i = new t(this);
        if (this[e])
            throw new Error(`Whoops! The name "${e}" is already in use`);
        this[e] = i,
        this._systemsHash[e] = i;
        for (const r in this.runners)
            this.runners[r].add(i);
        return this
    }
    emitWithCustomOptions(t, e) {
        const i = Object.keys(this._systemsHash);
        t.items.forEach(r=>{
            const n = i.find(o=>this._systemsHash[o] === r);
            r[t.name](e[n])
        }
        )
    }
    destroy() {
        Object.values(this.runners).forEach(t=>{
            t.destroy()
        }
        ),
        this._systemsHash = {}
    }
}
const Na = class du {
    constructor(t) {
        this.renderer = t,
        this.count = 0,
        this.checkCount = 0,
        this.maxIdle = du.defaultMaxIdle,
        this.checkCountMax = du.defaultCheckCountMax,
        this.mode = du.defaultMode
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && (this.count++,
        this.mode !== Ac.MANUAL && (this.checkCount++,
        this.checkCount > this.checkCountMax && (this.checkCount = 0,
        this.run())))
    }
    run() {
        const t = this.renderer.texture
          , e = t.managedTextures;
        let i = !1;
        for (let r = 0; r < e.length; r++) {
            const n = e[r];
            n.resource && this.count - n.touched > this.maxIdle && (t.destroyTexture(n, !0),
            e[r] = null,
            i = !0)
        }
        if (i) {
            let r = 0;
            for (let n = 0; n < e.length; n++)
                e[n] !== null && (e[r++] = e[n]);
            e.length = r
        }
    }
    unload(t) {
        const e = this.renderer.texture
          , i = t._texture;
        i && !i.framebuffer && e.destroyTexture(i);
        for (let r = t.children.length - 1; r >= 0; r--)
            this.unload(t.children[r])
    }
    destroy() {
        this.renderer = null
    }
}
;
Na.defaultMode = Ac.AUTO,
Na.defaultMaxIdle = 60 * 60,
Na.defaultCheckCountMax = 60 * 10,
Na.extension = {
    type: it.RendererSystem,
    name: "textureGC"
};
let Ms = Na;
ct.add(Ms);
class fu {
    constructor(t) {
        this.texture = t,
        this.width = -1,
        this.height = -1,
        this.dirtyId = -1,
        this.dirtyStyleId = -1,
        this.mipmap = !1,
        this.wrapMode = 33071,
        this.type = ft.UNSIGNED_BYTE,
        this.internalFormat = J.RGBA,
        this.samplerType = 0
    }
}
function mI(s) {
    let t;
    return "WebGL2RenderingContext"in globalThis && s instanceof globalThis.WebGL2RenderingContext ? t = {
        [s.RGB]: rt.FLOAT,
        [s.RGBA]: rt.FLOAT,
        [s.ALPHA]: rt.FLOAT,
        [s.LUMINANCE]: rt.FLOAT,
        [s.LUMINANCE_ALPHA]: rt.FLOAT,
        [s.R8]: rt.FLOAT,
        [s.R8_SNORM]: rt.FLOAT,
        [s.RG8]: rt.FLOAT,
        [s.RG8_SNORM]: rt.FLOAT,
        [s.RGB8]: rt.FLOAT,
        [s.RGB8_SNORM]: rt.FLOAT,
        [s.RGB565]: rt.FLOAT,
        [s.RGBA4]: rt.FLOAT,
        [s.RGB5_A1]: rt.FLOAT,
        [s.RGBA8]: rt.FLOAT,
        [s.RGBA8_SNORM]: rt.FLOAT,
        [s.RGB10_A2]: rt.FLOAT,
        [s.RGB10_A2UI]: rt.FLOAT,
        [s.SRGB8]: rt.FLOAT,
        [s.SRGB8_ALPHA8]: rt.FLOAT,
        [s.R16F]: rt.FLOAT,
        [s.RG16F]: rt.FLOAT,
        [s.RGB16F]: rt.FLOAT,
        [s.RGBA16F]: rt.FLOAT,
        [s.R32F]: rt.FLOAT,
        [s.RG32F]: rt.FLOAT,
        [s.RGB32F]: rt.FLOAT,
        [s.RGBA32F]: rt.FLOAT,
        [s.R11F_G11F_B10F]: rt.FLOAT,
        [s.RGB9_E5]: rt.FLOAT,
        [s.R8I]: rt.INT,
        [s.R8UI]: rt.UINT,
        [s.R16I]: rt.INT,
        [s.R16UI]: rt.UINT,
        [s.R32I]: rt.INT,
        [s.R32UI]: rt.UINT,
        [s.RG8I]: rt.INT,
        [s.RG8UI]: rt.UINT,
        [s.RG16I]: rt.INT,
        [s.RG16UI]: rt.UINT,
        [s.RG32I]: rt.INT,
        [s.RG32UI]: rt.UINT,
        [s.RGB8I]: rt.INT,
        [s.RGB8UI]: rt.UINT,
        [s.RGB16I]: rt.INT,
        [s.RGB16UI]: rt.UINT,
        [s.RGB32I]: rt.INT,
        [s.RGB32UI]: rt.UINT,
        [s.RGBA8I]: rt.INT,
        [s.RGBA8UI]: rt.UINT,
        [s.RGBA16I]: rt.INT,
        [s.RGBA16UI]: rt.UINT,
        [s.RGBA32I]: rt.INT,
        [s.RGBA32UI]: rt.UINT,
        [s.DEPTH_COMPONENT16]: rt.FLOAT,
        [s.DEPTH_COMPONENT24]: rt.FLOAT,
        [s.DEPTH_COMPONENT32F]: rt.FLOAT,
        [s.DEPTH_STENCIL]: rt.FLOAT,
        [s.DEPTH24_STENCIL8]: rt.FLOAT,
        [s.DEPTH32F_STENCIL8]: rt.FLOAT
    } : t = {
        [s.RGB]: rt.FLOAT,
        [s.RGBA]: rt.FLOAT,
        [s.ALPHA]: rt.FLOAT,
        [s.LUMINANCE]: rt.FLOAT,
        [s.LUMINANCE_ALPHA]: rt.FLOAT,
        [s.DEPTH_STENCIL]: rt.FLOAT
    },
    t
}
function gI(s) {
    let t;
    return "WebGL2RenderingContext"in globalThis && s instanceof globalThis.WebGL2RenderingContext ? t = {
        [ft.UNSIGNED_BYTE]: {
            [J.RGBA]: s.RGBA8,
            [J.RGB]: s.RGB8,
            [J.RG]: s.RG8,
            [J.RED]: s.R8,
            [J.RGBA_INTEGER]: s.RGBA8UI,
            [J.RGB_INTEGER]: s.RGB8UI,
            [J.RG_INTEGER]: s.RG8UI,
            [J.RED_INTEGER]: s.R8UI,
            [J.ALPHA]: s.ALPHA,
            [J.LUMINANCE]: s.LUMINANCE,
            [J.LUMINANCE_ALPHA]: s.LUMINANCE_ALPHA
        },
        [ft.BYTE]: {
            [J.RGBA]: s.RGBA8_SNORM,
            [J.RGB]: s.RGB8_SNORM,
            [J.RG]: s.RG8_SNORM,
            [J.RED]: s.R8_SNORM,
            [J.RGBA_INTEGER]: s.RGBA8I,
            [J.RGB_INTEGER]: s.RGB8I,
            [J.RG_INTEGER]: s.RG8I,
            [J.RED_INTEGER]: s.R8I
        },
        [ft.UNSIGNED_SHORT]: {
            [J.RGBA_INTEGER]: s.RGBA16UI,
            [J.RGB_INTEGER]: s.RGB16UI,
            [J.RG_INTEGER]: s.RG16UI,
            [J.RED_INTEGER]: s.R16UI,
            [J.DEPTH_COMPONENT]: s.DEPTH_COMPONENT16
        },
        [ft.SHORT]: {
            [J.RGBA_INTEGER]: s.RGBA16I,
            [J.RGB_INTEGER]: s.RGB16I,
            [J.RG_INTEGER]: s.RG16I,
            [J.RED_INTEGER]: s.R16I
        },
        [ft.UNSIGNED_INT]: {
            [J.RGBA_INTEGER]: s.RGBA32UI,
            [J.RGB_INTEGER]: s.RGB32UI,
            [J.RG_INTEGER]: s.RG32UI,
            [J.RED_INTEGER]: s.R32UI,
            [J.DEPTH_COMPONENT]: s.DEPTH_COMPONENT24
        },
        [ft.INT]: {
            [J.RGBA_INTEGER]: s.RGBA32I,
            [J.RGB_INTEGER]: s.RGB32I,
            [J.RG_INTEGER]: s.RG32I,
            [J.RED_INTEGER]: s.R32I
        },
        [ft.FLOAT]: {
            [J.RGBA]: s.RGBA32F,
            [J.RGB]: s.RGB32F,
            [J.RG]: s.RG32F,
            [J.RED]: s.R32F,
            [J.DEPTH_COMPONENT]: s.DEPTH_COMPONENT32F
        },
        [ft.HALF_FLOAT]: {
            [J.RGBA]: s.RGBA16F,
            [J.RGB]: s.RGB16F,
            [J.RG]: s.RG16F,
            [J.RED]: s.R16F
        },
        [ft.UNSIGNED_SHORT_5_6_5]: {
            [J.RGB]: s.RGB565
        },
        [ft.UNSIGNED_SHORT_4_4_4_4]: {
            [J.RGBA]: s.RGBA4
        },
        [ft.UNSIGNED_SHORT_5_5_5_1]: {
            [J.RGBA]: s.RGB5_A1
        },
        [ft.UNSIGNED_INT_2_10_10_10_REV]: {
            [J.RGBA]: s.RGB10_A2,
            [J.RGBA_INTEGER]: s.RGB10_A2UI
        },
        [ft.UNSIGNED_INT_10F_11F_11F_REV]: {
            [J.RGB]: s.R11F_G11F_B10F
        },
        [ft.UNSIGNED_INT_5_9_9_9_REV]: {
            [J.RGB]: s.RGB9_E5
        },
        [ft.UNSIGNED_INT_24_8]: {
            [J.DEPTH_STENCIL]: s.DEPTH24_STENCIL8
        },
        [ft.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [J.DEPTH_STENCIL]: s.DEPTH32F_STENCIL8
        }
    } : t = {
        [ft.UNSIGNED_BYTE]: {
            [J.RGBA]: s.RGBA,
            [J.RGB]: s.RGB,
            [J.ALPHA]: s.ALPHA,
            [J.LUMINANCE]: s.LUMINANCE,
            [J.LUMINANCE_ALPHA]: s.LUMINANCE_ALPHA
        },
        [ft.UNSIGNED_SHORT_5_6_5]: {
            [J.RGB]: s.RGB
        },
        [ft.UNSIGNED_SHORT_4_4_4_4]: {
            [J.RGBA]: s.RGBA
        },
        [ft.UNSIGNED_SHORT_5_5_5_1]: {
            [J.RGBA]: s.RGBA
        }
    },
    t
}
class tg {
    constructor(t) {
        this.renderer = t,
        this.boundTextures = [],
        this.currentLocation = -1,
        this.managedTextures = [],
        this._unknownBoundTextures = !1,
        this.unknownTexture = new At,
        this.hasIntegerTextures = !1
    }
    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.webGLVersion = this.renderer.context.webGLVersion,
        this.internalFormats = gI(t),
        this.samplerTypes = mI(t);
        const e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = e;
        for (let r = 0; r < e; r++)
            this.boundTextures[r] = null;
        this.emptyTextures = {};
        const i = new fu(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, i.texture),
        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)),
        this.emptyTextures[t.TEXTURE_2D] = i,
        this.emptyTextures[t.TEXTURE_CUBE_MAP] = new fu(t.createTexture()),
        t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let r = 0; r < 6; r++)
            t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let r = 0; r < this.boundTextures.length; r++)
            this.bind(null, r)
    }
    bind(t, e=0) {
        const {gl: i} = this;
        if (t = t?.castToBaseTexture(),
        t?.valid && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e,
            i.activeTexture(i.TEXTURE0 + e)),
            i.bindTexture(t.target, r.texture)),
            r.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e,
            i.activeTexture(i.TEXTURE0 + e)),
            this.updateTexture(t)) : r.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t),
            this.boundTextures[e] = t
        } else
            this.currentLocation !== e && (this.currentLocation = e,
            i.activeTexture(i.TEXTURE0 + e)),
            i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture),
            this.boundTextures[e] = null
    }
    reset() {
        this._unknownBoundTextures = !0,
        this.hasIntegerTextures = !1,
        this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++)
            this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const {gl: e, boundTextures: i} = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let r = 0; r < i.length; r++)
                i[r] === this.unknownTexture && this.bind(null, r)
        }
        for (let r = 0; r < i.length; r++)
            i[r] === t && (this.currentLocation !== r && (e.activeTexture(e.TEXTURE0 + r),
            this.currentLocation = r),
            e.bindTexture(t.target, this.emptyTextures[t.target].texture),
            i[r] = null)
    }
    ensureSamplerType(t) {
        const {boundTextures: e, hasIntegerTextures: i, CONTEXT_UID: r} = this;
        if (i)
            for (let n = t - 1; n >= 0; --n) {
                const o = e[n];
                o && o._glTextures[r].samplerType !== rt.FLOAT && this.renderer.texture.unbind(o)
            }
    }
    initTexture(t) {
        const e = new fu(this.gl.createTexture());
        return e.dirtyId = -1,
        t._glTextures[this.CONTEXT_UID] = e,
        this.managedTextures.push(t),
        t.on("dispose", this.destroyTexture, this),
        e
    }
    initTextureType(t, e) {
        e.internalFormat = this.internalFormats[t.type]?.[t.format] ?? t.format,
        e.samplerType = this.samplerTypes[e.internalFormat] ?? rt.FLOAT,
        this.webGLVersion === 2 && t.type === ft.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
    }
    updateTexture(t) {
        const e = t._glTextures[this.CONTEXT_UID];
        if (!e)
            return;
        const i = this.renderer;
        if (this.initTextureType(t, e),
        t.resource?.upload(i, t, e))
            e.samplerType !== rt.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const r = t.realWidth
              , n = t.realHeight
              , o = i.gl;
            (e.width !== r || e.height !== n || e.dirtyId < 0) && (e.width = r,
            e.height = n,
            o.texImage2D(t.target, 0, e.internalFormat, r, n, 0, t.format, e.type, null))
        }
        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
        e.dirtyId = t.dirtyId
    }
    destroyTexture(t, e) {
        const {gl: i} = this;
        if (t = t.castToBaseTexture(),
        t._glTextures[this.CONTEXT_UID] && (this.unbind(t),
        i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
        t.off("dispose", this.destroyTexture, this),
        delete t._glTextures[this.CONTEXT_UID],
        !e)) {
            const r = this.managedTextures.indexOf(t);
            r !== -1 && Nn(this.managedTextures, r, 1)
        }
    }
    updateTextureStyle(t) {
        const e = t._glTextures[this.CONTEXT_UID];
        e && ((t.mipmap === Ar.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1,
        this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = Jr.CLAMP : e.wrapMode = t.wrapMode,
        t.resource?.style(this.renderer, t, e) || this.setStyle(t, e),
        e.dirtyStyleId = t.dirtyStyleId)
    }
    setStyle(t, e) {
        const i = this.gl;
        if (e.mipmap && t.mipmap !== Ar.ON_MANUAL && i.generateMipmap(t.target),
        i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode),
        i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode),
        e.mipmap) {
            i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Wr.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
            const r = this.renderer.context.extensions.anisotropicFiltering;
            if (r && t.anisotropicLevel > 0 && t.scaleMode === Wr.LINEAR) {
                const n = Math.min(t.anisotropicLevel, i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, n)
            }
        } else
            i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === Wr.LINEAR ? i.LINEAR : i.NEAREST);
        i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === Wr.LINEAR ? i.LINEAR : i.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
tg.extension = {
    type: it.RendererSystem,
    name: "texture"
};
ct.add(tg);
class eg {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: e, CONTEXT_UID: i} = this
          , r = t._glTransformFeedbacks[i] || this.createGLTransformFeedback(t);
        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, r)
    }
    unbind() {
        const {gl: t} = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, e) {
        const {gl: i, renderer: r} = this;
        e && r.shader.bind(e),
        i.beginTransformFeedback(t)
    }
    endTransformFeedback() {
        const {gl: t} = this;
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const {gl: e, renderer: i, CONTEXT_UID: r} = this
          , n = e.createTransformFeedback();
        t._glTransformFeedbacks[r] = n,
        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, n);
        for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            a && (i.buffer.update(a),
            a._glBuffers[r].refCount++,
            e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, o, a._glBuffers[r].buffer || null))
        }
        return e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null),
        t.disposeRunner.add(this),
        n
    }
    disposeTransformFeedback(t, e) {
        const i = t._glTransformFeedbacks[this.CONTEXT_UID]
          , r = this.gl;
        t.disposeRunner.remove(this);
        const n = this.renderer.buffer;
        if (n)
            for (let o = 0; o < t.buffers.length; o++) {
                const a = t.buffers[o];
                if (!a)
                    continue;
                const l = a._glBuffers[this.CONTEXT_UID];
                l && (l.refCount--,
                l.refCount === 0 && !e && n.dispose(a, e))
            }
        i && (e || r.deleteTransformFeedback(i),
        delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
eg.extension = {
    type: it.RendererSystem,
    name: "transformFeedback"
};
ct.add(eg);
class Ll {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        this.screen = new St(0,0,t.width,t.height),
        this.element = t.view || nt.ADAPTER.createCanvas(),
        this.resolution = t.resolution || nt.RESOLUTION,
        this.autoDensity = !!t.autoDensity
    }
    resizeView(t, e) {
        this.element.width = Math.round(t * this.resolution),
        this.element.height = Math.round(e * this.resolution);
        const i = this.element.width / this.resolution
          , r = this.element.height / this.resolution;
        this.screen.width = i,
        this.screen.height = r,
        this.autoDensity && (this.element.style.width = `${i}px`,
        this.element.style.height = `${r}px`),
        this.renderer.emit("resize", i, r),
        this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(t) {
        t && this.element.parentNode?.removeChild(this.element),
        this.renderer = null,
        this.element = null,
        this.screen = null
    }
}
Ll.defaultOptions = {
    width: 800,
    height: 600,
    resolution: void 0,
    autoDensity: !1
},
Ll.extension = {
    type: [it.RendererSystem, it.CanvasRendererSystem],
    name: "_view"
};
ct.add(Ll);
nt.PREFER_ENV = rn.WEBGL2;
nt.STRICT_TEXTURE_CACHE = !1;
nt.RENDER_OPTIONS = {
    ...Ol.defaultOptions,
    ...Bl.defaultOptions,
    ...Ll.defaultOptions,
    ...kl.defaultOptions
};
Object.defineProperties(nt, {
    WRAP_MODE: {
        get() {
            return At.defaultOptions.wrapMode
        },
        set(s) {
            Et("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),
            At.defaultOptions.wrapMode = s
        }
    },
    SCALE_MODE: {
        get() {
            return At.defaultOptions.scaleMode
        },
        set(s) {
            Et("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),
            At.defaultOptions.scaleMode = s
        }
    },
    MIPMAP_TEXTURES: {
        get() {
            return At.defaultOptions.mipmap
        },
        set(s) {
            Et("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),
            At.defaultOptions.mipmap = s
        }
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return At.defaultOptions.anisotropicLevel
        },
        set(s) {
            Et("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),
            At.defaultOptions.anisotropicLevel = s
        }
    },
    FILTER_RESOLUTION: {
        get() {
            return Et("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),
            ti.defaultResolution
        },
        set(s) {
            ti.defaultResolution = s
        }
    },
    FILTER_MULTISAMPLE: {
        get() {
            return Et("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),
            ti.defaultMultisample
        },
        set(s) {
            ti.defaultMultisample = s
        }
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return Rs.defaultMaxTextures
        },
        set(s) {
            Et("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),
            Rs.defaultMaxTextures = s
        }
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return Rs.defaultBatchSize
        },
        set(s) {
            Et("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),
            Rs.defaultBatchSize = s
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return Rs.canUploadSameBuffer
        },
        set(s) {
            Et("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),
            Rs.canUploadSameBuffer = s
        }
    },
    GC_MODE: {
        get() {
            return Ms.defaultMode
        },
        set(s) {
            Et("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),
            Ms.defaultMode = s
        }
    },
    GC_MAX_IDLE: {
        get() {
            return Ms.defaultMaxIdle
        },
        set(s) {
            Et("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),
            Ms.defaultMaxIdle = s
        }
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return Ms.defaultCheckCountMax
        },
        set(s) {
            Et("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),
            Ms.defaultCheckCountMax = s
        }
    },
    PRECISION_VERTEX: {
        get() {
            return qr.defaultVertexPrecision
        },
        set(s) {
            Et("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),
            qr.defaultVertexPrecision = s
        }
    },
    PRECISION_FRAGMENT: {
        get() {
            return qr.defaultFragmentPrecision
        },
        set(s) {
            Et("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),
            qr.defaultFragmentPrecision = s
        }
    }
});
var Es = (s=>(s[s.INTERACTION = 50] = "INTERACTION",
s[s.HIGH = 25] = "HIGH",
s[s.NORMAL = 0] = "NORMAL",
s[s.LOW = -25] = "LOW",
s[s.UTILITY = -50] = "UTILITY",
s))(Es || {});
class Hd {
    constructor(t, e=null, i=0, r=!1) {
        this.next = null,
        this.previous = null,
        this._destroyed = !1,
        this.fn = t,
        this.context = e,
        this.priority = i,
        this.once = r
    }
    match(t, e=null) {
        return this.fn === t && this.context === e
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const e = this.next;
        return this.once && this.destroy(!0),
        this._destroyed && (this.next = null),
        e
    }
    connect(t) {
        this.previous = t,
        t.next && (t.next.previous = this),
        this.next = t.next,
        t.next = this
    }
    destroy(t=!1) {
        this._destroyed = !0,
        this.fn = null,
        this.context = null,
        this.previous && (this.previous.next = this.next),
        this.next && (this.next.previous = this.previous);
        const e = this.next;
        return this.next = t ? null : e,
        this.previous = null,
        e
    }
}
const z1 = class Ri {
    constructor() {
        this.autoStart = !1,
        this.deltaTime = 1,
        this.lastTime = -1,
        this.speed = 1,
        this.started = !1,
        this._requestId = null,
        this._maxElapsedMS = 100,
        this._minElapsedMS = 0,
        this._protected = !1,
        this._lastFrame = -1,
        this._head = new Hd(null,null,1 / 0),
        this.deltaMS = 1 / Ri.targetFPMS,
        this.elapsedMS = 1 / Ri.targetFPMS,
        this._tick = t=>{
            this._requestId = null,
            this.started && (this.update(t),
            this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(),
        this._lastFrame = this.lastTime,
        this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId),
        this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(t, e, i=Es.NORMAL) {
        return this._addListener(new Hd(t,e,i))
    }
    addOnce(t, e, i=Es.NORMAL) {
        return this._addListener(new Hd(t,e,i,!0))
    }
    _addListener(t) {
        let e = this._head.next
          , i = this._head;
        if (!e)
            t.connect(i);
        else {
            for (; e; ) {
                if (t.priority > e.priority) {
                    t.connect(i);
                    break
                }
                i = e,
                e = e.next
            }
            t.previous || t.connect(i)
        }
        return this._startIfPossible(),
        this
    }
    remove(t, e) {
        let i = this._head.next;
        for (; i; )
            i.match(t, e) ? i = i.destroy() : i = i.next;
        return this._head.next || this._cancelIfNeeded(),
        this
    }
    get count() {
        if (!this._head)
            return 0;
        let t = 0
          , e = this._head;
        for (; e = e.next; )
            t++;
        return t
    }
    start() {
        this.started || (this.started = !0,
        this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1,
        this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let t = this._head.next;
            for (; t; )
                t = t.destroy(!0);
            this._head.destroy(),
            this._head = null
        }
    }
    update(t=performance.now()) {
        let e;
        if (t > this.lastTime) {
            if (e = this.elapsedMS = t - this.lastTime,
            e > this._maxElapsedMS && (e = this._maxElapsedMS),
            e *= this.speed,
            this._minElapsedMS) {
                const n = t - this._lastFrame | 0;
                if (n < this._minElapsedMS)
                    return;
                this._lastFrame = t - n % this._minElapsedMS
            }
            this.deltaMS = e,
            this.deltaTime = this.deltaMS * Ri.targetFPMS;
            const i = this._head;
            let r = i.next;
            for (; r; )
                r = r.emit(this.deltaTime);
            i.next || this._cancelIfNeeded()
        } else
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = t
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(t) {
        const e = Math.min(this.maxFPS, t)
          , i = Math.min(Math.max(0, e) / 1e3, Ri.targetFPMS);
        this._maxElapsedMS = 1 / i
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(t) {
        if (t === 0)
            this._minElapsedMS = 0;
        else {
            const e = Math.max(this.minFPS, t);
            this._minElapsedMS = 1 / (e / 1e3)
        }
    }
    static get shared() {
        if (!Ri._shared) {
            const t = Ri._shared = new Ri;
            t.autoStart = !0,
            t._protected = !0
        }
        return Ri._shared
    }
    static get system() {
        if (!Ri._system) {
            const t = Ri._system = new Ri;
            t.autoStart = !0,
            t._protected = !0
        }
        return Ri._system
    }
}
;
z1.targetFPMS = .06;
let Ue = z1;
Object.defineProperties(nt, {
    TARGET_FPMS: {
        get() {
            return Ue.targetFPMS
        },
        set(s) {
            Et("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
            Ue.targetFPMS = s
        }
    }
});
class ig {
    static init(t) {
        t = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, t),
        Object.defineProperty(this, "ticker", {
            set(e) {
                this._ticker && this._ticker.remove(this.render, this),
                this._ticker = e,
                e && e.add(this.render, this, Es.LOW)
            },
            get() {
                return this._ticker
            }
        }),
        this.stop = ()=>{
            this._ticker.stop()
        }
        ,
        this.start = ()=>{
            this._ticker.start()
        }
        ,
        this._ticker = null,
        this.ticker = t.sharedTicker ? Ue.shared : new Ue,
        t.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null,
            t.destroy()
        }
    }
}
ig.extension = it.Application;
ct.add(ig);
const V1 = [];
ct.handleByList(it.Renderer, V1);
function X1(s) {
    for (const t of V1)
        if (t.test(s))
            return new t(s);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
var _I = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`
  , yI = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const W1 = _I
  , rg = yI;
class sg {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let e;
        if (this.renderer.context.webGLVersion === 1) {
            const i = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            e = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.FRAMEBUFFER, i)
        } else {
            const i = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            e = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, i)
        }
        e >= ge.HIGH ? this.multisample = ge.HIGH : e >= ge.MEDIUM ? this.multisample = ge.MEDIUM : e >= ge.LOW ? this.multisample = ge.LOW : this.multisample = ge.NONE
    }
    destroy() {}
}
sg.extension = {
    type: it.RendererSystem,
    name: "_multisample"
};
ct.add(sg);
class vI {
    constructor(t) {
        this.buffer = t || null,
        this.updateID = -1,
        this.byteLength = -1,
        this.refCount = 0
    }
}
class ng {
    constructor(t) {
        this.renderer = t,
        this.managedBuffers = {},
        this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0),
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: e, CONTEXT_UID: i} = this
          , r = t._glBuffers[i] || this.createGLBuffer(t);
        e.bindBuffer(t.type, r.buffer)
    }
    unbind(t) {
        const {gl: e} = this;
        e.bindBuffer(t, null)
    }
    bindBufferBase(t, e) {
        const {gl: i, CONTEXT_UID: r} = this;
        if (this.boundBufferBases[e] !== t) {
            const n = t._glBuffers[r] || this.createGLBuffer(t);
            this.boundBufferBases[e] = t,
            i.bindBufferBase(i.UNIFORM_BUFFER, e, n.buffer)
        }
    }
    bindBufferRange(t, e, i) {
        const {gl: r, CONTEXT_UID: n} = this;
        i = i || 0;
        const o = t._glBuffers[n] || this.createGLBuffer(t);
        r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, o.buffer, i * 256, 256)
    }
    update(t) {
        const {gl: e, CONTEXT_UID: i} = this
          , r = t._glBuffers[i] || this.createGLBuffer(t);
        if (t._updateID !== r.updateID)
            if (r.updateID = t._updateID,
            e.bindBuffer(t.type, r.buffer),
            r.byteLength >= t.data.byteLength)
                e.bufferSubData(t.type, 0, t.data);
            else {
                const n = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
                r.byteLength = t.data.byteLength,
                e.bufferData(t.type, t.data, n)
            }
    }
    dispose(t, e) {
        if (!this.managedBuffers[t.id])
            return;
        delete this.managedBuffers[t.id];
        const i = t._glBuffers[this.CONTEXT_UID]
          , r = this.gl;
        t.disposeRunner.remove(this),
        i && (e || r.deleteBuffer(i.buffer),
        delete t._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(t) {
        const e = Object.keys(this.managedBuffers);
        for (let i = 0; i < e.length; i++)
            this.dispose(this.managedBuffers[e[i]], t)
    }
    createGLBuffer(t) {
        const {CONTEXT_UID: e, gl: i} = this;
        return t._glBuffers[e] = new vI(i.createBuffer()),
        this.managedBuffers[t.id] = t,
        t.disposeRunner.add(this),
        t._glBuffers[e]
    }
}
ng.extension = {
    type: it.RendererSystem,
    name: "buffer"
};
ct.add(ng);
class og {
    constructor(t) {
        this.renderer = t
    }
    render(t, e) {
        const i = this.renderer;
        let r, n, o, a;
        if (e && (r = e.renderTexture,
        n = e.clear,
        o = e.transform,
        a = e.skipUpdateTransform),
        this.renderingToScreen = !r,
        i.runners.prerender.emit(),
        i.emit("prerender"),
        i.projection.transform = o,
        !i.context.isLost) {
            if (r || (this.lastObjectRendered = t),
            !a) {
                const l = t.enableTempParent();
                t.updateTransform(),
                t.disableTempParent(l)
            }
            i.renderTexture.bind(r),
            i.batch.currentRenderer.start(),
            (n ?? i.background.clearBeforeRender) && i.renderTexture.clear(),
            t.render(i),
            i.batch.currentRenderer.flush(),
            r && (e.blit && i.framebuffer.blit(),
            r.baseTexture.update()),
            i.runners.postrender.emit(),
            i.projection.transform = null,
            i.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null,
        this.lastObjectRendered = null
    }
}
og.extension = {
    type: it.RendererSystem,
    name: "objectRenderer"
};
ct.add(og);
const pu = class pp extends $1 {
    constructor(t) {
        super(),
        this.type = Dm.WEBGL,
        t = Object.assign({}, nt.RENDER_OPTIONS, t),
        this.gl = null,
        this.CONTEXT_UID = 0,
        this.globalUniforms = new ar({
            projectionMatrix: new Qt
        },!0);
        const e = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: pp.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(e),
        "useContextAlpha"in t && (Et("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),
        t.premultipliedAlpha = t.useContextAlpha && t.useContextAlpha !== "notMultiplied",
        t.backgroundAlpha = t.useContextAlpha === !1 ? 1 : t.backgroundAlpha),
        this._plugin.rendererPlugins = pp.__plugins,
        this.options = t,
        this.startup.run(this.options)
    }
    static test(t) {
        return t?.forceCanvas ? !1 : r1()
    }
    render(t, e) {
        this.objectRenderer.render(t, e)
    }
    resize(t, e) {
        this._view.resizeView(t, e)
    }
    reset() {
        return this.runners.reset.emit(),
        this
    }
    clear() {
        this.renderTexture.bind(),
        this.renderTexture.clear()
    }
    destroy(t=!1) {
        this.runners.destroy.items.reverse(),
        this.emitWithCustomOptions(this.runners.destroy, {
            _view: t
        }),
        super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(t) {
        this._view.resolution = t,
        this.runners.resolutionChange.emit(t)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return Et("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),
        this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return Et("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),
        this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return Et("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),
        this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return Et("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color
    }
    set backgroundColor(t) {
        Et("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color = t
    }
    get backgroundAlpha() {
        return Et("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha
    }
    set backgroundAlpha(t) {
        Et("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha = t
    }
    get powerPreference() {
        return Et("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),
        this.context.powerPreference
    }
    generateTexture(t, e) {
        return this.textureGenerator.generateTexture(t, e)
    }
}
;
pu.extension = {
    type: it.Renderer,
    priority: 1
},
pu.__plugins = {},
pu.__systems = {};
let Fc = pu;
ct.handleByMap(it.RendererPlugin, Fc.__plugins);
ct.handleByMap(it.RendererSystem, Fc.__systems);
ct.add(Fc);
class ag extends ia {
    constructor(t, e) {
        const {width: i, height: r} = e || {};
        super(i, r),
        this.items = [],
        this.itemDirtyIds = [];
        for (let n = 0; n < t; n++) {
            const o = new At;
            this.items.push(o),
            this.itemDirtyIds.push(-2)
        }
        this.length = t,
        this._load = null,
        this.baseTexture = null
    }
    initFromArray(t, e) {
        for (let i = 0; i < this.length; i++)
            t[i] && (t[i].castToBaseTexture ? this.addBaseTextureAt(t[i].castToBaseTexture(), i) : t[i]instanceof ia ? this.addResourceAt(t[i], i) : this.addResourceAt(Lm(t[i], e), i))
    }
    dispose() {
        for (let t = 0, e = this.length; t < e; t++)
            this.items[t].destroy();
        this.items = null,
        this.itemDirtyIds = null,
        this._load = null
    }
    addResourceAt(t, e) {
        if (!this.items[e])
            throw new Error(`Index ${e} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height),
        this.items[e].setResource(t),
        this
    }
    bind(t) {
        if (this.baseTexture !== null)
            throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let e = 0; e < this.length; e++)
            this.items[e].parentTextureArray = t,
            this.items[e].on("update", t.update, t)
    }
    unbind(t) {
        super.unbind(t);
        for (let e = 0; e < this.length; e++)
            this.items[e].parentTextureArray = null,
            this.items[e].off("update", t.update, t)
    }
    load() {
        if (this._load)
            return this._load;
        const t = this.items.map(e=>e.resource).filter(e=>e).map(e=>e.load());
        return this._load = Promise.all(t).then(()=>{
            const {realWidth: e, realHeight: i} = this.items[0];
            return this.resize(e, i),
            this.update(),
            Promise.resolve(this)
        }
        ),
        this._load
    }
}
class j1 extends ag {
    constructor(t, e) {
        const {width: i, height: r} = e || {};
        let n, o;
        Array.isArray(t) ? (n = t,
        o = t.length) : o = t,
        super(o, {
            width: i,
            height: r
        }),
        n && this.initFromArray(n, e)
    }
    addBaseTextureAt(t, e) {
        if (t.resource)
            this.addResourceAt(t.resource, e);
        else
            throw new Error("ArrayResource does not support RenderTexture");
        return this
    }
    bind(t) {
        super.bind(t),
        t.target = On.TEXTURE_2D_ARRAY
    }
    upload(t, e, i) {
        const {length: r, itemDirtyIds: n, items: o} = this
          , {gl: a} = t;
        i.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, i.internalFormat, this._width, this._height, r, 0, e.format, i.type, null);
        for (let l = 0; l < r; l++) {
            const h = o[l];
            n[l] < h.dirtyId && (n[l] = h.dirtyId,
            h.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, h.resource.width, h.resource.height, 1, e.format, i.type, h.resource.source))
        }
        return !0
    }
}
class q1 extends rs {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const {OffscreenCanvas: e} = globalThis;
        return e && t instanceof e ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
const Y1 = class Ua extends ag {
    constructor(t, e) {
        const {width: i, height: r, autoLoad: n, linkBaseTexture: o} = e || {};
        if (t && t.length !== Ua.SIDES)
            throw new Error(`Invalid length. Got ${t.length}, expected 6`);
        super(6, {
            width: i,
            height: r
        });
        for (let a = 0; a < Ua.SIDES; a++)
            this.items[a].target = On.TEXTURE_CUBE_MAP_POSITIVE_X + a;
        this.linkBaseTexture = o !== !1,
        t && this.initFromArray(t, e),
        n !== !1 && this.load()
    }
    bind(t) {
        super.bind(t),
        t.target = On.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(t, e, i) {
        if (i === void 0 && (i = this.linkBaseTexture),
        !this.items[e])
            throw new Error(`Index ${e} is out of bounds`);
        if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0)
            if (t.resource)
                this.addResourceAt(t.resource, e);
            else
                throw new Error("CubeResource does not support copying of renderTexture.");
        else
            t.target = On.TEXTURE_CUBE_MAP_POSITIVE_X + e,
            t.parentTextureArray = this.baseTexture,
            this.items[e] = t;
        return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
        this.items[e] = t,
        this
    }
    upload(t, e, i) {
        const r = this.itemDirtyIds;
        for (let n = 0; n < Ua.SIDES; n++) {
            const o = this.items[n];
            (r[n] < o.dirtyId || i.dirtyId < e.dirtyId) && (o.valid && o.resource ? (o.resource.upload(t, o, i),
            r[n] = o.dirtyId) : r[n] < -1 && (t.gl.texImage2D(o.target, 0, i.internalFormat, e.realWidth, e.realHeight, 0, e.format, i.type, null),
            r[n] = -1))
        }
        return !0
    }
    static test(t) {
        return Array.isArray(t) && t.length === Ua.SIDES
    }
}
;
Y1.SIDES = 6;
let K1 = Y1;
class An extends rs {
    constructor(t, e) {
        e = e || {};
        let i, r, n;
        typeof t == "string" ? (i = An.EMPTY,
        r = t,
        n = !0) : (i = t,
        r = null,
        n = !1),
        super(i),
        this.url = r,
        this.crossOrigin = e.crossOrigin ?? !0,
        this.alphaMode = typeof e.alphaMode == "number" ? e.alphaMode : null,
        this.ownsImageBitmap = e.ownsImageBitmap ?? n,
        this._load = null,
        e.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(async(t,e)=>{
            if (this.url === null) {
                t(this);
                return
            }
            try {
                const i = await nt.ADAPTER.fetch(this.url, {
                    mode: this.crossOrigin ? "cors" : "no-cors"
                });
                if (this.destroyed)
                    return;
                const r = await i.blob();
                if (this.destroyed)
                    return;
                const n = await createImageBitmap(r, {
                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === _i.UNPACK ? "premultiply" : "none"
                });
                if (this.destroyed) {
                    n.close();
                    return
                }
                this.source = n,
                this.update(),
                t(this)
            } catch (i) {
                if (this.destroyed)
                    return;
                e(i),
                this.onError.emit(i)
            }
        }
        ),
        this._load)
    }
    upload(t, e, i) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (e.alphaMode = this.alphaMode),
        super.upload(t, e, i)) : (this.load(),
        !1)
    }
    dispose() {
        this.ownsImageBitmap && this.source instanceof ImageBitmap && this.source.close(),
        super.dispose(),
        this._load = null
    }
    static test(t) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof t == "string" || t instanceof ImageBitmap)
    }
    static get EMPTY() {
        return An._EMPTY = An._EMPTY ?? nt.ADAPTER.createCanvas(0, 0),
        An._EMPTY
    }
}
const mp = class mu extends rs {
    constructor(t, e) {
        e = e || {},
        super(nt.ADAPTER.createCanvas()),
        this._width = 0,
        this._height = 0,
        this.svg = t,
        this.scale = e.scale || 1,
        this._overrideWidth = e.width,
        this._overrideHeight = e.height,
        this._resolve = null,
        this._crossorigin = e.crossorigin,
        this._load = null,
        e.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(t=>{
            if (this._resolve = ()=>{
                this.update(),
                t(this)
            }
            ,
            mu.SVG_XML.test(this.svg.trim())) {
                if (!btoa)
                    throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }
        ),
        this._load)
    }
    _loadSvg() {
        const t = new Image;
        rs.crossOrigin(t, this.svg, this._crossorigin),
        t.src = this.svg,
        t.onerror = e=>{
            this._resolve && (t.onerror = null,
            this.onError.emit(e))
        }
        ,
        t.onload = ()=>{
            if (!this._resolve)
                return;
            const e = t.width
              , i = t.height;
            if (!e || !i)
                throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let r = e * this.scale
              , n = i * this.scale;
            (this._overrideWidth || this._overrideHeight) && (r = this._overrideWidth || this._overrideHeight / i * e,
            n = this._overrideHeight || this._overrideWidth / e * i),
            r = Math.round(r),
            n = Math.round(n);
            const o = this.source;
            o.width = r,
            o.height = n,
            o._pixiId = `canvas_${Js()}`,
            o.getContext("2d").drawImage(t, 0, 0, e, i, 0, 0, r, n),
            this._resolve(),
            this._resolve = null
        }
    }
    static getSize(t) {
        const e = mu.SVG_SIZE.exec(t)
          , i = {};
        return e && (i[e[1]] = Math.round(parseFloat(e[3])),
        i[e[5]] = Math.round(parseFloat(e[7]))),
        i
    }
    dispose() {
        super.dispose(),
        this._resolve = null,
        this._crossorigin = null
    }
    static test(t, e) {
        return e === "svg" || typeof t == "string" && t.startsWith("data:image/svg+xml") || typeof t == "string" && mu.SVG_XML.test(t)
    }
}
;
mp.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,
mp.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
let sc = mp;
class xI extends rs {
    constructor(t) {
        super(t)
    }
    static test(t) {
        return !!globalThis.VideoFrame && t instanceof globalThis.VideoFrame
    }
}
const gp = class _p extends rs {
    constructor(t, e) {
        if (e = e || {},
        !(t instanceof HTMLVideoElement)) {
            const i = document.createElement("video");
            e.autoLoad !== !1 && i.setAttribute("preload", "auto"),
            e.playsinline !== !1 && (i.setAttribute("webkit-playsinline", ""),
            i.setAttribute("playsinline", "")),
            e.muted === !0 && (i.setAttribute("muted", ""),
            i.muted = !0),
            e.loop === !0 && i.setAttribute("loop", ""),
            e.autoPlay !== !1 && i.setAttribute("autoplay", ""),
            typeof t == "string" && (t = [t]);
            const r = t[0].src || t[0];
            rs.crossOrigin(i, r, e.crossorigin);
            for (let n = 0; n < t.length; ++n) {
                const o = document.createElement("source");
                let {src: a, mime: l} = t[n];
                if (a = a || t[n],
                a.startsWith("data:"))
                    l = a.slice(5, a.indexOf(";"));
                else if (!a.startsWith("blob:")) {
                    const h = a.split("?").shift().toLowerCase()
                      , u = h.slice(h.lastIndexOf(".") + 1);
                    l = l || _p.MIME_TYPES[u] || `video/${u}`
                }
                o.src = a,
                l && (o.type = l),
                i.appendChild(o)
            }
            t = i
        }
        super(t),
        this.noSubImage = !0,
        this._autoUpdate = !0,
        this._isConnectedToTicker = !1,
        this._updateFPS = e.updateFPS || 0,
        this._msToNextUpdate = 0,
        this.autoPlay = e.autoPlay !== !1,
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this),
        this._videoFrameRequestCallbackHandle = null,
        this._load = null,
        this._resolve = null,
        this._reject = null,
        this._onCanPlay = this._onCanPlay.bind(this),
        this._onError = this._onError.bind(this),
        this._onPlayStart = this._onPlayStart.bind(this),
        this._onPlayStop = this._onPlayStop.bind(this),
        this._onSeeked = this._onSeeked.bind(this),
        e.autoLoad !== !1 && this.load()
    }
    update(t=0) {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const e = Ue.shared.elapsedMS * this.source.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
            }
            (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(),
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    _videoFrameRequestCallback() {
        this.update(),
        this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback)
    }
    load() {
        if (this._load)
            return this._load;
        const t = this.source;
        return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0),
        t.addEventListener("play", this._onPlayStart),
        t.addEventListener("pause", this._onPlayStop),
        t.addEventListener("seeked", this._onSeeked),
        this._isSourceReady() ? this._onCanPlay() : (t.addEventListener("canplay", this._onCanPlay),
        t.addEventListener("canplaythrough", this._onCanPlay),
        t.addEventListener("error", this._onError, !0)),
        this._load = new Promise((e,i)=>{
            this.valid ? e(this) : (this._resolve = e,
            this._reject = i,
            t.load())
        }
        ),
        this._load
    }
    _onError(t) {
        this.source.removeEventListener("error", this._onError, !0),
        this.onError.emit(t),
        this._reject && (this._reject(t),
        this._reject = null,
        this._resolve = null)
    }
    _isSourcePlaying() {
        const t = this.source;
        return !t.paused && !t.ended
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(),
        this._configureAutoUpdate()
    }
    _onPlayStop() {
        this._configureAutoUpdate()
    }
    _onSeeked() {
        this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0,
        this.update(),
        this._msToNextUpdate = 0)
    }
    _onCanPlay() {
        const t = this.source;
        t.removeEventListener("canplay", this._onCanPlay),
        t.removeEventListener("canplaythrough", this._onCanPlay);
        const e = this.valid;
        this._msToNextUpdate = 0,
        this.update(),
        this._msToNextUpdate = 0,
        !e && this._resolve && (this._resolve(this),
        this._resolve = null,
        this._reject = null),
        this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
    }
    dispose() {
        this._configureAutoUpdate();
        const t = this.source;
        t && (t.removeEventListener("play", this._onPlayStart),
        t.removeEventListener("pause", this._onPlayStop),
        t.removeEventListener("seeked", this._onSeeked),
        t.removeEventListener("canplay", this._onCanPlay),
        t.removeEventListener("canplaythrough", this._onCanPlay),
        t.removeEventListener("error", this._onError, !0),
        t.pause(),
        t.src = "",
        t.load()),
        super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
        this._configureAutoUpdate())
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(t) {
        t !== this._updateFPS && (this._updateFPS = t,
        this._configureAutoUpdate())
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ue.shared.remove(this.update, this),
        this._isConnectedToTicker = !1,
        this._msToNextUpdate = 0),
        this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
        this._videoFrameRequestCallbackHandle = null),
        this._isConnectedToTicker || (Ue.shared.add(this.update, this),
        this._isConnectedToTicker = !0,
        this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
        this._videoFrameRequestCallbackHandle = null),
        this._isConnectedToTicker && (Ue.shared.remove(this.update, this),
        this._isConnectedToTicker = !1,
        this._msToNextUpdate = 0))
    }
    static test(t, e) {
        return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || _p.TYPES.includes(e)
    }
}
;
gp.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"],
gp.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
let lg = gp;
tc.push(An, Hm, q1, lg, xI, sc, jl, K1, j1);
class bI {
    constructor() {
        this._glTransformFeedbacks = {},
        this.buffers = [],
        this.disposeRunner = new Vi("disposeTransformFeedback")
    }
    bindBuffer(t, e) {
        this.buffers[t] = e
    }
    destroy() {
        this.disposeRunner.emit(this, !1)
    }
}
const wI = "7.4.0";
class Nl {
    constructor() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0,
        this.rect = null,
        this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? St.EMPTY : (t = t || new St(0,0,1,1),
        t.x = this.minX,
        t.y = this.minY,
        t.width = this.maxX - this.minX,
        t.height = this.maxY - this.minY,
        t)
    }
    addPoint(t) {
        this.minX = Math.min(this.minX, t.x),
        this.maxX = Math.max(this.maxX, t.x),
        this.minY = Math.min(this.minY, t.y),
        this.maxY = Math.max(this.maxY, t.y)
    }
    addPointMatrix(t, e) {
        const {a: i, b: r, c: n, d: o, tx: a, ty: l} = t
          , h = i * e.x + n * e.y + a
          , u = r * e.x + o * e.y + l;
        this.minX = Math.min(this.minX, h),
        this.maxX = Math.max(this.maxX, h),
        this.minY = Math.min(this.minY, u),
        this.maxY = Math.max(this.maxY, u)
    }
    addQuad(t) {
        let e = this.minX
          , i = this.minY
          , r = this.maxX
          , n = this.maxY
          , o = t[0]
          , a = t[1];
        e = o < e ? o : e,
        i = a < i ? a : i,
        r = o > r ? o : r,
        n = a > n ? a : n,
        o = t[2],
        a = t[3],
        e = o < e ? o : e,
        i = a < i ? a : i,
        r = o > r ? o : r,
        n = a > n ? a : n,
        o = t[4],
        a = t[5],
        e = o < e ? o : e,
        i = a < i ? a : i,
        r = o > r ? o : r,
        n = a > n ? a : n,
        o = t[6],
        a = t[7],
        e = o < e ? o : e,
        i = a < i ? a : i,
        r = o > r ? o : r,
        n = a > n ? a : n,
        this.minX = e,
        this.minY = i,
        this.maxX = r,
        this.maxY = n
    }
    addFrame(t, e, i, r, n) {
        this.addFrameMatrix(t.worldTransform, e, i, r, n)
    }
    addFrameMatrix(t, e, i, r, n) {
        const o = t.a
          , a = t.b
          , l = t.c
          , h = t.d
          , u = t.tx
          , c = t.ty;
        let d = this.minX
          , f = this.minY
          , p = this.maxX
          , m = this.maxY
          , g = o * e + l * i + u
          , _ = a * e + h * i + c;
        d = g < d ? g : d,
        f = _ < f ? _ : f,
        p = g > p ? g : p,
        m = _ > m ? _ : m,
        g = o * r + l * i + u,
        _ = a * r + h * i + c,
        d = g < d ? g : d,
        f = _ < f ? _ : f,
        p = g > p ? g : p,
        m = _ > m ? _ : m,
        g = o * e + l * n + u,
        _ = a * e + h * n + c,
        d = g < d ? g : d,
        f = _ < f ? _ : f,
        p = g > p ? g : p,
        m = _ > m ? _ : m,
        g = o * r + l * n + u,
        _ = a * r + h * n + c,
        d = g < d ? g : d,
        f = _ < f ? _ : f,
        p = g > p ? g : p,
        m = _ > m ? _ : m,
        this.minX = d,
        this.minY = f,
        this.maxX = p,
        this.maxY = m
    }
    addVertexData(t, e, i) {
        let r = this.minX
          , n = this.minY
          , o = this.maxX
          , a = this.maxY;
        for (let l = e; l < i; l += 2) {
            const h = t[l]
              , u = t[l + 1];
            r = h < r ? h : r,
            n = u < n ? u : n,
            o = h > o ? h : o,
            a = u > a ? u : a
        }
        this.minX = r,
        this.minY = n,
        this.maxX = o,
        this.maxY = a
    }
    addVertices(t, e, i, r) {
        this.addVerticesMatrix(t.worldTransform, e, i, r)
    }
    addVerticesMatrix(t, e, i, r, n=0, o=n) {
        const a = t.a
          , l = t.b
          , h = t.c
          , u = t.d
          , c = t.tx
          , d = t.ty;
        let f = this.minX
          , p = this.minY
          , m = this.maxX
          , g = this.maxY;
        for (let _ = i; _ < r; _ += 2) {
            const x = e[_]
              , y = e[_ + 1]
              , v = a * x + h * y + c
              , E = u * y + l * x + d;
            f = Math.min(f, v - n),
            m = Math.max(m, v + n),
            p = Math.min(p, E - o),
            g = Math.max(g, E + o)
        }
        this.minX = f,
        this.minY = p,
        this.maxX = m,
        this.maxY = g
    }
    addBounds(t) {
        const e = this.minX
          , i = this.minY
          , r = this.maxX
          , n = this.maxY;
        this.minX = t.minX < e ? t.minX : e,
        this.minY = t.minY < i ? t.minY : i,
        this.maxX = t.maxX > r ? t.maxX : r,
        this.maxY = t.maxY > n ? t.maxY : n
    }
    addBoundsMask(t, e) {
        const i = t.minX > e.minX ? t.minX : e.minX
          , r = t.minY > e.minY ? t.minY : e.minY
          , n = t.maxX < e.maxX ? t.maxX : e.maxX
          , o = t.maxY < e.maxY ? t.maxY : e.maxY;
        if (i <= n && r <= o) {
            const a = this.minX
              , l = this.minY
              , h = this.maxX
              , u = this.maxY;
            this.minX = i < a ? i : a,
            this.minY = r < l ? r : l,
            this.maxX = n > h ? n : h,
            this.maxY = o > u ? o : u
        }
    }
    addBoundsMatrix(t, e) {
        this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, e) {
        const i = t.minX > e.x ? t.minX : e.x
          , r = t.minY > e.y ? t.minY : e.y
          , n = t.maxX < e.x + e.width ? t.maxX : e.x + e.width
          , o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
        if (i <= n && r <= o) {
            const a = this.minX
              , l = this.minY
              , h = this.maxX
              , u = this.maxY;
            this.minX = i < a ? i : a,
            this.minY = r < l ? r : l,
            this.maxX = n > h ? n : h,
            this.maxY = o > u ? o : u
        }
    }
    pad(t=0, e=t) {
        this.isEmpty() || (this.minX -= t,
        this.maxX += t,
        this.minY -= e,
        this.maxY += e)
    }
    addFramePad(t, e, i, r, n, o) {
        t -= n,
        e -= o,
        i += n,
        r += o,
        this.minX = this.minX < t ? this.minX : t,
        this.maxX = this.maxX > i ? this.maxX : i,
        this.minY = this.minY < e ? this.minY : e,
        this.maxY = this.maxY > r ? this.maxY : r
    }
}
class re extends na {
    constructor() {
        super(),
        this.tempDisplayObjectParent = null,
        this.transform = new Zl,
        this.alpha = 1,
        this.visible = !0,
        this.renderable = !0,
        this.cullable = !1,
        this.cullArea = null,
        this.parent = null,
        this.worldAlpha = 1,
        this._lastSortedIndex = 0,
        this._zIndex = 0,
        this.filterArea = null,
        this.filters = null,
        this._enabledFilters = null,
        this._bounds = new Nl,
        this._localBounds = null,
        this._boundsID = 0,
        this._boundsRect = null,
        this._localBoundsRect = null,
        this._mask = null,
        this._maskRefCount = 0,
        this._destroyed = !1,
        this.isSprite = !1,
        this.isMask = !1
    }
    static mixin(t) {
        const e = Object.keys(t);
        for (let i = 0; i < e.length; ++i) {
            const r = e[i];
            Object.defineProperty(re.prototype, r, Object.getOwnPropertyDescriptor(t, r))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(),
        this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(t, e) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(),
        this.updateTransform()) : (this.parent = this._tempDisplayObjectParent,
        this.updateTransform(),
        this.parent = null)),
        this._bounds.updateID !== this._boundsID && (this.calculateBounds(),
        this._bounds.updateID = this._boundsID),
        e || (this._boundsRect || (this._boundsRect = new St),
        e = this._boundsRect),
        this._bounds.getRectangle(e)
    }
    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new St),
        t = this._localBoundsRect),
        this._localBounds || (this._localBounds = new Nl);
        const e = this.transform
          , i = this.parent;
        this.parent = null,
        this._tempDisplayObjectParent.worldAlpha = i?.worldAlpha ?? 1,
        this.transform = this._tempDisplayObjectParent.transform;
        const r = this._bounds
          , n = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, t);
        return this.parent = i,
        this.transform = e,
        this._bounds = r,
        this._bounds.updateID += this._boundsID - n,
        o
    }
    toGlobal(t, e, i=!1) {
        return i || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.apply(t, e)
    }
    toLocal(t, e, i, r) {
        return e && (t = e.toGlobal(t, i, r)),
        r || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.applyInverse(t, i)
    }
    setParent(t) {
        if (!t || !t.addChild)
            throw new Error("setParent: Argument must be a Container");
        return t.addChild(this),
        t
    }
    removeFromParent() {
        this.parent?.removeChild(this)
    }
    setTransform(t=0, e=0, i=1, r=1, n=0, o=0, a=0, l=0, h=0) {
        return this.position.x = t,
        this.position.y = e,
        this.scale.x = i || 1,
        this.scale.y = r || 1,
        this.rotation = n,
        this.skew.x = o,
        this.skew.y = a,
        this.pivot.x = l,
        this.pivot.y = h,
        this
    }
    destroy(t) {
        this.removeFromParent(),
        this._destroyed = !0,
        this.transform = null,
        this.parent = null,
        this._bounds = null,
        this.mask = null,
        this.cullArea = null,
        this.filters = null,
        this.filterArea = null,
        this.hitArea = null,
        this.eventMode = "auto",
        this.interactiveChildren = !1,
        this.emit("destroyed"),
        this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new Z1),
        this.tempDisplayObjectParent
    }
    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent,
        t
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * g1
    }
    set angle(t) {
        this.transform.rotation = t * _1
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex !== t && (this._zIndex = t,
        this.parent && (this.parent.sortDirty = !0))
    }
    get worldVisible() {
        let t = this;
        do {
            if (!t.visible)
                return !1;
            t = t.parent
        } while (t);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                e && (e._maskRefCount--,
                e._maskRefCount === 0 && (e.renderable = !0,
                e.isMask = !1))
            }
            if (this._mask = t,
            this._mask) {
                const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                e && (e._maskRefCount === 0 && (e.renderable = !1,
                e.isMask = !0),
                e._maskRefCount++)
            }
        }
    }
}
class Z1 extends re {
    constructor() {
        super(...arguments),
        this.sortDirty = null
    }
}
re.prototype.displayObjectUpdateTransform = re.prototype.updateTransform;
const EI = new Qt;
function TI(s, t) {
    return s.zIndex === t.zIndex ? s._lastSortedIndex - t._lastSortedIndex : s.zIndex - t.zIndex
}
const Q1 = class yp extends re {
    constructor() {
        super(),
        this.children = [],
        this.sortableChildren = yp.defaultSortableChildren,
        this.sortDirty = !1
    }
    onChildrenChange(t) {}
    addChild(...t) {
        if (t.length > 1)
            for (let e = 0; e < t.length; e++)
                this.addChild(t[e]);
        else {
            const e = t[0];
            e.parent && e.parent.removeChild(e),
            e.parent = this,
            this.sortDirty = !0,
            e.transform._parentID = -1,
            this.children.push(e),
            this._boundsID++,
            this.onChildrenChange(this.children.length - 1),
            this.emit("childAdded", e, this, this.children.length - 1),
            e.emit("added", this)
        }
        return t[0]
    }
    addChildAt(t, e) {
        if (e < 0 || e > this.children.length)
            throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${this.children.length}`);
        return t.parent && t.parent.removeChild(t),
        t.parent = this,
        this.sortDirty = !0,
        t.transform._parentID = -1,
        this.children.splice(e, 0, t),
        this._boundsID++,
        this.onChildrenChange(e),
        t.emit("added", this),
        this.emit("childAdded", t, this, e),
        t
    }
    swapChildren(t, e) {
        if (t === e)
            return;
        const i = this.getChildIndex(t)
          , r = this.getChildIndex(e);
        this.children[i] = e,
        this.children[r] = t,
        this.onChildrenChange(i < r ? i : r)
    }
    getChildIndex(t) {
        const e = this.children.indexOf(t);
        if (e === -1)
            throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }
    setChildIndex(t, e) {
        if (e < 0 || e >= this.children.length)
            throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
        const i = this.getChildIndex(t);
        Nn(this.children, i, 1),
        this.children.splice(e, 0, t),
        this.onChildrenChange(e)
    }
    getChildAt(t) {
        if (t < 0 || t >= this.children.length)
            throw new Error(`getChildAt: Index (${t}) does not exist.`);
        return this.children[t]
    }
    removeChild(...t) {
        if (t.length > 1)
            for (let e = 0; e < t.length; e++)
                this.removeChild(t[e]);
        else {
            const e = t[0]
              , i = this.children.indexOf(e);
            if (i === -1)
                return null;
            e.parent = null,
            e.transform._parentID = -1,
            Nn(this.children, i, 1),
            this._boundsID++,
            this.onChildrenChange(i),
            e.emit("removed", this),
            this.emit("childRemoved", e, this, i)
        }
        return t[0]
    }
    removeChildAt(t) {
        const e = this.getChildAt(t);
        return e.parent = null,
        e.transform._parentID = -1,
        Nn(this.children, t, 1),
        this._boundsID++,
        this.onChildrenChange(t),
        e.emit("removed", this),
        this.emit("childRemoved", e, this, t),
        e
    }
    removeChildren(t=0, e=this.children.length) {
        const i = t
          , r = e
          , n = r - i;
        let o;
        if (n > 0 && n <= r) {
            o = this.children.splice(i, n);
            for (let a = 0; a < o.length; ++a)
                o[a].parent = null,
                o[a].transform && (o[a].transform._parentID = -1);
            this._boundsID++,
            this.onChildrenChange(t);
            for (let a = 0; a < o.length; ++a)
                o[a].emit("removed", this),
                this.emit("childRemoved", o[a], this, a);
            return o
        } else if (n === 0 && this.children.length === 0)
            return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let t = !1;
        for (let e = 0, i = this.children.length; e < i; ++e) {
            const r = this.children[e];
            r._lastSortedIndex = e,
            !t && r.zIndex !== 0 && (t = !0)
        }
        t && this.children.length > 1 && this.children.sort(TI),
        this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(),
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let t = 0, e = this.children.length; t < e; ++t) {
            const i = this.children[t];
            i.visible && i.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(),
        this._calculateBounds();
        for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t];
            if (!(!e.visible || !e.renderable))
                if (e.calculateBounds(),
                e._mask) {
                    const i = e._mask.isMaskData ? e._mask.maskObject : e._mask;
                    i ? (i.calculateBounds(),
                    this._bounds.addBoundsMask(e._bounds, i._bounds)) : this._bounds.addBounds(e._bounds)
                } else
                    e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(t, e=!1) {
        const i = super.getLocalBounds(t);
        if (!e)
            for (let r = 0, n = this.children.length; r < n; ++r) {
                const o = this.children[r];
                o.visible && o.updateTransform()
            }
        return i
    }
    _calculateBounds() {}
    _renderWithCulling(t) {
        const e = t.renderTexture.sourceFrame;
        if (!(e.width > 0 && e.height > 0))
            return;
        let i, r;
        this.cullArea ? (i = this.cullArea,
        r = this.worldTransform) : this._render !== yp.prototype._render && (i = this.getBounds(!0));
        const n = t.projection.transform;
        if (n && (r ? (r = EI.copyFrom(r),
        r.prepend(n)) : r = n),
        i && e.intersects(i, r))
            this._render(t);
        else if (this.cullArea)
            return;
        for (let o = 0, a = this.children.length; o < a; ++o) {
            const l = this.children[o]
              , h = l.cullable;
            l.cullable = h || !this.cullArea,
            l.render(t),
            l.cullable = h
        }
    }
    render(t) {
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || this.filters?.length)
                this.renderAdvanced(t);
            else if (this.cullable)
                this._renderWithCulling(t);
            else {
                this._render(t);
                for (let e = 0, i = this.children.length; e < i; ++e)
                    this.children[e].render(t)
            }
    }
    renderAdvanced(t) {
        const e = this.filters
          , i = this._mask;
        if (e) {
            this._enabledFilters || (this._enabledFilters = []),
            this._enabledFilters.length = 0;
            for (let n = 0; n < e.length; n++)
                e[n].enabled && this._enabledFilters.push(e[n])
        }
        const r = e && this._enabledFilters?.length || i && (!i.isMaskData || i.enabled && (i.autoDetect || i.type !== ve.NONE));
        if (r && t.batch.flush(),
        e && this._enabledFilters?.length && t.filter.push(this, this._enabledFilters),
        i && t.mask.push(this, this._mask),
        this.cullable)
            this._renderWithCulling(t);
        else {
            this._render(t);
            for (let n = 0, o = this.children.length; n < o; ++n)
                this.children[n].render(t)
        }
        r && t.batch.flush(),
        i && t.mask.pop(this),
        e && this._enabledFilters?.length && t.filter.pop()
    }
    _render(t) {}
    destroy(t) {
        super.destroy(),
        this.sortDirty = !1;
        const e = typeof t == "boolean" ? t : t?.children
          , i = this.removeChildren(0, this.children.length);
        if (e)
            for (let r = 0; r < i.length; ++r)
                i[r].destroy(t)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(t) {
        const e = this.getLocalBounds().width;
        e !== 0 ? this.scale.x = t / e : this.scale.x = 1,
        this._width = t
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(t) {
        const e = this.getLocalBounds().height;
        e !== 0 ? this.scale.y = t / e : this.scale.y = 1,
        this._height = t
    }
}
;
Q1.defaultSortableChildren = !1;
let Si = Q1;
Si.prototype.containerUpdateTransform = Si.prototype.updateTransform;
Object.defineProperties(nt, {
    SORTABLE_CHILDREN: {
        get() {
            return Si.defaultSortableChildren
        },
        set(s) {
            Et("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),
            Si.defaultSortableChildren = s
        }
    }
});
const Da = new Nt
  , DI = new Uint16Array([0, 1, 2, 0, 2, 3]);
class ae extends Si {
    constructor(t) {
        super(),
        this._anchor = new jr(this._onAnchorUpdate,this,t ? t.defaultAnchor.x : 0,t ? t.defaultAnchor.y : 0),
        this._texture = null,
        this._width = 0,
        this._height = 0,
        this._tintColor = new zt(16777215),
        this._tintRGB = null,
        this.tint = 16777215,
        this.blendMode = _t.NORMAL,
        this._cachedTint = 16777215,
        this.uvs = null,
        this.texture = t || st.EMPTY,
        this.vertexData = new Float32Array(8),
        this.vertexTrimmedData = null,
        this._transformID = -1,
        this._textureID = -1,
        this._transformTrimmedID = -1,
        this._textureTrimmedID = -1,
        this.indices = DI,
        this.pluginName = "batch",
        this.isSprite = !0,
        this._roundPixels = nt.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1,
        this._textureTrimmedID = -1,
        this._cachedTint = 16777215,
        this._width && (this.scale.x = gs(this.scale.x) * this._width / this._texture.orig.width),
        this._height && (this.scale.y = gs(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1,
        this._transformTrimmedID = -1
    }
    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID)
            return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32),
        this._transformID = this.transform._worldID,
        this._textureID = t._updateID;
        const e = this.transform.worldTransform
          , i = e.a
          , r = e.b
          , n = e.c
          , o = e.d
          , a = e.tx
          , l = e.ty
          , h = this.vertexData
          , u = t.trim
          , c = t.orig
          , d = this._anchor;
        let f = 0
          , p = 0
          , m = 0
          , g = 0;
        if (u ? (p = u.x - d._x * c.width,
        f = p + u.width,
        g = u.y - d._y * c.height,
        m = g + u.height) : (p = -d._x * c.width,
        f = p + c.width,
        g = -d._y * c.height,
        m = g + c.height),
        h[0] = i * p + n * g + a,
        h[1] = o * g + r * p + l,
        h[2] = i * f + n * g + a,
        h[3] = o * g + r * f + l,
        h[4] = i * f + n * m + a,
        h[5] = o * m + r * f + l,
        h[6] = i * p + n * m + a,
        h[7] = o * m + r * p + l,
        this._roundPixels) {
            const _ = nt.RESOLUTION;
            for (let x = 0; x < h.length; ++x)
                h[x] = Math.round(h[x] * _) / _
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData)
            this.vertexTrimmedData = new Float32Array(8);
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
            return;
        this._transformTrimmedID = this.transform._worldID,
        this._textureTrimmedID = this._texture._updateID;
        const t = this._texture
          , e = this.vertexTrimmedData
          , i = t.orig
          , r = this._anchor
          , n = this.transform.worldTransform
          , o = n.a
          , a = n.b
          , l = n.c
          , h = n.d
          , u = n.tx
          , c = n.ty
          , d = -r._x * i.width
          , f = d + i.width
          , p = -r._y * i.height
          , m = p + i.height;
        if (e[0] = o * d + l * p + u,
        e[1] = h * p + a * d + c,
        e[2] = o * f + l * p + u,
        e[3] = h * p + a * f + c,
        e[4] = o * f + l * m + u,
        e[5] = h * m + a * f + c,
        e[6] = o * d + l * m + u,
        e[7] = h * m + a * d + c,
        this._roundPixels) {
            const g = nt.RESOLUTION;
            for (let _ = 0; _ < e.length; ++_)
                e[_] = Math.round(e[_] * g) / g
        }
    }
    _render(t) {
        this.calculateVertices(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const t = this._texture.trim
          , e = this._texture.orig;
        !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(),
        this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Nl),
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x,
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y,
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x),
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new St),
        t = this._localBoundsRect),
        this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, Da);
        const e = this._texture.orig.width
          , i = this._texture.orig.height
          , r = -e * this.anchor.x;
        let n = 0;
        return Da.x >= r && Da.x < r + e && (n = -i * this.anchor.y,
        Da.y >= n && Da.y < n + i)
    }
    destroy(t) {
        if (super.destroy(t),
        this._texture.off("update", this._onTextureUpdate, this),
        this._anchor = null,
        typeof t == "boolean" ? t : t?.texture) {
            const e = typeof t == "boolean" ? t : t?.baseTexture;
            this._texture.destroy(!!e)
        }
        this._texture = null
    }
    static from(t, e) {
        const i = t instanceof st ? t : st.from(t, e);
        return new ae(i)
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1,
        this._transformTrimmedID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const e = gs(this.scale.x) || 1;
        this.scale.x = e * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const e = gs(this.scale.y) || 1;
        this.scale.y = e * t / this._texture.orig.height,
        this._height = t
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t),
        this._tintRGB = this._tintColor.toLittleEndianNumber()
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this),
        this._texture = t || st.EMPTY,
        this._cachedTint = 16777215,
        this._textureID = -1,
        this._textureTrimmedID = -1,
        t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}
const J1 = new Qt;
re.prototype._cacheAsBitmap = !1;
re.prototype._cacheData = null;
re.prototype._cacheAsBitmapResolution = null;
re.prototype._cacheAsBitmapMultisample = null;
class AI {
    constructor() {
        this.textureCacheId = null,
        this.originalRender = null,
        this.originalRenderCanvas = null,
        this.originalCalculateBounds = null,
        this.originalGetLocalBounds = null,
        this.originalUpdateTransform = null,
        this.originalDestroy = null,
        this.originalMask = null,
        this.originalFilterArea = null,
        this.originalContainsPoint = null,
        this.sprite = null
    }
}
Object.defineProperties(re.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(s) {
            s !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = s,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(s) {
            s !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = s,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(s) {
            if (this._cacheAsBitmap === s)
                return;
            this._cacheAsBitmap = s;
            let t;
            s ? (this._cacheData || (this._cacheData = new AI),
            t = this._cacheData,
            t.originalRender = this.render,
            t.originalRenderCanvas = this.renderCanvas,
            t.originalUpdateTransform = this.updateTransform,
            t.originalCalculateBounds = this.calculateBounds,
            t.originalGetLocalBounds = this.getLocalBounds,
            t.originalDestroy = this.destroy,
            t.originalContainsPoint = this.containsPoint,
            t.originalMask = this._mask,
            t.originalFilterArea = this.filterArea,
            this.render = this._renderCached,
            this.renderCanvas = this._renderCachedCanvas,
            this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData,
            t.sprite && this._destroyCachedDisplayObject(),
            this.render = t.originalRender,
            this.renderCanvas = t.originalRenderCanvas,
            this.calculateBounds = t.originalCalculateBounds,
            this.getLocalBounds = t.originalGetLocalBounds,
            this.destroy = t.originalDestroy,
            this.updateTransform = t.originalUpdateTransform,
            this.containsPoint = t.originalContainsPoint,
            this._mask = t.originalMask,
            this.filterArea = t.originalFilterArea)
        }
    }
});
re.prototype._renderCached = function(s) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(s),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._render(s))
}
;
re.prototype._initCachedDisplayObject = function(s) {
    if (this._cacheData?.sprite)
        return;
    const t = this.alpha;
    this.alpha = 1,
    s.batch.flush();
    const e = this.getLocalBounds(new St, !0);
    if (this.filters?.length) {
        const d = this.filters[0].padding;
        e.pad(d)
    }
    const i = this.cacheAsBitmapResolution || s.resolution;
    e.ceil(i),
    e.width = Math.max(e.width, 1 / i),
    e.height = Math.max(e.height, 1 / i);
    const r = s.renderTexture.current
      , n = s.renderTexture.sourceFrame.clone()
      , o = s.renderTexture.destinationFrame.clone()
      , a = s.projection.transform
      , l = nn.create({
        width: e.width,
        height: e.height,
        resolution: i,
        multisample: this.cacheAsBitmapMultisample ?? s.multisample
    })
      , h = `cacheAsBitmap_${Js()}`;
    this._cacheData.textureCacheId = h,
    At.addToCache(l.baseTexture, h),
    st.addToCache(l, h);
    const u = this.transform.localTransform.copyTo(J1).invert().translate(-e.x, -e.y);
    this.render = this._cacheData.originalRender,
    s.render(this, {
        renderTexture: l,
        clear: !0,
        transform: u,
        skipUpdateTransform: !1
    }),
    s.framebuffer.blit(),
    s.projection.transform = a,
    s.renderTexture.bind(r, n, o),
    this.render = this._renderCached,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = t;
    const c = new ae(l);
    c.transform.worldTransform = this.transform.worldTransform,
    c.anchor.x = -(e.x / e.width),
    c.anchor.y = -(e.y / e.height),
    c.alpha = t,
    c._bounds = this._bounds,
    this._cacheData.sprite = c,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.enableTempParent(),
    this.updateTransform(),
    this.disableTempParent(null)),
    this.containsPoint = c.containsPoint.bind(c)
}
;
re.prototype._renderCachedCanvas = function(s) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(s),
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._renderCanvas(s))
}
;
re.prototype._initCachedDisplayObjectCanvas = function(s) {
    if (this._cacheData?.sprite)
        return;
    const t = this.getLocalBounds(new St, !0)
      , e = this.alpha;
    this.alpha = 1;
    const i = s.canvasContext.activeContext
      , r = s._projTransform
      , n = this.cacheAsBitmapResolution || s.resolution;
    t.ceil(n),
    t.width = Math.max(t.width, 1 / n),
    t.height = Math.max(t.height, 1 / n);
    const o = nn.create({
        width: t.width,
        height: t.height,
        resolution: n
    })
      , a = `cacheAsBitmap_${Js()}`;
    this._cacheData.textureCacheId = a,
    At.addToCache(o.baseTexture, a),
    st.addToCache(o, a);
    const l = J1;
    this.transform.localTransform.copyTo(l),
    l.invert(),
    l.tx -= t.x,
    l.ty -= t.y,
    this.renderCanvas = this._cacheData.originalRenderCanvas,
    s.render(this, {
        renderTexture: o,
        clear: !0,
        transform: l,
        skipUpdateTransform: !1
    }),
    s.canvasContext.activeContext = i,
    s._projTransform = r,
    this.renderCanvas = this._renderCachedCanvas,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = e;
    const h = new ae(o);
    h.transform.worldTransform = this.transform.worldTransform,
    h.anchor.x = -(t.x / t.width),
    h.anchor.y = -(t.y / t.height),
    h.alpha = e,
    h._bounds = this._bounds,
    this._cacheData.sprite = h,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.parent = s._tempDisplayObjectParent,
    this.updateTransform(),
    this.parent = null),
    this.containsPoint = h.containsPoint.bind(h)
}
;
re.prototype._calculateCachedBounds = function() {
    this._bounds.clear(),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite._calculateBounds(),
    this._bounds.updateID = this._boundsID
}
;
re.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null)
}
;
re.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0),
    this._cacheData.sprite = null,
    At.removeFromCache(this._cacheData.textureCacheId),
    st.removeFromCache(this._cacheData.textureCacheId),
    this._cacheData.textureCacheId = null
}
;
re.prototype._cacheAsBitmapDestroy = function(s) {
    this.cacheAsBitmap = !1,
    this.destroy(s)
}
;
re.prototype.name = null;
Si.prototype.getChildByName = function(s, t) {
    for (let e = 0, i = this.children.length; e < i; e++)
        if (this.children[e].name === s)
            return this.children[e];
    if (t)
        for (let e = 0, i = this.children.length; e < i; e++) {
            const r = this.children[e];
            if (!r.getChildByName)
                continue;
            const n = r.getChildByName(s, !0);
            if (n)
                return n
        }
    return null
}
;
re.prototype.getGlobalPosition = function(s=new Nt, t=!1) {
    return this.parent ? this.parent.toGlobal(this.position, s, t) : (s.x = this.position.x,
    s.y = this.position.y),
    s
}
;
var SI = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class tb extends ti {
    constructor(t=1) {
        super(W1, SI, {
            uAlpha: 1
        }),
        this.alpha = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
const CI = {
    5: [.153388, .221461, .250301],
    7: [.071303, .131514, .189879, .214607],
    9: [.028532, .067234, .124009, .179044, .20236],
    11: [.0093, .028002, .065984, .121703, .175713, .198596],
    13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
    15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
}
  , PI = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
function II(s) {
    const t = CI[s]
      , e = t.length;
    let i = PI
      , r = "";
    const n = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < s; a++) {
        let l = n.replace("%index%", a.toString());
        o = a,
        a >= e && (o = s - a - 1),
        l = l.replace("%value%", t[o].toString()),
        r += l,
        r += `
`
    }
    return i = i.replace("%blur%", r),
    i = i.replace("%size%", s.toString()),
    i
}
const RI = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function MI(s, t) {
    const e = Math.ceil(s / 2);
    let i = RI, r = "", n;
    t ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < s; o++) {
        let a = n.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o - (e - 1)}.0`),
        r += a,
        r += `
`
    }
    return i = i.replace("%blur%", r),
    i = i.replace("%size%", s.toString()),
    i
}
class nc extends ti {
    constructor(t, e=8, i=4, r=ti.defaultResolution, n=5) {
        const o = MI(n, t)
          , a = II(n);
        super(o, a),
        this.horizontal = t,
        this.resolution = r,
        this._quality = 0,
        this.quality = i,
        this.blur = e
    }
    apply(t, e, i, r) {
        if (i ? this.horizontal ? this.uniforms.strength = 1 / i.width * (i.width / e.width) : this.uniforms.strength = 1 / i.height * (i.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height),
        this.uniforms.strength *= this.strength,
        this.uniforms.strength /= this.passes,
        this.passes === 1)
            t.applyFilter(this, e, i, r);
        else {
            const n = t.getFilterTexture()
              , o = t.renderer;
            let a = e
              , l = n;
            this.state.blend = !1,
            t.applyFilter(this, a, l, yr.CLEAR);
            for (let h = 1; h < this.passes - 1; h++) {
                t.bindAndClear(a, yr.BLIT),
                this.uniforms.uSampler = l;
                const u = l;
                l = a,
                a = u,
                o.shader.bind(this),
                o.geometry.draw(5)
            }
            this.state.blend = !0,
            t.applyFilter(this, l, i, r),
            t.returnFilterTexture(n)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        this.padding = 1 + Math.abs(t) * 2,
        this.strength = t
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        this._quality = t,
        this.passes = t
    }
}
class eb extends ti {
    constructor(t=8, e=4, i=ti.defaultResolution, r=5) {
        super(),
        this._repeatEdgePixels = !1,
        this.blurXFilter = new nc(!0,t,e,i,r),
        this.blurYFilter = new nc(!1,t,e,i,r),
        this.resolution = i,
        this.quality = e,
        this.blur = t,
        this.repeatEdgePixels = !1
    }
    apply(t, e, i, r) {
        const n = Math.abs(this.blurXFilter.strength)
          , o = Math.abs(this.blurYFilter.strength);
        if (n && o) {
            const a = t.getFilterTexture();
            this.blurXFilter.apply(t, e, a, yr.CLEAR),
            this.blurYFilter.apply(t, a, i, r),
            t.returnFilterTexture(a)
        } else
            o ? this.blurYFilter.apply(t, e, i, r) : this.blurXFilter.apply(t, e, i, r)
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(t) {
        this.blurXFilter.blur = this.blurYFilter.blur = t,
        this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(t) {
        this.blurXFilter.blur = t,
        this.updatePadding()
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(t) {
        this.blurYFilter.blur = t,
        this.updatePadding()
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(t) {
        this._repeatEdgePixels = t,
        this.updatePadding()
    }
}
var FI = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class oc extends ti {
    constructor() {
        const t = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(rg, FI, t),
        this.alpha = 1
    }
    _loadMatrix(t, e=!1) {
        let i = t;
        e && (this._multiply(i, this.uniforms.m, t),
        i = this._colorMatrix(i)),
        this.uniforms.m = i
    }
    _multiply(t, e, i) {
        return t[0] = e[0] * i[0] + e[1] * i[5] + e[2] * i[10] + e[3] * i[15],
        t[1] = e[0] * i[1] + e[1] * i[6] + e[2] * i[11] + e[3] * i[16],
        t[2] = e[0] * i[2] + e[1] * i[7] + e[2] * i[12] + e[3] * i[17],
        t[3] = e[0] * i[3] + e[1] * i[8] + e[2] * i[13] + e[3] * i[18],
        t[4] = e[0] * i[4] + e[1] * i[9] + e[2] * i[14] + e[3] * i[19] + e[4],
        t[5] = e[5] * i[0] + e[6] * i[5] + e[7] * i[10] + e[8] * i[15],
        t[6] = e[5] * i[1] + e[6] * i[6] + e[7] * i[11] + e[8] * i[16],
        t[7] = e[5] * i[2] + e[6] * i[7] + e[7] * i[12] + e[8] * i[17],
        t[8] = e[5] * i[3] + e[6] * i[8] + e[7] * i[13] + e[8] * i[18],
        t[9] = e[5] * i[4] + e[6] * i[9] + e[7] * i[14] + e[8] * i[19] + e[9],
        t[10] = e[10] * i[0] + e[11] * i[5] + e[12] * i[10] + e[13] * i[15],
        t[11] = e[10] * i[1] + e[11] * i[6] + e[12] * i[11] + e[13] * i[16],
        t[12] = e[10] * i[2] + e[11] * i[7] + e[12] * i[12] + e[13] * i[17],
        t[13] = e[10] * i[3] + e[11] * i[8] + e[12] * i[13] + e[13] * i[18],
        t[14] = e[10] * i[4] + e[11] * i[9] + e[12] * i[14] + e[13] * i[19] + e[14],
        t[15] = e[15] * i[0] + e[16] * i[5] + e[17] * i[10] + e[18] * i[15],
        t[16] = e[15] * i[1] + e[16] * i[6] + e[17] * i[11] + e[18] * i[16],
        t[17] = e[15] * i[2] + e[16] * i[7] + e[17] * i[12] + e[18] * i[17],
        t[18] = e[15] * i[3] + e[16] * i[8] + e[17] * i[13] + e[18] * i[18],
        t[19] = e[15] * i[4] + e[16] * i[9] + e[17] * i[14] + e[18] * i[19] + e[19],
        t
    }
    _colorMatrix(t) {
        const e = new Float32Array(t);
        return e[4] /= 255,
        e[9] /= 255,
        e[14] /= 255,
        e[19] /= 255,
        e
    }
    brightness(t, e) {
        const i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, e)
    }
    tint(t, e) {
        const [i,r,n] = zt.shared.setValue(t).toArray()
          , o = [i, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, e)
    }
    greyscale(t, e) {
        const i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, e)
    }
    blackAndWhite(t) {
        const e = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    hue(t, e) {
        t = (t || 0) / 180 * Math.PI;
        const i = Math.cos(t)
          , r = Math.sin(t)
          , n = Math.sqrt
          , o = 1 / 3
          , a = n(o)
          , l = i + (1 - i) * o
          , h = o * (1 - i) - a * r
          , u = o * (1 - i) + a * r
          , c = o * (1 - i) + a * r
          , d = i + o * (1 - i)
          , f = o * (1 - i) - a * r
          , p = o * (1 - i) - a * r
          , m = o * (1 - i) + a * r
          , g = i + o * (1 - i)
          , _ = [l, h, u, 0, 0, c, d, f, 0, 0, p, m, g, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(_, e)
    }
    contrast(t, e) {
        const i = (t || 0) + 1
          , r = -.5 * (i - 1)
          , n = [i, 0, 0, 0, r, 0, i, 0, 0, r, 0, 0, i, 0, r, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    saturate(t=0, e) {
        const i = t * 2 / 3 + 1
          , r = (i - 1) * -.5
          , n = [i, r, r, 0, 0, r, i, r, 0, 0, r, r, i, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, e)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        const e = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    sepia(t) {
        const e = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    technicolor(t) {
        const e = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    polaroid(t) {
        const e = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    toBGR(t) {
        const e = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    kodachrome(t) {
        const e = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    browni(t) {
        const e = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    vintage(t) {
        const e = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    colorTone(t, e, i, r, n) {
        t = t || .2,
        e = e || .15,
        i = i || 16770432,
        r = r || 3375104;
        const o = zt.shared
          , [a,l,h] = o.setValue(i).toArray()
          , [u,c,d] = o.setValue(r).toArray()
          , f = [.3, .59, .11, 0, 0, a, l, h, t, 0, u, c, d, e, 0, a - u, l - c, h - d, 0, 0];
        this._loadMatrix(f, n)
    }
    night(t, e) {
        t = t || .1;
        const i = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, e)
    }
    predator(t, e) {
        const i = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(i, e)
    }
    lsd(t) {
        const e = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(e, t)
    }
    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(t, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
oc.prototype.grayscale = oc.prototype.greyscale;
var BI = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`
  , OI = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class hg extends ti {
    constructor(t, e) {
        const i = new Qt;
        t.renderable = !1,
        super(OI, BI, {
            mapSampler: t._texture,
            filterMatrix: i,
            scale: {
                x: 1,
                y: 1
            },
            rotation: new Float32Array([1, 0, 0, 1])
        }),
        this.maskSprite = t,
        this.maskMatrix = i,
        e == null && (e = 20),
        this.scale = new Nt(e,e)
    }
    apply(t, e, i, r) {
        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite),
        this.uniforms.scale.x = this.scale.x,
        this.uniforms.scale.y = this.scale.y;
        const n = this.maskSprite.worldTransform
          , o = Math.sqrt(n.a * n.a + n.b * n.b)
          , a = Math.sqrt(n.c * n.c + n.d * n.d);
        o !== 0 && a !== 0 && (this.uniforms.rotation[0] = n.a / o,
        this.uniforms.rotation[1] = n.b / o,
        this.uniforms.rotation[2] = n.c / a,
        this.uniforms.rotation[3] = n.d / a),
        t.applyFilter(this, e, i, r)
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(t) {
        this.uniforms.mapSampler = t
    }
}
var kI = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`
  , LI = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class ib extends ti {
    constructor() {
        super(LI, kI)
    }
}
var NI = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class rb extends ti {
    constructor(t=.5, e=Math.random()) {
        super(rg, NI, {
            uNoise: 0,
            uSeed: 0
        }),
        this.noise = t,
        this.seed = e
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(t) {
        this.uniforms.uNoise = t
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(t) {
        this.uniforms.uSeed = t
    }
}
const vp = {
    AlphaFilter: tb,
    BlurFilter: eb,
    BlurFilterPass: nc,
    ColorMatrixFilter: oc,
    DisplacementFilter: hg,
    FXAAFilter: ib,
    NoiseFilter: rb
};
Object.entries(vp).forEach(([s,t])=>{
    Object.defineProperty(vp, s, {
        get() {
            return Et("7.1.0", `filters.${s} has moved to ${s}`),
            t
        }
    })
}
);
class UI {
    constructor() {
        this.interactionFrequency = 10,
        this._deltaTime = 0,
        this._didMove = !1,
        this.tickerAdded = !1,
        this._pauseUpdate = !0
    }
    init(t) {
        this.removeTickerListener(),
        this.events = t,
        this.interactionFrequency = 10,
        this._deltaTime = 0,
        this._didMove = !1,
        this.tickerAdded = !1,
        this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(t) {
        this._pauseUpdate = t
    }
    addTickerListener() {
        this.tickerAdded || !this.domElement || (Ue.system.add(this.tickerUpdate, this, Es.INTERACTION),
        this.tickerAdded = !0)
    }
    removeTickerListener() {
        this.tickerAdded && (Ue.system.remove(this.tickerUpdate, this),
        this.tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    update() {
        if (!this.domElement || this._pauseUpdate)
            return;
        if (this._didMove) {
            this._didMove = !1;
            return
        }
        const t = this.events.rootPointerEvent;
        this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove",{
            clientX: t.clientX,
            clientY: t.clientY
        }))
    }
    tickerUpdate(t) {
        this._deltaTime += t,
        !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0,
        this.update())
    }
}
const Os = new UI;
class aa {
    constructor(t) {
        this.bubbles = !0,
        this.cancelBubble = !0,
        this.cancelable = !1,
        this.composed = !1,
        this.defaultPrevented = !1,
        this.eventPhase = aa.prototype.NONE,
        this.propagationStopped = !1,
        this.propagationImmediatelyStopped = !1,
        this.layer = new Nt,
        this.page = new Nt,
        this.NONE = 0,
        this.CAPTURING_PHASE = 1,
        this.AT_TARGET = 2,
        this.BUBBLING_PHASE = 3,
        this.manager = t
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []),
        this.path
    }
    initEvent(t, e, i) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(t, e, i, r, n) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
        this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class Ul extends aa {
    constructor() {
        super(...arguments),
        this.client = new Nt,
        this.movement = new Nt,
        this.offset = new Nt,
        this.global = new Nt,
        this.screen = new Nt
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(t, e, i) {
        return t.worldTransform.applyInverse(i || this.global, e)
    }
    getModifierState(t) {
        return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }
    initMouseEvent(t, e, i, r, n, o, a, l, h, u, c, d, f, p, m) {
        throw new Error("Method not implemented.")
    }
}
class Yi extends Ul {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.height = 0,
        this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class Gn extends Ul {
    constructor() {
        super(...arguments),
        this.DOM_DELTA_PIXEL = 0,
        this.DOM_DELTA_LINE = 1,
        this.DOM_DELTA_PAGE = 2
    }
}
Gn.DOM_DELTA_PIXEL = 0,
Gn.DOM_DELTA_LINE = 1,
Gn.DOM_DELTA_PAGE = 2;
const GI = 2048
  , HI = new Nt
  , $d = new Nt;
class sb {
    constructor(t) {
        this.dispatch = new na,
        this.moveOnAll = !1,
        this.enableGlobalMoveEvents = !0,
        this.mappingState = {
            trackingData: {}
        },
        this.eventPool = new Map,
        this._allInteractiveElements = [],
        this._hitElements = [],
        this._isPointerMoveEvent = !1,
        this.rootTarget = t,
        this.hitPruneFn = this.hitPruneFn.bind(this),
        this.hitTestFn = this.hitTestFn.bind(this),
        this.mapPointerDown = this.mapPointerDown.bind(this),
        this.mapPointerMove = this.mapPointerMove.bind(this),
        this.mapPointerOut = this.mapPointerOut.bind(this),
        this.mapPointerOver = this.mapPointerOver.bind(this),
        this.mapPointerUp = this.mapPointerUp.bind(this),
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
        this.mapWheel = this.mapWheel.bind(this),
        this.mappingTable = {},
        this.addEventMapping("pointerdown", this.mapPointerDown),
        this.addEventMapping("pointermove", this.mapPointerMove),
        this.addEventMapping("pointerout", this.mapPointerOut),
        this.addEventMapping("pointerleave", this.mapPointerOut),
        this.addEventMapping("pointerover", this.mapPointerOver),
        this.addEventMapping("pointerup", this.mapPointerUp),
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
        this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(t, e) {
        this.mappingTable[t] || (this.mappingTable[t] = []),
        this.mappingTable[t].push({
            fn: e,
            priority: 0
        }),
        this.mappingTable[t].sort((i,r)=>i.priority - r.priority)
    }
    dispatchEvent(t, e) {
        t.propagationStopped = !1,
        t.propagationImmediatelyStopped = !1,
        this.propagate(t, e),
        this.dispatch.emit(e || t.type, t)
    }
    mapEvent(t) {
        if (!this.rootTarget)
            return;
        const e = this.mappingTable[t.type];
        if (e)
            for (let i = 0, r = e.length; i < r; i++)
                e[i].fn(t);
        else
            console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }
    hitTest(t, e) {
        Os.pauseUpdate = !0;
        const i = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"
          , r = this[i](this.rootTarget, this.rootTarget.eventMode, HI.set(t, e), this.hitTestFn, this.hitPruneFn);
        return r && r[0]
    }
    propagate(t, e) {
        if (!t.target)
            return;
        const i = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let r = 0, n = i.length - 1; r < n; r++)
            if (t.currentTarget = i[r],
            this.notifyTarget(t, e),
            t.propagationStopped || t.propagationImmediatelyStopped)
                return;
        if (t.eventPhase = t.AT_TARGET,
        t.currentTarget = t.target,
        this.notifyTarget(t, e),
        !(t.propagationStopped || t.propagationImmediatelyStopped)) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let r = i.length - 2; r >= 0; r--)
                if (t.currentTarget = i[r],
                this.notifyTarget(t, e),
                t.propagationStopped || t.propagationImmediatelyStopped)
                    return
        }
    }
    all(t, e, i=this._allInteractiveElements) {
        if (i.length === 0)
            return;
        t.eventPhase = t.BUBBLING_PHASE;
        const r = Array.isArray(e) ? e : [e];
        for (let n = i.length - 1; n >= 0; n--)
            r.forEach(o=>{
                t.currentTarget = i[n],
                this.notifyTarget(t, o)
            }
            )
    }
    propagationPath(t) {
        const e = [t];
        for (let i = 0; i < GI && t !== this.rootTarget; i++) {
            if (!t.parent)
                throw new Error("Cannot find propagation path to disconnected target");
            e.push(t.parent),
            t = t.parent
        }
        return e.reverse(),
        e
    }
    hitTestMoveRecursive(t, e, i, r, n, o=!1) {
        let a = !1;
        if (this._interactivePrune(t))
            return null;
        if ((t.eventMode === "dynamic" || e === "dynamic") && (Os.pauseUpdate = !1),
        t.interactiveChildren && t.children) {
            const u = t.children;
            for (let c = u.length - 1; c >= 0; c--) {
                const d = u[c]
                  , f = this.hitTestMoveRecursive(d, this._isInteractive(e) ? e : d.eventMode, i, r, n, o || n(t, i));
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent)
                        continue;
                    const p = t.isInteractive();
                    (f.length > 0 || p) && (p && this._allInteractiveElements.push(t),
                    f.push(t)),
                    this._hitElements.length === 0 && (this._hitElements = f),
                    a = !0
                }
            }
        }
        const l = this._isInteractive(e)
          , h = t.isInteractive();
        return l && h && this._allInteractiveElements.push(t),
        o || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !n(t, i) && r(t, i) ? h ? [t] : [] : null
    }
    hitTestRecursive(t, e, i, r, n) {
        if (this._interactivePrune(t) || n(t, i))
            return null;
        if ((t.eventMode === "dynamic" || e === "dynamic") && (Os.pauseUpdate = !1),
        t.interactiveChildren && t.children) {
            const l = t.children;
            for (let h = l.length - 1; h >= 0; h--) {
                const u = l[h]
                  , c = this.hitTestRecursive(u, this._isInteractive(e) ? e : u.eventMode, i, r, n);
                if (c) {
                    if (c.length > 0 && !c[c.length - 1].parent)
                        continue;
                    const d = t.isInteractive();
                    return (c.length > 0 || d) && c.push(t),
                    c
                }
            }
        }
        const o = this._isInteractive(e)
          , a = t.isInteractive();
        return o && r(t, i) ? a ? [t] : [] : null
    }
    _isInteractive(t) {
        return t === "static" || t === "dynamic"
    }
    _interactivePrune(t) {
        return !!(!t || t.isMask || !t.visible || !t.renderable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren || t.isMask)
    }
    hitPruneFn(t, e) {
        if (t.hitArea && (t.worldTransform.applyInverse(e, $d),
        !t.hitArea.contains($d.x, $d.y)))
            return !0;
        if (t._mask) {
            const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (i && !i.containsPoint?.(e))
                return !0
        }
        return !1
    }
    hitTestFn(t, e) {
        return t.eventMode === "passive" ? !1 : t.hitArea ? !0 : t.containsPoint ? t.containsPoint(e) : !1
    }
    notifyTarget(t, e) {
        e = e ?? t.type;
        const i = `on${e}`;
        t.currentTarget[i]?.(t);
        const r = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
        this.notifyListeners(t, r),
        t.eventPhase === t.AT_TARGET && this.notifyListeners(t, e)
    }
    mapPointerDown(t) {
        if (!(t instanceof Yi)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const e = this.createPointerEvent(t);
        if (this.dispatchEvent(e, "pointerdown"),
        e.pointerType === "touch")
            this.dispatchEvent(e, "touchstart");
        else if (e.pointerType === "mouse" || e.pointerType === "pen") {
            const r = e.button === 2;
            this.dispatchEvent(e, r ? "rightdown" : "mousedown")
        }
        const i = this.trackingData(t.pointerId);
        i.pressTargetsByButton[t.button] = e.composedPath(),
        this.freeEvent(e)
    }
    mapPointerMove(t) {
        if (!(t instanceof Yi)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        this._allInteractiveElements.length = 0,
        this._hitElements.length = 0,
        this._isPointerMoveEvent = !0;
        const e = this.createPointerEvent(t);
        this._isPointerMoveEvent = !1;
        const i = e.pointerType === "mouse" || e.pointerType === "pen"
          , r = this.trackingData(t.pointerId)
          , n = this.findMountedTarget(r.overTargets);
        if (r.overTargets?.length > 0 && n !== e.target) {
            const l = t.type === "mousemove" ? "mouseout" : "pointerout"
              , h = this.createPointerEvent(t, l, n);
            if (this.dispatchEvent(h, "pointerout"),
            i && this.dispatchEvent(h, "mouseout"),
            !e.composedPath().includes(n)) {
                const u = this.createPointerEvent(t, "pointerleave", n);
                for (u.eventPhase = u.AT_TARGET; u.target && !e.composedPath().includes(u.target); )
                    u.currentTarget = u.target,
                    this.notifyTarget(u),
                    i && this.notifyTarget(u, "mouseleave"),
                    u.target = u.target.parent;
                this.freeEvent(u)
            }
            this.freeEvent(h)
        }
        if (n !== e.target) {
            const l = t.type === "mousemove" ? "mouseover" : "pointerover"
              , h = this.clonePointerEvent(e, l);
            this.dispatchEvent(h, "pointerover"),
            i && this.dispatchEvent(h, "mouseover");
            let u = n?.parent;
            for (; u && u !== this.rootTarget.parent && u !== e.target; )
                u = u.parent;
            if (!u || u === this.rootTarget.parent) {
                const c = this.clonePointerEvent(e, "pointerenter");
                for (c.eventPhase = c.AT_TARGET; c.target && c.target !== n && c.target !== this.rootTarget.parent; )
                    c.currentTarget = c.target,
                    this.notifyTarget(c),
                    i && this.notifyTarget(c, "mouseenter"),
                    c.target = c.target.parent;
                this.freeEvent(c)
            }
            this.freeEvent(h)
        }
        const o = []
          , a = this.enableGlobalMoveEvents ?? !0;
        this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(e, "pointermove"),
        a && o.push("globalpointermove"),
        e.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"),
        a && o.push("globaltouchmove")),
        i && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"),
        a && o.push("globalmousemove"),
        this.cursor = e.target?.cursor),
        o.length > 0 && this.all(e, o),
        this._allInteractiveElements.length = 0,
        this._hitElements.length = 0,
        r.overTargets = e.composedPath(),
        this.freeEvent(e)
    }
    mapPointerOver(t) {
        if (!(t instanceof Yi)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const e = this.trackingData(t.pointerId)
          , i = this.createPointerEvent(t)
          , r = i.pointerType === "mouse" || i.pointerType === "pen";
        this.dispatchEvent(i, "pointerover"),
        r && this.dispatchEvent(i, "mouseover"),
        i.pointerType === "mouse" && (this.cursor = i.target?.cursor);
        const n = this.clonePointerEvent(i, "pointerenter");
        for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent; )
            n.currentTarget = n.target,
            this.notifyTarget(n),
            r && this.notifyTarget(n, "mouseenter"),
            n.target = n.target.parent;
        e.overTargets = i.composedPath(),
        this.freeEvent(i),
        this.freeEvent(n)
    }
    mapPointerOut(t) {
        if (!(t instanceof Yi)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const e = this.trackingData(t.pointerId);
        if (e.overTargets) {
            const i = t.pointerType === "mouse" || t.pointerType === "pen"
              , r = this.findMountedTarget(e.overTargets)
              , n = this.createPointerEvent(t, "pointerout", r);
            this.dispatchEvent(n),
            i && this.dispatchEvent(n, "mouseout");
            const o = this.createPointerEvent(t, "pointerleave", r);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
                o.currentTarget = o.target,
                this.notifyTarget(o),
                i && this.notifyTarget(o, "mouseleave"),
                o.target = o.target.parent;
            e.overTargets = null,
            this.freeEvent(n),
            this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof Yi)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const e = performance.now()
          , i = this.createPointerEvent(t);
        if (this.dispatchEvent(i, "pointerup"),
        i.pointerType === "touch")
            this.dispatchEvent(i, "touchend");
        else if (i.pointerType === "mouse" || i.pointerType === "pen") {
            const a = i.button === 2;
            this.dispatchEvent(i, a ? "rightup" : "mouseup")
        }
        const r = this.trackingData(t.pointerId)
          , n = this.findMountedTarget(r.pressTargetsByButton[t.button]);
        let o = n;
        if (n && !i.composedPath().includes(n)) {
            let a = n;
            for (; a && !i.composedPath().includes(a); ) {
                if (i.currentTarget = a,
                this.notifyTarget(i, "pointerupoutside"),
                i.pointerType === "touch")
                    this.notifyTarget(i, "touchendoutside");
                else if (i.pointerType === "mouse" || i.pointerType === "pen") {
                    const l = i.button === 2;
                    this.notifyTarget(i, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete r.pressTargetsByButton[t.button],
            o = a
        }
        if (o) {
            const a = this.clonePointerEvent(i, "click");
            a.target = o,
            a.path = null,
            r.clicksByButton[t.button] || (r.clicksByButton[t.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: e
            });
            const l = r.clicksByButton[t.button];
            if (l.target === a.target && e - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1,
            l.target = a.target,
            l.timeStamp = e,
            a.detail = l.clickCount,
            a.pointerType === "mouse") {
                const h = a.button === 2;
                this.dispatchEvent(a, h ? "rightclick" : "click")
            } else
                a.pointerType === "touch" && this.dispatchEvent(a, "tap");
            this.dispatchEvent(a, "pointertap"),
            this.freeEvent(a)
        }
        this.freeEvent(i)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof Yi)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const e = this.trackingData(t.pointerId)
          , i = this.findMountedTarget(e.pressTargetsByButton[t.button])
          , r = this.createPointerEvent(t);
        if (i) {
            let n = i;
            for (; n; )
                r.currentTarget = n,
                this.notifyTarget(r, "pointerupoutside"),
                r.pointerType === "touch" ? this.notifyTarget(r, "touchendoutside") : (r.pointerType === "mouse" || r.pointerType === "pen") && this.notifyTarget(r, r.button === 2 ? "rightupoutside" : "mouseupoutside"),
                n = n.parent;
            delete e.pressTargetsByButton[t.button]
        }
        this.freeEvent(r)
    }
    mapWheel(t) {
        if (!(t instanceof Gn)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const e = this.createWheelEvent(t);
        this.dispatchEvent(e),
        this.freeEvent(e)
    }
    findMountedTarget(t) {
        if (!t)
            return null;
        let e = t[0];
        for (let i = 1; i < t.length && t[i].parent === e; i++)
            e = t[i];
        return e
    }
    createPointerEvent(t, e, i) {
        const r = this.allocateEvent(Yi);
        return this.copyPointerData(t, r),
        this.copyMouseData(t, r),
        this.copyData(t, r),
        r.nativeEvent = t.nativeEvent,
        r.originalEvent = t,
        r.target = i ?? this.hitTest(r.global.x, r.global.y) ?? this._hitElements[0],
        typeof e == "string" && (r.type = e),
        r
    }
    createWheelEvent(t) {
        const e = this.allocateEvent(Gn);
        return this.copyWheelData(t, e),
        this.copyMouseData(t, e),
        this.copyData(t, e),
        e.nativeEvent = t.nativeEvent,
        e.originalEvent = t,
        e.target = this.hitTest(e.global.x, e.global.y),
        e
    }
    clonePointerEvent(t, e) {
        const i = this.allocateEvent(Yi);
        return i.nativeEvent = t.nativeEvent,
        i.originalEvent = t.originalEvent,
        this.copyPointerData(t, i),
        this.copyMouseData(t, i),
        this.copyData(t, i),
        i.target = t.target,
        i.path = t.composedPath().slice(),
        i.type = e ?? i.type,
        i
    }
    copyWheelData(t, e) {
        e.deltaMode = t.deltaMode,
        e.deltaX = t.deltaX,
        e.deltaY = t.deltaY,
        e.deltaZ = t.deltaZ
    }
    copyPointerData(t, e) {
        t instanceof Yi && e instanceof Yi && (e.pointerId = t.pointerId,
        e.width = t.width,
        e.height = t.height,
        e.isPrimary = t.isPrimary,
        e.pointerType = t.pointerType,
        e.pressure = t.pressure,
        e.tangentialPressure = t.tangentialPressure,
        e.tiltX = t.tiltX,
        e.tiltY = t.tiltY,
        e.twist = t.twist)
    }
    copyMouseData(t, e) {
        t instanceof Ul && e instanceof Ul && (e.altKey = t.altKey,
        e.button = t.button,
        e.buttons = t.buttons,
        e.client.copyFrom(t.client),
        e.ctrlKey = t.ctrlKey,
        e.metaKey = t.metaKey,
        e.movement.copyFrom(t.movement),
        e.screen.copyFrom(t.screen),
        e.shiftKey = t.shiftKey,
        e.global.copyFrom(t.global))
    }
    copyData(t, e) {
        e.isTrusted = t.isTrusted,
        e.srcElement = t.srcElement,
        e.timeStamp = performance.now(),
        e.type = t.type,
        e.detail = t.detail,
        e.view = t.view,
        e.which = t.which,
        e.layer.copyFrom(t.layer),
        e.page.copyFrom(t.page)
    }
    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }),
        this.mappingState.trackingData[t]
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const e = this.eventPool.get(t).pop() || new t(this);
        return e.eventPhase = e.NONE,
        e.currentTarget = null,
        e.path = null,
        e.target = null,
        e
    }
    freeEvent(t) {
        if (t.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const e = t.constructor;
        this.eventPool.has(e) || this.eventPool.set(e, []),
        this.eventPool.get(e).push(t)
    }
    notifyListeners(t, e) {
        const i = t.currentTarget._events[e];
        if (i && t.currentTarget.isInteractive())
            if ("fn"in i)
                i.once && t.currentTarget.removeListener(e, i.fn, void 0, !0),
                i.fn.call(i.context, t);
            else
                for (let r = 0, n = i.length; r < n && !t.propagationImmediatelyStopped; r++)
                    i[r].once && t.currentTarget.removeListener(e, i[r].fn, void 0, !0),
                    i[r].fn.call(i[r].context, t)
    }
}
const $I = 1
  , zI = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
}
  , xp = class bp {
    constructor(t) {
        this.supportsTouchEvents = "ontouchstart"in globalThis,
        this.supportsPointerEvents = !!globalThis.PointerEvent,
        this.domElement = null,
        this.resolution = 1,
        this.renderer = t,
        this.rootBoundary = new sb(null),
        Os.init(this),
        this.autoPreventDefault = !0,
        this.eventsAdded = !1,
        this.rootPointerEvent = new Yi(null),
        this.rootWheelEvent = new Gn(null),
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        },
        this.features = new Proxy({
            ...bp.defaultEventFeatures
        },{
            set: (e,i,r)=>(i === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = r),
            e[i] = r,
            !0)
        }),
        this.onPointerDown = this.onPointerDown.bind(this),
        this.onPointerMove = this.onPointerMove.bind(this),
        this.onPointerUp = this.onPointerUp.bind(this),
        this.onPointerOverOut = this.onPointerOverOut.bind(this),
        this.onWheel = this.onWheel.bind(this)
    }
    static get defaultEventMode() {
        return this._defaultEventMode
    }
    init(t) {
        const {view: e, resolution: i} = this.renderer;
        this.setTargetElement(e),
        this.resolution = i,
        bp._defaultEventMode = t.eventMode ?? "auto",
        Object.assign(this.features, t.eventFeatures ?? {}),
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
    }
    resolutionChange(t) {
        this.resolution = t
    }
    destroy() {
        this.setTargetElement(null),
        this.renderer = null
    }
    setCursor(t) {
        t = t || "default";
        let e = !0;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1),
        this.currentCursor === t)
            return;
        this.currentCursor = t;
        const i = this.cursorStyles[t];
        if (i)
            switch (typeof i) {
            case "string":
                e && (this.domElement.style.cursor = i);
                break;
            case "function":
                i(t);
                break;
            case "object":
                e && Object.assign(this.domElement.style, i);
                break
            }
        else
            e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
    }
    get pointer() {
        return this.rootPointerEvent
    }
    onPointerDown(t) {
        if (!this.features.click)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const e = this.normalizeToPointerData(t);
        this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable"in t)) && t.preventDefault();
        for (let i = 0, r = e.length; i < r; i++) {
            const n = e[i]
              , o = this.bootstrapEvent(this.rootPointerEvent, n);
            this.rootBoundary.mapEvent(o)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerMove(t) {
        if (!this.features.move)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        Os.pointerMoved();
        const e = this.normalizeToPointerData(t);
        for (let i = 0, r = e.length; i < r; i++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, e[i]);
            this.rootBoundary.mapEvent(n)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerUp(t) {
        if (!this.features.click)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let e = t.target;
        t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
        const i = e !== this.domElement ? "outside" : ""
          , r = this.normalizeToPointerData(t);
        for (let n = 0, o = r.length; n < o; n++) {
            const a = this.bootstrapEvent(this.rootPointerEvent, r[n]);
            a.type += i,
            this.rootBoundary.mapEvent(a)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerOverOut(t) {
        if (!this.features.click)
            return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const e = this.normalizeToPointerData(t);
        for (let i = 0, r = e.length; i < r; i++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, e[i]);
            this.rootBoundary.mapEvent(n)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onWheel(t) {
        if (!this.features.wheel)
            return;
        const e = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.rootBoundary.mapEvent(e)
    }
    setTargetElement(t) {
        this.removeEvents(),
        this.domElement = t,
        Os.domElement = t,
        this.addEvents()
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement)
            return;
        Os.addTickerListener();
        const t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none",
        t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")),
        this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.addEventListener("mouseup", this.onPointerUp, !0),
        this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.addEventListener("touchend", this.onPointerUp, !0),
        this.domElement.addEventListener("touchmove", this.onPointerMove, !0))),
        this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0
        }),
        this.eventsAdded = !0
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement)
            return;
        Os.removeTickerListener();
        const t = this.domElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "",
        t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""),
        this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("mouseup", this.onPointerUp, !0),
        this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.removeEventListener("touchend", this.onPointerUp, !0),
        this.domElement.removeEventListener("touchmove", this.onPointerMove, !0))),
        this.domElement.removeEventListener("wheel", this.onWheel, !0),
        this.domElement = null,
        this.eventsAdded = !1
    }
    mapPositionToPoint(t, e, i) {
        const r = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        }
          , n = 1 / this.resolution;
        t.x = (e - r.left) * (this.domElement.width / r.width) * n,
        t.y = (i - r.top) * (this.domElement.height / r.height) * n
    }
    normalizeToPointerData(t) {
        const e = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent)
            for (let i = 0, r = t.changedTouches.length; i < r; i++) {
                const n = t.changedTouches[i];
                typeof n.button > "u" && (n.button = 0),
                typeof n.buttons > "u" && (n.buttons = 1),
                typeof n.isPrimary > "u" && (n.isPrimary = t.touches.length === 1 && t.type === "touchstart"),
                typeof n.width > "u" && (n.width = n.radiusX || 1),
                typeof n.height > "u" && (n.height = n.radiusY || 1),
                typeof n.tiltX > "u" && (n.tiltX = 0),
                typeof n.tiltY > "u" && (n.tiltY = 0),
                typeof n.pointerType > "u" && (n.pointerType = "touch"),
                typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0),
                typeof n.pressure > "u" && (n.pressure = n.force || .5),
                typeof n.twist > "u" && (n.twist = 0),
                typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0),
                typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX),
                typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY),
                n.isNormalized = !0,
                n.type = t.type,
                e.push(n)
            }
        else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
            const i = t;
            typeof i.isPrimary > "u" && (i.isPrimary = !0),
            typeof i.width > "u" && (i.width = 1),
            typeof i.height > "u" && (i.height = 1),
            typeof i.tiltX > "u" && (i.tiltX = 0),
            typeof i.tiltY > "u" && (i.tiltY = 0),
            typeof i.pointerType > "u" && (i.pointerType = "mouse"),
            typeof i.pointerId > "u" && (i.pointerId = $I),
            typeof i.pressure > "u" && (i.pressure = .5),
            typeof i.twist > "u" && (i.twist = 0),
            typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
            i.isNormalized = !0,
            e.push(i)
        } else
            e.push(t);
        return e
    }
    normalizeWheelEvent(t) {
        const e = this.rootWheelEvent;
        return this.transferMouseData(e, t),
        e.deltaX = t.deltaX,
        e.deltaY = t.deltaY,
        e.deltaZ = t.deltaZ,
        e.deltaMode = t.deltaMode,
        this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
        e.global.copyFrom(e.screen),
        e.offset.copyFrom(e.screen),
        e.nativeEvent = t,
        e.type = t.type,
        e
    }
    bootstrapEvent(t, e) {
        return t.originalEvent = null,
        t.nativeEvent = e,
        t.pointerId = e.pointerId,
        t.width = e.width,
        t.height = e.height,
        t.isPrimary = e.isPrimary,
        t.pointerType = e.pointerType,
        t.pressure = e.pressure,
        t.tangentialPressure = e.tangentialPressure,
        t.tiltX = e.tiltX,
        t.tiltY = e.tiltY,
        t.twist = e.twist,
        this.transferMouseData(t, e),
        this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
        t.global.copyFrom(t.screen),
        t.offset.copyFrom(t.screen),
        t.isTrusted = e.isTrusted,
        t.type === "pointerleave" && (t.type = "pointerout"),
        t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")),
        t.type.startsWith("touch") && (t.type = zI[t.type] || t.type),
        t
    }
    transferMouseData(t, e) {
        t.isTrusted = e.isTrusted,
        t.srcElement = e.srcElement,
        t.timeStamp = performance.now(),
        t.type = e.type,
        t.altKey = e.altKey,
        t.button = e.button,
        t.buttons = e.buttons,
        t.client.x = e.clientX,
        t.client.y = e.clientY,
        t.ctrlKey = e.ctrlKey,
        t.metaKey = e.metaKey,
        t.movement.x = e.movementX,
        t.movement.y = e.movementY,
        t.page.x = e.pageX,
        t.page.y = e.pageY,
        t.relatedTarget = null,
        t.shiftKey = e.shiftKey
    }
}
;
xp.extension = {
    name: "events",
    type: [it.RendererSystem, it.CanvasRendererSystem]
},
xp.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0
};
let ac = xp;
ct.add(ac);
function Z_(s) {
    return s === "dynamic" || s === "static"
}
const nb = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
        return this._internalInteractive ?? Z_(ac.defaultEventMode)
    },
    set interactive(s) {
        Et("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."),
        this._internalInteractive = s,
        this.eventMode = s ? "static" : "auto"
    },
    _internalEventMode: void 0,
    get eventMode() {
        return this._internalEventMode ?? ac.defaultEventMode
    },
    set eventMode(s) {
        this._internalInteractive = Z_(s),
        this._internalEventMode = s
    },
    isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic"
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(s, t, e) {
        const i = typeof e == "boolean" && e || typeof e == "object" && e.capture
          , r = typeof e == "object" ? e.signal : void 0
          , n = typeof e == "object" ? e.once === !0 : !1
          , o = typeof t == "function" ? void 0 : t;
        s = i ? `${s}capture` : s;
        const a = typeof t == "function" ? t : t.handleEvent
          , l = this;
        r && r.addEventListener("abort", ()=>{
            l.off(s, a, o)
        }
        ),
        n ? l.once(s, a, o) : l.on(s, a, o)
    },
    removeEventListener(s, t, e) {
        const i = typeof e == "boolean" && e || typeof e == "object" && e.capture
          , r = typeof t == "function" ? void 0 : t;
        s = i ? `${s}capture` : s,
        t = typeof t == "function" ? t : t.handleEvent,
        this.off(s, t, r)
    },
    dispatchEvent(s) {
        if (!(s instanceof aa))
            throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return s.defaultPrevented = !1,
        s.path = null,
        s.target = this,
        s.manager.dispatchEvent(s),
        !s.defaultPrevented
    }
};
re.mixin(nb);
const ob = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
re.mixin(ob);
const VI = 9
  , $h = 100
  , XI = 0
  , WI = 0
  , Q_ = 2
  , J_ = 1
  , jI = -1e3
  , qI = -1e3
  , YI = 2;
class ug {
    constructor(t) {
        this.debug = !1,
        this._isActive = !1,
        this._isMobileAccessibility = !1,
        this.pool = [],
        this.renderId = 0,
        this.children = [],
        this.androidUpdateCount = 0,
        this.androidUpdateFrequency = 500,
        this._hookDiv = null,
        (br.tablet || br.phone) && this.createTouchHook();
        const e = document.createElement("div");
        e.style.width = `${$h}px`,
        e.style.height = `${$h}px`,
        e.style.position = "absolute",
        e.style.top = `${XI}px`,
        e.style.left = `${WI}px`,
        e.style.zIndex = Q_.toString(),
        this.div = e,
        this.renderer = t,
        this._onKeyDown = this._onKeyDown.bind(this),
        this._onMouseMove = this._onMouseMove.bind(this),
        globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = `${J_}px`,
        t.style.height = `${J_}px`,
        t.style.position = "absolute",
        t.style.top = `${jI}px`,
        t.style.left = `${qI}px`,
        t.style.zIndex = YI.toString(),
        t.style.backgroundColor = "#FF0000",
        t.title = "select to enable accessibility for this content",
        t.addEventListener("focus", ()=>{
            this._isMobileAccessibility = !0,
            this.activate(),
            this.destroyTouchHook()
        }
        ),
        document.body.appendChild(t),
        this._hookDiv = t
    }
    destroyTouchHook() {
        this._hookDiv && (document.body.removeChild(this._hookDiv),
        this._hookDiv = null)
    }
    activate() {
        this._isActive || (this._isActive = !0,
        globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown, !1),
        this.renderer.on("postrender", this.update, this),
        this.renderer.view.parentNode?.appendChild(this.div))
    }
    deactivate() {
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.addEventListener("keydown", this._onKeyDown, !1),
        this.renderer.off("postrender", this.update),
        this.div.parentNode?.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren)
            return;
        t.accessible && t.isInteractive() && (t._accessibleActive || this.addChild(t),
        t.renderId = this.renderId);
        const e = t.children;
        if (e)
            for (let i = 0; i < e.length; i++)
                this.updateAccessibleObjects(e[i])
    }
    update() {
        const t = performance.now();
        if (br.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency,
        !this.renderer.renderingToScreen))
            return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {x: e, y: i, width: r, height: n} = this.renderer.view.getBoundingClientRect()
          , {width: o, height: a, resolution: l} = this.renderer
          , h = r / o * l
          , u = n / a * l;
        let c = this.div;
        c.style.left = `${e}px`,
        c.style.top = `${i}px`,
        c.style.width = `${o}px`,
        c.style.height = `${a}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId)
                f._accessibleActive = !1,
                Nn(this.children, d, 1),
                this.div.removeChild(f._accessibleDiv),
                this.pool.push(f._accessibleDiv),
                f._accessibleDiv = null,
                d--;
            else {
                c = f._accessibleDiv;
                let p = f.hitArea;
                const m = f.worldTransform;
                f.hitArea ? (c.style.left = `${(m.tx + p.x * m.a) * h}px`,
                c.style.top = `${(m.ty + p.y * m.d) * u}px`,
                c.style.width = `${p.width * m.a * h}px`,
                c.style.height = `${p.height * m.d * u}px`) : (p = f.getBounds(),
                this.capHitArea(p),
                c.style.left = `${p.x * h}px`,
                c.style.top = `${p.y * u}px`,
                c.style.width = `${p.width * h}px`,
                c.style.height = `${p.height * u}px`,
                c.title !== f.accessibleTitle && f.accessibleTitle !== null && (c.title = f.accessibleTitle),
                c.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && c.setAttribute("aria-label", f.accessibleHint)),
                (f.accessibleTitle !== c.title || f.tabIndex !== c.tabIndex) && (c.title = f.accessibleTitle,
                c.tabIndex = f.tabIndex,
                this.debug && this.updateDebugHTML(c))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        t.x < 0 && (t.width += t.x,
        t.x = 0),
        t.y < 0 && (t.height += t.y,
        t.y = 0);
        const {width: e, height: i} = this.renderer;
        t.x + t.width > e && (t.width = e - t.x),
        t.y + t.height > i && (t.height = i - t.y)
    }
    addChild(t) {
        let e = this.pool.pop();
        e || (e = document.createElement("button"),
        e.style.width = `${$h}px`,
        e.style.height = `${$h}px`,
        e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
        e.style.position = "absolute",
        e.style.zIndex = Q_.toString(),
        e.style.borderStyle = "none",
        navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"),
        navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"),
        e.addEventListener("click", this._onClick.bind(this)),
        e.addEventListener("focus", this._onFocus.bind(this)),
        e.addEventListener("focusout", this._onFocusOut.bind(this))),
        e.style.pointerEvents = t.accessiblePointerEvents,
        e.type = t.accessibleType,
        t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `displayObject ${t.tabIndex}`),
        t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint),
        this.debug && this.updateDebugHTML(e),
        t._accessibleActive = !0,
        t._accessibleDiv = e,
        e.displayObject = t,
        this.children.push(t),
        this.div.appendChild(t._accessibleDiv),
        t._accessibleDiv.tabIndex = t.tabIndex
    }
    _dispatchEvent(t, e) {
        const {displayObject: i} = t.target
          , r = this.renderer.events.rootBoundary
          , n = Object.assign(new aa(r), {
            target: i
        });
        r.rootTarget = this.renderer.lastObjectRendered,
        e.forEach(o=>r.dispatchEvent(n, o))
    }
    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }
    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"),
        this._dispatchEvent(t, ["mouseover"])
    }
    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"),
        this._dispatchEvent(t, ["mouseout"])
    }
    _onKeyDown(t) {
        t.keyCode === VI && this.activate()
    }
    _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(),
        this.div = null,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown),
        this.pool = null,
        this.children = null,
        this.renderer = null
    }
}
ug.extension = {
    name: "accessibility",
    type: [it.RendererPlugin, it.CanvasRendererPlugin]
};
ct.add(ug);
const ab = class wp {
    constructor(t) {
        this.stage = new Si,
        t = Object.assign({
            forceCanvas: !1
        }, t),
        this.renderer = X1(t),
        wp._plugins.forEach(e=>{
            e.init.call(this, t)
        }
        )
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer?.view
    }
    get screen() {
        return this.renderer?.screen
    }
    destroy(t, e) {
        const i = wp._plugins.slice(0);
        i.reverse(),
        i.forEach(r=>{
            r.destroy.call(this)
        }
        ),
        this.stage.destroy(e),
        this.stage = null,
        this.renderer.destroy(t),
        this.renderer = null
    }
}
;
ab._plugins = [];
let cg = ab;
ct.handleByList(it.Application, cg._plugins);
class dg {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(e) {
                globalThis.removeEventListener("resize", this.queueResize),
                this._resizeTo = e,
                e && (globalThis.addEventListener("resize", this.queueResize),
                this.resize())
            },
            get() {
                return this._resizeTo
            }
        }),
        this.queueResize = ()=>{
            this._resizeTo && (this.cancelResize(),
            this._resizeId = requestAnimationFrame(()=>this.resize()))
        }
        ,
        this.cancelResize = ()=>{
            this._resizeId && (cancelAnimationFrame(this._resizeId),
            this._resizeId = null)
        }
        ,
        this.resize = ()=>{
            if (!this._resizeTo)
                return;
            this.cancelResize();
            let e, i;
            if (this._resizeTo === globalThis.window)
                e = globalThis.innerWidth,
                i = globalThis.innerHeight;
            else {
                const {clientWidth: r, clientHeight: n} = this._resizeTo;
                e = r,
                i = n
            }
            this.renderer.resize(e, i),
            this.render()
        }
        ,
        this._resizeId = null,
        this._resizeTo = null,
        this.resizeTo = t.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize),
        this.cancelResize(),
        this.cancelResize = null,
        this.queueResize = null,
        this.resizeTo = null,
        this.resize = null
    }
}
dg.extension = it.Application;
ct.add(dg);
const ty = {
    loader: it.LoadParser,
    resolver: it.ResolveParser,
    cache: it.CacheParser,
    detection: it.DetectionParser
};
ct.handle(it.Asset, s=>{
    const t = s.ref;
    Object.entries(ty).filter(([e])=>!!t[e]).forEach(([e,i])=>ct.add(Object.assign(t[e], {
        extension: t[e].extension ?? i
    })))
}
, s=>{
    const t = s.ref;
    Object.keys(ty).filter(e=>!!t[e]).forEach(e=>ct.remove(t[e]))
}
);
class KI {
    constructor(t, e=!1) {
        this._loader = t,
        this._assetList = [],
        this._isLoading = !1,
        this._maxConcurrent = 1,
        this.verbose = e
    }
    add(t) {
        t.forEach(e=>{
            this._assetList.push(e)
        }
        ),
        this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
        this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = []
              , e = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i = 0; i < e; i++)
                t.push(this._assetList.pop());
            await this._loader.load(t),
            this._isLoading = !1,
            this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t && (this._isActive = t,
        t && !this._isLoading && this._next())
    }
}
function Jn(s, t) {
    if (Array.isArray(t)) {
        for (const e of t)
            if (s.startsWith(`data:${e}`))
                return !0;
        return !1
    }
    return s.startsWith(`data:${t}`)
}
function Ds(s, t) {
    const e = s.split("?")[0]
      , i = Ee.extname(e).toLowerCase();
    return Array.isArray(t) ? t.includes(i) : i === t
}
const ir = (s,t,e=!1)=>(Array.isArray(s) || (s = [s]),
t ? s.map(i=>typeof i == "string" || e ? t(i) : i) : s)
  , lc = (s,t)=>{
    const e = t.split("?")[1];
    return e && (s += `?${e}`),
    s
}
;
function lb(s, t, e, i, r) {
    const n = t[e];
    for (let o = 0; o < n.length; o++) {
        const a = n[o];
        e < t.length - 1 ? lb(s.replace(i[e], a), t, e + 1, i, r) : r.push(s.replace(i[e], a))
    }
}
function hb(s) {
    const t = /\{(.*?)\}/g
      , e = s.match(t)
      , i = [];
    if (e) {
        const r = [];
        e.forEach(n=>{
            const o = n.substring(1, n.length - 1).split(",");
            r.push(o)
        }
        ),
        lb(s, r, 0, e, i)
    } else
        i.push(s);
    return i
}
const Gl = s=>!Array.isArray(s);
class ZI {
    constructor() {
        this._parsers = [],
        this._cache = new Map,
        this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(),
        this._cache.clear()
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const e = this._cache.get(t);
        return e || console.warn(`[Assets] Asset id ${t} was not found in the Cache`),
        e
    }
    set(t, e) {
        const i = ir(t);
        let r;
        for (let a = 0; a < this.parsers.length; a++) {
            const l = this.parsers[a];
            if (l.test(e)) {
                r = l.getCacheableAssets(i, e);
                break
            }
        }
        r || (r = {},
        i.forEach(a=>{
            r[a] = e
        }
        ));
        const n = Object.keys(r)
          , o = {
            cacheKeys: n,
            keys: i
        };
        if (i.forEach(a=>{
            this._cacheMap.set(a, o)
        }
        ),
        n.forEach(a=>{
            this._cache.has(a) && this._cache.get(a) !== e && console.warn("[Cache] already has key:", a),
            this._cache.set(a, r[a])
        }
        ),
        e instanceof st) {
            const a = e;
            i.forEach(l=>{
                a.baseTexture !== st.EMPTY.baseTexture && At.addToCache(a.baseTexture, l),
                st.addToCache(a, l)
            }
            )
        }
    }
    remove(t) {
        if (!this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
            return
        }
        const e = this._cacheMap.get(t);
        e.cacheKeys.forEach(i=>{
            this._cache.delete(i)
        }
        ),
        e.keys.forEach(i=>{
            this._cacheMap.delete(i)
        }
        )
    }
    get parsers() {
        return this._parsers
    }
}
const ks = new ZI;
class QI {
    constructor() {
        this._parsers = [],
        this._parsersValidated = !1,
        this.parsers = new Proxy(this._parsers,{
            set: (t,e,i)=>(this._parsersValidated = !1,
            t[e] = i,
            !0)
        }),
        this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1,
        this.promiseCache = {}
    }
    _getLoadPromiseAndParser(t, e) {
        const i = {
            promise: null,
            parser: null
        };
        return i.promise = (async()=>{
            let r = null
              , n = null;
            if (e.loadParser && (n = this._parserHash[e.loadParser],
            n || console.warn(`[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`)),
            !n) {
                for (let o = 0; o < this.parsers.length; o++) {
                    const a = this.parsers[o];
                    if (a.load && a.test?.(t, e, this)) {
                        n = a;
                        break
                    }
                }
                if (!n)
                    return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),
                    null
            }
            r = await n.load(t, e, this),
            i.parser = n;
            for (let o = 0; o < this.parsers.length; o++) {
                const a = this.parsers[o];
                a.parse && a.parse && await a.testParse?.(r, e, this) && (r = await a.parse(r, e, this) || r,
                i.parser = a)
            }
            return r
        }
        )(),
        i
    }
    async load(t, e) {
        this._parsersValidated || this._validateParsers();
        let i = 0;
        const r = {}
          , n = Gl(t)
          , o = ir(t, h=>({
            alias: [h],
            src: h
        }))
          , a = o.length
          , l = o.map(async h=>{
            const u = Ee.toAbsolute(h.src);
            if (!r[h.src])
                try {
                    this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, h)),
                    r[h.src] = await this.promiseCache[u].promise,
                    e && e(++i / a)
                } catch (c) {
                    throw delete this.promiseCache[u],
                    delete r[h.src],
                    new Error(`[Loader.load] Failed to load ${u}.
${c}`)
                }
        }
        );
        return await Promise.all(l),
        n ? r[o[0].src] : r
    }
    async unload(t) {
        const e = ir(t, i=>({
            alias: [i],
            src: i
        })).map(async i=>{
            const r = Ee.toAbsolute(i.src)
              , n = this.promiseCache[r];
            if (n) {
                const o = await n.promise;
                delete this.promiseCache[r],
                n.parser?.unload?.(o, i, this)
            }
        }
        );
        await Promise.all(e)
    }
    _validateParsers() {
        this._parsersValidated = !0,
        this._parserHash = this._parsers.filter(t=>t.name).reduce((t,e)=>(t[e.name] && console.warn(`[Assets] loadParser name conflict "${e.name}"`),
        {
            ...t,
            [e.name]: e
        }), {})
    }
}
var hr = (s=>(s[s.Low = 0] = "Low",
s[s.Normal = 1] = "Normal",
s[s.High = 2] = "High",
s))(hr || {});
const JI = ".json"
  , tR = "application/json"
  , ub = {
    extension: {
        type: it.LoadParser,
        priority: hr.Low
    },
    name: "loadJson",
    test(s) {
        return Jn(s, tR) || Ds(s, JI)
    },
    async load(s) {
        return await (await nt.ADAPTER.fetch(s)).json()
    }
};
ct.add(ub);
const eR = ".txt"
  , iR = "text/plain"
  , cb = {
    name: "loadTxt",
    extension: {
        type: it.LoadParser,
        priority: hr.Low
    },
    test(s) {
        return Jn(s, iR) || Ds(s, eR)
    },
    async load(s) {
        return await (await nt.ADAPTER.fetch(s)).text()
    }
};
ct.add(cb);
const rR = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
  , sR = [".ttf", ".otf", ".woff", ".woff2"]
  , nR = ["font/ttf", "font/otf", "font/woff", "font/woff2"]
  , oR = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function db(s) {
    const t = Ee.extname(s)
      , e = Ee.basename(s, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(n=>n.charAt(0).toUpperCase() + n.slice(1));
    let i = e.length > 0;
    for (const n of e)
        if (!n.match(oR)) {
            i = !1;
            break
        }
    let r = e.join(" ");
    return i || (r = `"${r.replace(/[\\"]/g, "\\$&")}"`),
    r
}
const aR = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function lR(s) {
    return aR.test(s) ? s : encodeURI(s)
}
const fb = {
    extension: {
        type: it.LoadParser,
        priority: hr.Low
    },
    name: "loadWebFont",
    test(s) {
        return Jn(s, nR) || Ds(s, sR)
    },
    async load(s, t) {
        const e = nt.ADAPTER.getFontFaceSet();
        if (e) {
            const i = []
              , r = t.data?.family ?? db(s)
              , n = t.data?.weights?.filter(a=>rR.includes(a)) ?? ["normal"]
              , o = t.data ?? {};
            for (let a = 0; a < n.length; a++) {
                const l = n[a]
                  , h = new FontFace(r,`url(${lR(s)})`,{
                    ...o,
                    weight: l
                });
                await h.load(),
                e.add(h),
                i.push(h)
            }
            return i.length === 1 ? i[0] : i
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),
        null
    },
    unload(s) {
        (Array.isArray(s) ? s : [s]).forEach(t=>nt.ADAPTER.getFontFaceSet().delete(t))
    }
};
ct.add(fb);
const hR = `(function() {
  "use strict";
  const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  async function checkImageBitmap() {
    try {
      if (typeof createImageBitmap != "function")
        return !1;
      const imageBlob = await (await fetch(WHITE_PNG)).blob(), imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap.width === 1 && imageBitmap.height === 1;
    } catch {
      return !1;
    }
  }
  checkImageBitmap().then((result) => {
    self.postMessage(result);
  });
})();
`;
let zo = null
  , Ep = class extends Worker {
    constructor() {
        zo || (zo = URL.createObjectURL(new Blob([hR],{
            type: "application/javascript"
        }))),
        super(zo)
    }
}
;
Ep.revokeObjectURL = function() {
    zo && (URL.revokeObjectURL(zo),
    zo = null)
}
;
const uR = `(function() {
  "use strict";
  async function loadImageBitmap(url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
    const imageBlob = await response.blob();
    return await createImageBitmap(imageBlob);
  }
  self.onmessage = async (event) => {
    try {
      const imageBitmap = await loadImageBitmap(event.data.data[0]);
      self.postMessage({
        data: imageBitmap,
        uuid: event.data.uuid,
        id: event.data.id
      }, [imageBitmap]);
    } catch (e) {
      self.postMessage({
        error: e,
        uuid: event.data.uuid,
        id: event.data.id
      });
    }
  };
})();
`;
let Vo = null;
class pb extends Worker {
    constructor() {
        Vo || (Vo = URL.createObjectURL(new Blob([uR],{
            type: "application/javascript"
        }))),
        super(Vo)
    }
}
pb.revokeObjectURL = function() {
    Vo && (URL.revokeObjectURL(Vo),
    Vo = null)
}
;
let ey = 0, zd;
class cR {
    constructor() {
        this._initialized = !1,
        this._createdWorkers = 0,
        this.workerPool = [],
        this.queue = [],
        this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t=>{
            const e = new Ep;
            e.addEventListener("message", i=>{
                e.terminate(),
                Ep.revokeObjectURL(),
                t(i.data)
            }
            )
        }
        ),
        this._isImageBitmapSupported)
    }
    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        zd === void 0 && (zd = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < zd && (this._createdWorkers++,
        t = new pb,
        t.addEventListener("message", e=>{
            this.complete(e.data),
            this.returnWorker(e.target),
            this.next()
        }
        )),
        t
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        t.error !== void 0 ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data),
        this.resolveHash[t.uuid] = null
    }
    async _run(t, e) {
        await this._initWorkers();
        const i = new Promise((r,n)=>{
            this.queue.push({
                id: t,
                arguments: e,
                resolve: r,
                reject: n
            })
        }
        );
        return this.next(),
        i
    }
    next() {
        if (!this.queue.length)
            return;
        const t = this.getWorker();
        if (!t)
            return;
        const e = this.queue.pop()
          , i = e.id;
        this.resolveHash[ey] = {
            resolve: e.resolve,
            reject: e.reject
        },
        t.postMessage({
            data: e.arguments,
            uuid: ey++,
            id: i
        })
    }
}
const iy = new cR;
function la(s, t, e) {
    s.resource.internal = !0;
    const i = new st(s)
      , r = ()=>{
        delete t.promiseCache[e],
        ks.has(e) && ks.remove(e)
    }
    ;
    return i.baseTexture.once("destroyed", ()=>{
        e in t.promiseCache && (console.warn("[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture."),
        r())
    }
    ),
    i.once("destroyed", ()=>{
        s.destroyed || (console.warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),
        r())
    }
    ),
    i
}
const dR = [".jpeg", ".jpg", ".png", ".webp", ".avif"]
  , fR = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function mb(s) {
    const t = await nt.ADAPTER.fetch(s);
    if (!t.ok)
        throw new Error(`[loadImageBitmap] Failed to fetch ${s}: ${t.status} ${t.statusText}`);
    const e = await t.blob();
    return await createImageBitmap(e)
}
const Jl = {
    name: "loadTextures",
    extension: {
        type: it.LoadParser,
        priority: hr.High
    },
    config: {
        preferWorkers: !0,
        preferCreateImageBitmap: !0,
        crossOrigin: "anonymous"
    },
    test(s) {
        return Jn(s, fR) || Ds(s, dR)
    },
    async load(s, t, e) {
        const i = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
        let r;
        i ? this.config.preferWorkers && await iy.isImageBitmapSupported() ? r = await iy.loadImageBitmap(s) : r = await mb(s) : r = await new Promise((a,l)=>{
            const h = new Image;
            h.crossOrigin = this.config.crossOrigin,
            h.src = s,
            h.complete ? a(h) : (h.onload = ()=>a(h),
            h.onerror = u=>l(u))
        }
        );
        const n = {
            ...t.data
        };
        n.resolution ?? (n.resolution = is(s)),
        i && n.resourceOptions?.ownsImageBitmap === void 0 && (n.resourceOptions = {
            ...n.resourceOptions
        },
        n.resourceOptions.ownsImageBitmap = !0);
        const o = new At(r,n);
        return o.resource.src = s,
        la(o, e, s)
    },
    unload(s) {
        s.destroy(!0)
    }
};
ct.add(Jl);
const pR = ".svg"
  , mR = "image/svg+xml"
  , gb = {
    extension: {
        type: it.LoadParser,
        priority: hr.High
    },
    name: "loadSVG",
    test(s) {
        return Jn(s, mR) || Ds(s, pR)
    },
    async testParse(s) {
        return sc.test(s)
    },
    async parse(s, t, e) {
        const i = new sc(s,t?.data?.resourceOptions);
        await i.load();
        const r = new At(i,{
            resolution: is(s),
            ...t?.data
        });
        return r.resource.src = t.src,
        la(r, e, t.src)
    },
    async load(s, t) {
        return (await nt.ADAPTER.fetch(s)).text()
    },
    unload: Jl.unload
};
ct.add(gb);
const gR = [".mp4", ".m4v", ".webm", ".ogv"]
  , _R = ["video/mp4", "video/webm", "video/ogg"]
  , _b = {
    name: "loadVideo",
    extension: {
        type: it.LoadParser,
        priority: hr.High
    },
    config: {
        defaultAutoPlay: !0,
        defaultUpdateFPS: 0,
        defaultLoop: !1,
        defaultMuted: !1,
        defaultPlaysinline: !0
    },
    test(s) {
        return Jn(s, _R) || Ds(s, gR)
    },
    async load(s, t, e) {
        let i;
        const r = await (await nt.ADAPTER.fetch(s)).blob()
          , n = URL.createObjectURL(r);
        try {
            const o = {
                autoPlay: this.config.defaultAutoPlay,
                updateFPS: this.config.defaultUpdateFPS,
                loop: this.config.defaultLoop,
                muted: this.config.defaultMuted,
                playsinline: this.config.defaultPlaysinline,
                ...t?.data?.resourceOptions,
                autoLoad: !0
            }
              , a = new lg(n,o);
            await a.load();
            const l = new At(a,{
                alphaMode: await i1(),
                resolution: is(s),
                ...t?.data
            });
            l.resource.src = s,
            i = la(l, e, s),
            i.baseTexture.once("destroyed", ()=>{
                URL.revokeObjectURL(n)
            }
            )
        } catch (o) {
            throw URL.revokeObjectURL(n),
            o
        }
        return i
    },
    unload(s) {
        s.destroy(!0)
    }
};
ct.add(_b);
class yR {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t,e)=>`${t}${this._bundleIdConnector}${e}`,
            extractAssetIdFromBundle: (t,e)=>e.replace(`${t}${this._bundleIdConnector}`, "")
        },
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
        this._assetMap = {},
        this._preferredOrder = [],
        this._parsers = [],
        this._resolverHash = {},
        this._bundles = {}
    }
    setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector,
        this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId,
        this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle,
        this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...t) {
        t.forEach(e=>{
            this._preferredOrder.push(e),
            e.priority || (e.priority = Object.keys(e.params))
        }
        ),
        this._resolverHash = {}
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
        this._assetMap = {},
        this._preferredOrder = [],
        this._resolverHash = {},
        this._rootPath = null,
        this._basePath = null,
        this._manifest = null,
        this._bundles = {},
        this._defaultSearchParams = null
    }
    setDefaultSearchParams(t) {
        if (typeof t == "string")
            this._defaultSearchParams = t;
        else {
            const e = t;
            this._defaultSearchParams = Object.keys(e).map(i=>`${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`).join("&")
        }
    }
    getAlias(t) {
        const {alias: e, name: i, src: r, srcs: n} = t;
        return ir(e || i || r || n, o=>typeof o == "string" ? o : Array.isArray(o) ? o.map(a=>a?.src ?? a?.srcs ?? a) : o?.src || o?.srcs ? o.src ?? o.srcs : o, !0)
    }
    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
        this._manifest = t,
        t.bundles.forEach(e=>{
            this.addBundle(e.name, e.assets)
        }
        )
    }
    addBundle(t, e) {
        const i = [];
        Array.isArray(e) ? e.forEach(r=>{
            const n = r.src ?? r.srcs
              , o = r.alias ?? r.name;
            let a;
            if (typeof o == "string") {
                const l = this._createBundleAssetId(t, o);
                i.push(l),
                a = [o, l]
            } else {
                const l = o.map(h=>this._createBundleAssetId(t, h));
                i.push(...l),
                a = [...o, ...l]
            }
            this.add({
                ...r,
                alias: a,
                src: n
            })
        }
        ) : Object.keys(e).forEach(r=>{
            const n = [r, this._createBundleAssetId(t, r)];
            if (typeof e[r] == "string")
                this.add({
                    alias: n,
                    src: e[r]
                });
            else if (Array.isArray(e[r]))
                this.add({
                    alias: n,
                    src: e[r]
                });
            else {
                const o = e[r]
                  , a = o.src ?? o.srcs;
                this.add({
                    ...o,
                    alias: n,
                    src: Array.isArray(a) ? a : [a]
                })
            }
            i.push(...n)
        }
        ),
        this._bundles[t] = i
    }
    add(t, e, i, r, n) {
        const o = [];
        typeof t == "string" || Array.isArray(t) && typeof t[0] == "string" ? (Et("7.2.0", `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`),
        o.push({
            alias: t,
            src: e,
            data: i,
            format: r,
            loadParser: n
        })) : Array.isArray(t) ? o.push(...t) : o.push(t);
        let a;
        a = l=>{
            this.hasKey(l) && console.warn(`[Resolver] already has key: ${l} overwriting`)
        }
        ,
        ir(o).forEach(l=>{
            const {src: h, srcs: u} = l;
            let {data: c, format: d, loadParser: f} = l;
            const p = ir(h || u).map(_=>typeof _ == "string" ? hb(_) : Array.isArray(_) ? _ : [_])
              , m = this.getAlias(l);
            Array.isArray(m) ? m.forEach(a) : a(m);
            const g = [];
            p.forEach(_=>{
                _.forEach(x=>{
                    let y = {};
                    if (typeof x != "object") {
                        y.src = x;
                        for (let v = 0; v < this._parsers.length; v++) {
                            const E = this._parsers[v];
                            if (E.test(x)) {
                                y = E.parse(x);
                                break
                            }
                        }
                    } else
                        c = x.data ?? c,
                        d = x.format ?? d,
                        f = x.loadParser ?? f,
                        y = {
                            ...y,
                            ...x
                        };
                    if (!m)
                        throw new Error(`[Resolver] alias is undefined for this asset: ${y.src}`);
                    y = this.buildResolvedAsset(y, {
                        aliases: m,
                        data: c,
                        format: d,
                        loadParser: f
                    }),
                    g.push(y)
                }
                )
            }
            ),
            m.forEach(_=>{
                this._assetMap[_] = g
            }
            )
        }
        )
    }
    resolveBundle(t) {
        const e = Gl(t);
        t = ir(t);
        const i = {};
        return t.forEach(r=>{
            const n = this._bundles[r];
            if (n) {
                const o = this.resolve(n)
                  , a = {};
                for (const l in o) {
                    const h = o[l];
                    a[this._extractAssetIdFromBundle(r, l)] = h
                }
                i[r] = a
            }
        }
        ),
        e ? i[t[0]] : i
    }
    resolveUrl(t) {
        const e = this.resolve(t);
        if (typeof t != "string") {
            const i = {};
            for (const r in e)
                i[r] = e[r].src;
            return i
        }
        return e.src
    }
    resolve(t) {
        const e = Gl(t);
        t = ir(t);
        const i = {};
        return t.forEach(r=>{
            if (!this._resolverHash[r])
                if (this._assetMap[r]) {
                    let n = this._assetMap[r];
                    const o = n[0]
                      , a = this._getPreferredOrder(n);
                    a?.priority.forEach(l=>{
                        a.params[l].forEach(h=>{
                            const u = n.filter(c=>c[l] ? c[l] === h : !1);
                            u.length && (n = u)
                        }
                        )
                    }
                    ),
                    this._resolverHash[r] = n[0] ?? o
                } else
                    this._resolverHash[r] = this.buildResolvedAsset({
                        alias: [r],
                        src: r
                    }, {});
            i[r] = this._resolverHash[r]
        }
        ),
        e ? i[t[0]] : i
    }
    hasKey(t) {
        return !!this._assetMap[t]
    }
    hasBundle(t) {
        return !!this._bundles[t]
    }
    _getPreferredOrder(t) {
        for (let e = 0; e < t.length; e++) {
            const i = t[0]
              , r = this._preferredOrder.find(n=>n.params.format.includes(i.format));
            if (r)
                return r
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams)
            return t;
        const e = /\?/.test(t) ? "&" : "?";
        return `${t}${e}${this._defaultSearchParams}`
    }
    buildResolvedAsset(t, e) {
        const {aliases: i, data: r, loadParser: n, format: o} = e;
        return (this._basePath || this._rootPath) && (t.src = Ee.toAbsolute(t.src, this._basePath, this._rootPath)),
        t.alias = i ?? t.alias ?? [t.src],
        t.src = this._appendDefaultSearchParams(t.src),
        t.data = {
            ...r || {},
            ...t.data
        },
        t.loadParser = n ?? t.loadParser,
        t.format = o ?? Ee.extname(t.src).slice(1),
        t.srcs = t.src,
        t.name = t.alias,
        t
    }
}
class yb {
    constructor() {
        this._detections = [],
        this._initialized = !1,
        this.resolver = new yR,
        this.loader = new QI,
        this.cache = ks,
        this._backgroundLoader = new KI(this.loader),
        this._backgroundLoader.active = !0,
        this.reset()
    }
    async init(t={}) {
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
            return
        }
        if (this._initialized = !0,
        t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams),
        t.basePath && (this.resolver.basePath = t.basePath),
        t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier),
        t.manifest) {
            let n = t.manifest;
            typeof n == "string" && (n = await this.load(n)),
            this.resolver.addManifest(n)
        }
        const e = t.texturePreference?.resolution ?? 1
          , i = typeof e == "number" ? [e] : e
          , r = await this._detectFormats({
            preferredFormats: t.texturePreference?.format,
            skipDetections: t.skipDetections,
            detections: this._detections
        });
        this.resolver.prefer({
            params: {
                format: r,
                resolution: i
            }
        }),
        t.preferences && this.setPreferences(t.preferences)
    }
    add(t, e, i, r, n) {
        this.resolver.add(t, e, i, r, n)
    }
    async load(t, e) {
        this._initialized || await this.init();
        const i = Gl(t)
          , r = ir(t).map(a=>{
            if (typeof a != "string") {
                const l = this.resolver.getAlias(a);
                return l.some(h=>!this.resolver.hasKey(h)) && this.add(a),
                Array.isArray(l) ? l[0] : l
            }
            return this.resolver.hasKey(a) || this.add({
                alias: a,
                src: a
            }),
            a
        }
        )
          , n = this.resolver.resolve(r)
          , o = await this._mapLoadToResolve(n, e);
        return i ? o[r[0]] : o
    }
    addBundle(t, e) {
        this.resolver.addBundle(t, e)
    }
    async loadBundle(t, e) {
        this._initialized || await this.init();
        let i = !1;
        typeof t == "string" && (i = !0,
        t = [t]);
        const r = this.resolver.resolveBundle(t)
          , n = {}
          , o = Object.keys(r);
        let a = 0
          , l = 0;
        const h = ()=>{
            e?.(++a / l)
        }
          , u = o.map(c=>{
            const d = r[c];
            return l += Object.keys(d).length,
            this._mapLoadToResolve(d, h).then(f=>{
                n[c] = f
            }
            )
        }
        );
        return await Promise.all(u),
        i ? n[t[0]] : n
    }
    async backgroundLoad(t) {
        this._initialized || await this.init(),
        typeof t == "string" && (t = [t]);
        const e = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(e))
    }
    async backgroundLoadBundle(t) {
        this._initialized || await this.init(),
        typeof t == "string" && (t = [t]);
        const e = this.resolver.resolveBundle(t);
        Object.values(e).forEach(i=>{
            this._backgroundLoader.add(Object.values(i))
        }
        )
    }
    reset() {
        this.resolver.reset(),
        this.loader.reset(),
        this.cache.reset(),
        this._initialized = !1
    }
    get(t) {
        if (typeof t == "string")
            return ks.get(t);
        const e = {};
        for (let i = 0; i < t.length; i++)
            e[i] = ks.get(t[i]);
        return e
    }
    async _mapLoadToResolve(t, e) {
        const i = Object.values(t)
          , r = Object.keys(t);
        this._backgroundLoader.active = !1;
        const n = await this.loader.load(i, e);
        this._backgroundLoader.active = !0;
        const o = {};
        return i.forEach((a,l)=>{
            const h = n[a.src]
              , u = [a.src];
            a.alias && u.push(...a.alias),
            o[r[l]] = h,
            ks.set(u, h)
        }
        ),
        o
    }
    async unload(t) {
        this._initialized || await this.init();
        const e = ir(t).map(r=>typeof r != "string" ? r.src : r)
          , i = this.resolver.resolve(e);
        await this._unloadFromResolved(i)
    }
    async unloadBundle(t) {
        this._initialized || await this.init(),
        t = ir(t);
        const e = this.resolver.resolveBundle(t)
          , i = Object.keys(e).map(r=>this._unloadFromResolved(e[r]));
        await Promise.all(i)
    }
    async _unloadFromResolved(t) {
        const e = Object.values(t);
        e.forEach(i=>{
            ks.remove(i.src)
        }
        ),
        await this.loader.unload(e)
    }
    async _detectFormats(t) {
        let e = [];
        t.preferredFormats && (e = Array.isArray(t.preferredFormats) ? t.preferredFormats : [t.preferredFormats]);
        for (const i of t.detections)
            t.skipDetections || await i.test() ? e = await i.add(e) : t.skipDetections || (e = await i.remove(e));
        return e = e.filter((i,r)=>e.indexOf(i) === r),
        e
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return Jl.config.preferWorkers
    }
    set preferWorkers(t) {
        Et("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."),
        this.setPreferences({
            preferWorkers: t
        })
    }
    setPreferences(t) {
        this.loader.parsers.forEach(e=>{
            e.config && Object.keys(e.config).filter(i=>i in t).forEach(i=>{
                e.config[i] = t[i]
            }
            )
        }
        )
    }
}
const Ga = new yb;
ct.handleByList(it.LoadParser, Ga.loader.parsers).handleByList(it.ResolveParser, Ga.resolver.parsers).handleByList(it.CacheParser, Ga.cache.parsers).handleByList(it.DetectionParser, Ga.detections);
const vb = {
    extension: it.CacheParser,
    test: s=>Array.isArray(s) && s.every(t=>t instanceof st),
    getCacheableAssets: (s,t)=>{
        const e = {};
        return s.forEach(i=>{
            t.forEach((r,n)=>{
                e[i + (n === 0 ? "" : n + 1)] = r
            }
            )
        }
        ),
        e
    }
};
ct.add(vb);
async function xb(s) {
    if ("Image"in globalThis)
        return new Promise(t=>{
            const e = new Image;
            e.onload = ()=>{
                t(!0)
            }
            ,
            e.onerror = ()=>{
                t(!1)
            }
            ,
            e.src = s
        }
        );
    if ("createImageBitmap"in globalThis && "fetch"in globalThis) {
        try {
            const t = await (await fetch(s)).blob();
            await createImageBitmap(t)
        } catch {
            return !1
        }
        return !0
    }
    return !1
}
const bb = {
    extension: {
        type: it.DetectionParser,
        priority: 1
    },
    test: async()=>xb("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
    add: async s=>[...s, "avif"],
    remove: async s=>s.filter(t=>t !== "avif")
};
ct.add(bb);
const wb = {
    extension: {
        type: it.DetectionParser,
        priority: 0
    },
    test: async()=>xb("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
    add: async s=>[...s, "webp"],
    remove: async s=>s.filter(t=>t !== "webp")
};
ct.add(wb);
const ry = ["png", "jpg", "jpeg"]
  , Eb = {
    extension: {
        type: it.DetectionParser,
        priority: -1
    },
    test: ()=>Promise.resolve(!0),
    add: async s=>[...s, ...ry],
    remove: async s=>s.filter(t=>!ry.includes(t))
};
ct.add(Eb);
const vR = "WorkerGlobalScope"in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function fg(s) {
    return vR ? !1 : document.createElement("video").canPlayType(s) !== ""
}
const Tb = {
    extension: {
        type: it.DetectionParser,
        priority: 0
    },
    test: async()=>fg("video/webm"),
    add: async s=>[...s, "webm"],
    remove: async s=>s.filter(t=>t !== "webm")
};
ct.add(Tb);
const Db = {
    extension: {
        type: it.DetectionParser,
        priority: 0
    },
    test: async()=>fg("video/mp4"),
    add: async s=>[...s, "mp4", "m4v"],
    remove: async s=>s.filter(t=>t !== "mp4" && t !== "m4v")
};
ct.add(Db);
const Ab = {
    extension: {
        type: it.DetectionParser,
        priority: 0
    },
    test: async()=>fg("video/ogg"),
    add: async s=>[...s, "ogv"],
    remove: async s=>s.filter(t=>t !== "ogv")
};
ct.add(Ab);
const Sb = {
    extension: it.ResolveParser,
    test: Jl.test,
    parse: s=>({
        resolution: parseFloat(nt.RETINA_PREFIX.exec(s)?.[1] ?? "1"),
        format: Ee.extname(s).slice(1),
        src: s
    })
};
ct.add(Sb);
var Fe = (s=>(s[s.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
s[s.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
s[s.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
s[s.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
s[s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
s[s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
s[s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
s[s.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
s[s.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
s[s.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
s[s.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
s[s.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
s[s.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
s[s.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
s[s.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
s[s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
s[s.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
s[s.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
s[s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
s[s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
s[s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
s[s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
s[s.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL",
s[s.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL",
s[s.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
s[s.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",
s[s.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
s[s.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT",
s[s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",
s[s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",
s[s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",
s))(Fe || {});
const Hl = {
    33776: .5,
    33777: .5,
    33778: 1,
    33779: 1,
    35916: .5,
    35917: .5,
    35918: 1,
    35919: 1,
    37488: .5,
    37489: .5,
    37490: 1,
    37491: 1,
    37492: .5,
    37496: 1,
    37493: .5,
    37497: 1,
    37494: .5,
    37495: .5,
    35840: .5,
    35842: .5,
    35841: .25,
    35843: .25,
    36196: .5,
    35986: .5,
    35987: 1,
    34798: 1,
    37808: 1,
    36492: 1,
    36493: 1,
    36494: 1,
    36495: 1
};
let kr, _o;
function sy() {
    _o = {
        s3tc: kr.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: kr.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: kr.getExtension("WEBGL_compressed_texture_etc"),
        etc1: kr.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: kr.getExtension("WEBGL_compressed_texture_pvrtc") || kr.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: kr.getExtension("WEBGL_compressed_texture_atc"),
        astc: kr.getExtension("WEBGL_compressed_texture_astc"),
        bptc: kr.getExtension("EXT_texture_compression_bptc")
    }
}
const Cb = {
    extension: {
        type: it.DetectionParser,
        priority: 2
    },
    test: async()=>{
        const s = nt.ADAPTER.createCanvas().getContext("webgl");
        return s ? (kr = s,
        !0) : (console.warn("WebGL not available for compressed textures."),
        !1)
    }
    ,
    add: async s=>{
        _o || sy();
        const t = [];
        for (const e in _o)
            _o[e] && t.push(e);
        return [...t, ...s]
    }
    ,
    remove: async s=>(_o || sy(),
    s.filter(t=>!(t in _o)))
};
ct.add(Cb);
class Pb extends jl {
    constructor(t, e={
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let i, r;
        typeof t == "string" ? (i = t,
        r = new Uint8Array) : (i = null,
        r = t),
        super(r, e),
        this.origin = i,
        this.buffer = r ? new Ju(r) : null,
        this._load = null,
        this.loaded = !1,
        this.origin !== null && e.autoLoad !== !1 && this.load(),
        this.origin === null && this.buffer && (this._load = Promise.resolve(this),
        this.loaded = !0,
        this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(t) {}
    load() {
        return this._load ? this._load : (this._load = fetch(this.origin).then(t=>t.blob()).then(t=>t.arrayBuffer()).then(t=>(this.data = new Uint32Array(t),
        this.buffer = new Ju(t),
        this.loaded = !0,
        this.onBlobLoaded(t),
        this.update(),
        this)),
        this._load)
    }
}
class qs extends Pb {
    constructor(t, e) {
        super(t, e),
        this.format = e.format,
        this.levels = e.levels || 1,
        this._width = e.width,
        this._height = e.height,
        this._extension = qs._formatToExtension(this.format),
        (e.levelBuffers || this.buffer) && (this._levelBuffers = e.levelBuffers || qs._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(t, e, i) {
        const r = t.gl;
        if (!t.context.extensions[this._extension])
            throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers)
            return !1;
        r.pixelStorei(r.UNPACK_ALIGNMENT, 4);
        for (let n = 0, o = this.levels; n < o; n++) {
            const {levelID: a, levelWidth: l, levelHeight: h, levelBuffer: u} = this._levelBuffers[n];
            r.compressedTexImage2D(r.TEXTURE_2D, a, this.format, l, h, 0, u)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = qs._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779)
            return "s3tc";
        if (t >= 35916 && t <= 35919)
            return "s3tc_sRGB";
        if (t >= 37488 && t <= 37497)
            return "etc";
        if (t >= 35840 && t <= 35843)
            return "pvrtc";
        if (t === 36196)
            return "etc1";
        if (t === 35986 || t === 35987 || t === 34798)
            return "atc";
        if (t >= 36492 && t <= 36495)
            return "bptc";
        if (t === 37808)
            return "astc";
        throw new Error(`Invalid (compressed) texture format given: ${t}`)
    }
    static _createLevelBuffers(t, e, i, r, n, o, a) {
        const l = new Array(i);
        let h = t.byteOffset
          , u = o
          , c = a
          , d = u + r - 1 & ~(r - 1)
          , f = c + n - 1 & ~(n - 1)
          , p = d * f * Hl[e];
        for (let m = 0; m < i; m++)
            l[m] = {
                levelID: m,
                levelWidth: i > 1 ? u : d,
                levelHeight: i > 1 ? c : f,
                levelBuffer: new Uint8Array(t.buffer,h,p)
            },
            h += p,
            u = u >> 1 || 1,
            c = c >> 1 || 1,
            d = u + r - 1 & ~(r - 1),
            f = c + n - 1 & ~(n - 1),
            p = d * f * Hl[e];
        return l
    }
}
const Vd = 4
  , zh = 124
  , xR = 32
  , ny = 20
  , bR = 542327876
  , Vh = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19
}
  , wR = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7
}
  , Xh = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
}
  , ER = 1
  , TR = 2
  , DR = 4
  , AR = 64
  , SR = 512
  , CR = 131072
  , PR = 827611204
  , IR = 861165636
  , RR = 894720068
  , MR = 808540228
  , FR = 4
  , BR = {
    [PR]: Fe.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [IR]: Fe.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [RR]: Fe.COMPRESSED_RGBA_S3TC_DXT5_EXT
}
  , OR = {
    70: Fe.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    71: Fe.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    73: Fe.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    74: Fe.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    76: Fe.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    77: Fe.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    72: Fe.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    75: Fe.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    78: Fe.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
    96: Fe.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
    95: Fe.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
    98: Fe.COMPRESSED_RGBA_BPTC_UNORM_EXT,
    99: Fe.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
};
function Ib(s) {
    const t = new Uint32Array(s);
    if (t[0] !== bR)
        throw new Error("Invalid DDS file magic word");
    const e = new Uint32Array(s,0,zh / Uint32Array.BYTES_PER_ELEMENT)
      , i = e[Vh.HEIGHT]
      , r = e[Vh.WIDTH]
      , n = e[Vh.MIPMAP_COUNT]
      , o = new Uint32Array(s,Vh.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,xR / Uint32Array.BYTES_PER_ELEMENT)
      , a = o[ER];
    if (a & DR) {
        const l = o[wR.FOURCC];
        if (l !== MR) {
            const x = BR[l]
              , y = Vd + zh
              , v = new Uint8Array(s,y);
            return [new qs(v,{
                format: x,
                width: r,
                height: i,
                levels: n
            })]
        }
        const h = Vd + zh
          , u = new Uint32Array(t.buffer,h,ny / Uint32Array.BYTES_PER_ELEMENT)
          , c = u[Xh.DXGI_FORMAT]
          , d = u[Xh.RESOURCE_DIMENSION]
          , f = u[Xh.MISC_FLAG]
          , p = u[Xh.ARRAY_SIZE]
          , m = OR[c];
        if (m === void 0)
            throw new Error(`DDSParser cannot parse texture data with DXGI format ${c}`);
        if (f === FR)
            throw new Error("DDSParser does not support cubemap textures");
        if (d === 6)
            throw new Error("DDSParser does not supported 3D texture data");
        const g = new Array
          , _ = Vd + zh + ny;
        if (p === 1)
            g.push(new Uint8Array(s,_));
        else {
            const x = Hl[m];
            let y = 0
              , v = r
              , E = i;
            for (let w = 0; w < n; w++) {
                const A = Math.max(1, v + 3 & -4)
                  , I = Math.max(1, E + 3 & -4)
                  , F = A * I * x;
                y += F,
                v = v >>> 1,
                E = E >>> 1
            }
            let P = _;
            for (let w = 0; w < p; w++)
                g.push(new Uint8Array(s,P,y)),
                P += y
        }
        return g.map(x=>new qs(x,{
            format: m,
            width: r,
            height: i,
            levels: n
        }))
    }
    throw a & AR ? new Error("DDSParser does not support uncompressed texture data.") : a & SR ? new Error("DDSParser does not supported YUV uncompressed texture data.") : a & CR ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : a & TR ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const oy = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
  , kR = 67305985
  , fr = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
}
  , Tp = 64
  , Dp = {
    [ft.UNSIGNED_BYTE]: 1,
    [ft.UNSIGNED_SHORT]: 2,
    [ft.INT]: 4,
    [ft.UNSIGNED_INT]: 4,
    [ft.FLOAT]: 4,
    [ft.HALF_FLOAT]: 8
}
  , Rb = {
    [J.RGBA]: 4,
    [J.RGB]: 3,
    [J.RG]: 2,
    [J.RED]: 1,
    [J.LUMINANCE]: 1,
    [J.LUMINANCE_ALPHA]: 2,
    [J.ALPHA]: 1
}
  , Mb = {
    [ft.UNSIGNED_SHORT_4_4_4_4]: 2,
    [ft.UNSIGNED_SHORT_5_5_5_1]: 2,
    [ft.UNSIGNED_SHORT_5_6_5]: 2
};
function Fb(s, t, e=!1) {
    const i = new DataView(t);
    if (!LR(s, i))
        return null;
    const r = i.getUint32(fr.ENDIANNESS, !0) === kR
      , n = i.getUint32(fr.GL_TYPE, r)
      , o = i.getUint32(fr.GL_FORMAT, r)
      , a = i.getUint32(fr.GL_INTERNAL_FORMAT, r)
      , l = i.getUint32(fr.PIXEL_WIDTH, r)
      , h = i.getUint32(fr.PIXEL_HEIGHT, r) || 1
      , u = i.getUint32(fr.PIXEL_DEPTH, r) || 1
      , c = i.getUint32(fr.NUMBER_OF_ARRAY_ELEMENTS, r) || 1
      , d = i.getUint32(fr.NUMBER_OF_FACES, r)
      , f = i.getUint32(fr.NUMBER_OF_MIPMAP_LEVELS, r)
      , p = i.getUint32(fr.BYTES_OF_KEY_VALUE_DATA, r);
    if (h === 0 || u !== 1)
        throw new Error("Only 2D textures are supported");
    if (d !== 1)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (c !== 1)
        throw new Error("WebGL does not support array textures");
    const m = 4
      , g = 4
      , _ = l + 3 & -4
      , x = h + 3 & -4
      , y = new Array(c);
    let v = l * h;
    n === 0 && (v = _ * x);
    let E;
    if (n !== 0 ? Dp[n] ? E = Dp[n] * Rb[o] : E = Mb[n] : E = Hl[a],
    E === void 0)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const P = e ? UR(i, p, r) : null;
    let w = v * E
      , A = l
      , I = h
      , F = _
      , O = x
      , B = Tp + p;
    for (let S = 0; S < f; S++) {
        const T = i.getUint32(B, r);
        let M = B + 4;
        for (let D = 0; D < c; D++) {
            let C = y[D];
            C || (C = y[D] = new Array(f)),
            C[S] = {
                levelID: S,
                levelWidth: f > 1 || n !== 0 ? A : F,
                levelHeight: f > 1 || n !== 0 ? I : O,
                levelBuffer: new Uint8Array(t,M,w)
            },
            M += w
        }
        B += T + 4,
        B = B % 4 !== 0 ? B + 4 - B % 4 : B,
        A = A >> 1 || 1,
        I = I >> 1 || 1,
        F = A + m - 1 & ~(m - 1),
        O = I + g - 1 & ~(g - 1),
        w = F * O * E
    }
    return n !== 0 ? {
        uncompressed: y.map(S=>{
            let T = S[0].levelBuffer
              , M = !1;
            return n === ft.FLOAT ? T = new Float32Array(S[0].levelBuffer.buffer,S[0].levelBuffer.byteOffset,S[0].levelBuffer.byteLength / 4) : n === ft.UNSIGNED_INT ? (M = !0,
            T = new Uint32Array(S[0].levelBuffer.buffer,S[0].levelBuffer.byteOffset,S[0].levelBuffer.byteLength / 4)) : n === ft.INT && (M = !0,
            T = new Int32Array(S[0].levelBuffer.buffer,S[0].levelBuffer.byteOffset,S[0].levelBuffer.byteLength / 4)),
            {
                resource: new jl(T,{
                    width: S[0].levelWidth,
                    height: S[0].levelHeight
                }),
                type: n,
                format: M ? NR(o) : o
            }
        }
        ),
        kvData: P
    } : {
        compressed: y.map(S=>new qs(null,{
            format: a,
            width: l,
            height: h,
            levels: f,
            levelBuffers: S
        })),
        kvData: P
    }
}
function LR(s, t) {
    for (let e = 0; e < oy.length; e++)
        if (t.getUint8(e) !== oy[e])
            return console.error(`${s} is not a valid *.ktx file!`),
            !1;
    return !0
}
function NR(s) {
    switch (s) {
    case J.RGBA:
        return J.RGBA_INTEGER;
    case J.RGB:
        return J.RGB_INTEGER;
    case J.RG:
        return J.RG_INTEGER;
    case J.RED:
        return J.RED_INTEGER;
    default:
        return s
    }
}
function UR(s, t, e) {
    const i = new Map;
    let r = 0;
    for (; r < t; ) {
        const n = s.getUint32(Tp + r, e)
          , o = Tp + r + 4
          , a = 3 - (n + 3) % 4;
        if (n === 0 || n > t - r) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let l = 0;
        for (; l < n && s.getUint8(o + l) !== 0; l++)
            ;
        if (l === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const h = new TextDecoder().decode(new Uint8Array(s.buffer,o,l))
          , u = new DataView(s.buffer,o + l + 1,n - l - 1);
        i.set(h, u),
        r += 4 + n + a
    }
    return i
}
const Bb = {
    extension: {
        type: it.LoadParser,
        priority: hr.High
    },
    name: "loadDDS",
    test(s) {
        return Ds(s, ".dds")
    },
    async load(s, t, e) {
        const i = await (await nt.ADAPTER.fetch(s)).arrayBuffer()
          , r = Ib(i).map(n=>{
            const o = new At(n,{
                mipmap: Ar.OFF,
                alphaMode: _i.NO_PREMULTIPLIED_ALPHA,
                resolution: is(s),
                ...t.data
            });
            return la(o, e, s)
        }
        );
        return r.length === 1 ? r[0] : r
    },
    unload(s) {
        Array.isArray(s) ? s.forEach(t=>t.destroy(!0)) : s.destroy(!0)
    }
};
ct.add(Bb);
const Ob = {
    extension: {
        type: it.LoadParser,
        priority: hr.High
    },
    name: "loadKTX",
    test(s) {
        return Ds(s, ".ktx")
    },
    async load(s, t, e) {
        const i = await (await nt.ADAPTER.fetch(s)).arrayBuffer()
          , {compressed: r, uncompressed: n, kvData: o} = Fb(s, i)
          , a = r ?? n
          , l = {
            mipmap: Ar.OFF,
            alphaMode: _i.NO_PREMULTIPLIED_ALPHA,
            resolution: is(s),
            ...t.data
        }
          , h = a.map(u=>{
            a === n && Object.assign(l, {
                type: u.type,
                format: u.format
            });
            const c = u.resource ?? u
              , d = new At(c,l);
            return d.ktxKeyValueData = o,
            la(d, e, s)
        }
        );
        return h.length === 1 ? h[0] : h
    },
    unload(s) {
        Array.isArray(s) ? s.forEach(t=>t.destroy(!0)) : s.destroy(!0)
    }
};
ct.add(Ob);
const kb = {
    extension: it.ResolveParser,
    test: s=>{
        const t = Ee.extname(s).slice(1);
        return ["basis", "ktx", "dds"].includes(t)
    }
    ,
    parse: s=>{
        const t = Ee.extname(s).slice(1);
        if (t === "ktx") {
            const e = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx", ".bptc.ktx"];
            if (e.some(i=>s.endsWith(i)))
                return {
                    resolution: parseFloat(nt.RETINA_PREFIX.exec(s)?.[1] ?? "1"),
                    format: e.find(i=>s.endsWith(i)),
                    src: s
                }
        }
        return {
            resolution: parseFloat(nt.RETINA_PREFIX.exec(s)?.[1] ?? "1"),
            format: t,
            src: s
        }
    }
};
ct.add(kb);
const Wh = new St
  , GR = 4
  , Lb = class Ha {
    constructor(t) {
        this.renderer = t,
        this._rendererPremultipliedAlpha = !1
    }
    contextChange() {
        const t = this.renderer?.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
    }
    async image(t, e, i, r) {
        const n = new Image;
        return n.src = await this.base64(t, e, i, r),
        n
    }
    async base64(t, e, i, r) {
        const n = this.canvas(t, r);
        if (n.toBlob !== void 0)
            return new Promise((o,a)=>{
                n.toBlob(l=>{
                    if (!l) {
                        a(new Error("ICanvas.toBlob failed!"));
                        return
                    }
                    const h = new FileReader;
                    h.onload = ()=>o(h.result),
                    h.onerror = a,
                    h.readAsDataURL(l)
                }
                , e, i)
            }
            );
        if (n.toDataURL !== void 0)
            return n.toDataURL(e, i);
        if (n.convertToBlob !== void 0) {
            const o = await n.convertToBlob({
                type: e,
                quality: i
            });
            return new Promise((a,l)=>{
                const h = new FileReader;
                h.onload = ()=>a(h.result),
                h.onerror = l,
                h.readAsDataURL(o)
            }
            )
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
    }
    canvas(t, e) {
        const {pixels: i, width: r, height: n, flipY: o, premultipliedAlpha: a} = this._rawPixels(t, e);
        o && Ha._flipY(i, r, n),
        a && Ha._unpremultiplyAlpha(i);
        const l = new c1(r,n,1)
          , h = new ImageData(new Uint8ClampedArray(i.buffer),r,n);
        return l.context.putImageData(h, 0, 0),
        l.canvas
    }
    pixels(t, e) {
        const {pixels: i, width: r, height: n, flipY: o, premultipliedAlpha: a} = this._rawPixels(t, e);
        return o && Ha._flipY(i, r, n),
        a && Ha._unpremultiplyAlpha(i),
        i
    }
    _rawPixels(t, e) {
        const i = this.renderer;
        if (!i)
            throw new Error("The Extract has already been destroyed");
        let r, n = !1, o = !1, a, l = !1;
        t && (t instanceof nn ? a = t : (a = i.generateTexture(t, {
            region: e,
            resolution: i.resolution,
            multisample: i.multisample
        }),
        l = !0,
        e && (Wh.width = e.width,
        Wh.height = e.height,
        e = Wh)));
        const h = i.gl;
        if (a) {
            if (r = a.baseTexture.resolution,
            e = e ?? a.frame,
            n = !1,
            o = a.baseTexture.alphaMode > 0 && a.baseTexture.format === J.RGBA,
            !l) {
                i.renderTexture.bind(a);
                const f = a.framebuffer.glFramebuffers[i.CONTEXT_UID];
                f.blitFramebuffer && i.framebuffer.bind(f.blitFramebuffer)
            }
        } else
            r = i.resolution,
            e || (e = Wh,
            e.width = i.width / r,
            e.height = i.height / r),
            n = !0,
            o = this._rendererPremultipliedAlpha,
            i.renderTexture.bind();
        const u = Math.max(Math.round(e.width * r), 1)
          , c = Math.max(Math.round(e.height * r), 1)
          , d = new Uint8Array(GR * u * c);
        return h.readPixels(Math.round(e.x * r), Math.round(e.y * r), u, c, h.RGBA, h.UNSIGNED_BYTE, d),
        l && a?.destroy(!0),
        {
            pixels: d,
            width: u,
            height: c,
            flipY: n,
            premultipliedAlpha: o
        }
    }
    destroy() {
        this.renderer = null
    }
    static _flipY(t, e, i) {
        const r = e << 2
          , n = i >> 1
          , o = new Uint8Array(r);
        for (let a = 0; a < n; a++) {
            const l = a * r
              , h = (i - a - 1) * r;
            o.set(t.subarray(l, l + r)),
            t.copyWithin(l, h, h + r),
            t.set(o, h)
        }
    }
    static _unpremultiplyAlpha(t) {
        t instanceof Uint8ClampedArray && (t = new Uint8Array(t.buffer));
        const e = t.length;
        for (let i = 0; i < e; i += 4) {
            const r = t[i + 3];
            if (r !== 0) {
                const n = 255.001 / r;
                t[i] = t[i] * n + .5,
                t[i + 1] = t[i + 1] * n + .5,
                t[i + 2] = t[i + 2] * n + .5
            }
        }
    }
}
;
Lb.extension = {
    name: "extract",
    type: it.RendererSystem
};
let Nb = Lb;
ct.add(Nb);
const $l = {
    build(s) {
        const t = s.points;
        let e, i, r, n, o, a;
        if (s.type === Ne.CIRC) {
            const p = s.shape;
            e = p.x,
            i = p.y,
            o = a = p.radius,
            r = n = 0
        } else if (s.type === Ne.ELIP) {
            const p = s.shape;
            e = p.x,
            i = p.y,
            o = p.width,
            a = p.height,
            r = n = 0
        } else {
            const p = s.shape
              , m = p.width / 2
              , g = p.height / 2;
            e = p.x + m,
            i = p.y + g,
            o = a = Math.max(0, Math.min(p.radius, Math.min(m, g))),
            r = m - o,
            n = g - a
        }
        if (!(o >= 0 && a >= 0 && r >= 0 && n >= 0)) {
            t.length = 0;
            return
        }
        const l = Math.ceil(2.3 * Math.sqrt(o + a))
          , h = l * 8 + (r ? 4 : 0) + (n ? 4 : 0);
        if (t.length = h,
        h === 0)
            return;
        if (l === 0) {
            t.length = 8,
            t[0] = t[6] = e + r,
            t[1] = t[3] = i + n,
            t[2] = t[4] = e - r,
            t[5] = t[7] = i - n;
            return
        }
        let u = 0
          , c = l * 4 + (r ? 2 : 0) + 2
          , d = c
          , f = h;
        {
            const p = r + o
              , m = n
              , g = e + p
              , _ = e - p
              , x = i + m;
            if (t[u++] = g,
            t[u++] = x,
            t[--c] = x,
            t[--c] = _,
            n) {
                const y = i - m;
                t[d++] = _,
                t[d++] = y,
                t[--f] = y,
                t[--f] = g
            }
        }
        for (let p = 1; p < l; p++) {
            const m = Math.PI / 2 * (p / l)
              , g = r + Math.cos(m) * o
              , _ = n + Math.sin(m) * a
              , x = e + g
              , y = e - g
              , v = i + _
              , E = i - _;
            t[u++] = x,
            t[u++] = v,
            t[--c] = v,
            t[--c] = y,
            t[d++] = y,
            t[d++] = E,
            t[--f] = E,
            t[--f] = x
        }
        {
            const p = r
              , m = n + a
              , g = e + p
              , _ = e - p
              , x = i + m
              , y = i - m;
            t[u++] = g,
            t[u++] = x,
            t[--f] = y,
            t[--f] = g,
            r && (t[u++] = _,
            t[u++] = x,
            t[--f] = y,
            t[--f] = _)
        }
    },
    triangulate(s, t) {
        const e = s.points
          , i = t.points
          , r = t.indices;
        if (e.length === 0)
            return;
        let n = i.length / 2;
        const o = n;
        let a, l;
        if (s.type !== Ne.RREC) {
            const u = s.shape;
            a = u.x,
            l = u.y
        } else {
            const u = s.shape;
            a = u.x + u.width / 2,
            l = u.y + u.height / 2
        }
        const h = s.matrix;
        i.push(s.matrix ? h.a * a + h.c * l + h.tx : a, s.matrix ? h.b * a + h.d * l + h.ty : l),
        n++,
        i.push(e[0], e[1]);
        for (let u = 2; u < e.length; u += 2)
            i.push(e[u], e[u + 1]),
            r.push(n++, o, n);
        r.push(o + 1, o, n)
    }
};
function ay(s, t=!1) {
    const e = s.length;
    if (e < 6)
        return;
    let i = 0;
    for (let r = 0, n = s[e - 2], o = s[e - 1]; r < e; r += 2) {
        const a = s[r]
          , l = s[r + 1];
        i += (a - n) * (l + o),
        n = a,
        o = l
    }
    if (!t && i > 0 || t && i <= 0) {
        const r = e / 2;
        for (let n = r + r % 2; n < e; n += 2) {
            const o = e - n - 2
              , a = e - n - 1
              , l = n
              , h = n + 1;
            [s[o],s[l]] = [s[l], s[o]],
            [s[a],s[h]] = [s[h], s[a]]
        }
    }
}
const pg = {
    build(s) {
        s.points = s.shape.points.slice()
    },
    triangulate(s, t) {
        let e = s.points;
        const i = s.holes
          , r = t.points
          , n = t.indices;
        if (e.length >= 6) {
            ay(e, !1);
            const o = [];
            for (let h = 0; h < i.length; h++) {
                const u = i[h];
                ay(u.points, !0),
                o.push(e.length / 2),
                e = e.concat(u.points)
            }
            const a = Lx(e, o, 2);
            if (!a)
                return;
            const l = r.length / 2;
            for (let h = 0; h < a.length; h += 3)
                n.push(a[h] + l),
                n.push(a[h + 1] + l),
                n.push(a[h + 2] + l);
            for (let h = 0; h < e.length; h++)
                r.push(e[h])
        }
    }
}
  , Ub = {
    build(s) {
        const t = s.shape
          , e = t.x
          , i = t.y
          , r = t.width
          , n = t.height
          , o = s.points;
        o.length = 0,
        r >= 0 && n >= 0 && o.push(e, i, e + r, i, e + r, i + n, e, i + n)
    },
    triangulate(s, t) {
        const e = s.points
          , i = t.points;
        if (e.length === 0)
            return;
        const r = i.length / 2;
        i.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]),
        t.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3)
    }
}
  , Gb = {
    build(s) {
        $l.build(s)
    },
    triangulate(s, t) {
        $l.triangulate(s, t)
    }
};
var Oi = (s=>(s.MITER = "miter",
s.BEVEL = "bevel",
s.ROUND = "round",
s))(Oi || {})
  , _s = (s=>(s.BUTT = "butt",
s.ROUND = "round",
s.SQUARE = "square",
s))(_s || {});
const tn = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(s, t=20) {
        if (!this.adaptive || !s || isNaN(s))
            return t;
        let e = Math.ceil(s / this.maxLength);
        return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments),
        e
    }
}
  , HR = tn;
class Ap {
    static curveTo(t, e, i, r, n, o) {
        const a = o[o.length - 2]
          , l = o[o.length - 1] - e
          , h = a - t
          , u = r - e
          , c = i - t
          , d = Math.abs(l * c - h * u);
        if (d < 1e-8 || n === 0)
            return (o[o.length - 2] !== t || o[o.length - 1] !== e) && o.push(t, e),
            null;
        const f = l * l + h * h
          , p = u * u + c * c
          , m = l * u + h * c
          , g = n * Math.sqrt(f) / d
          , _ = n * Math.sqrt(p) / d
          , x = g * m / f
          , y = _ * m / p
          , v = g * c + _ * h
          , E = g * u + _ * l
          , P = h * (_ + x)
          , w = l * (_ + x)
          , A = c * (g + y)
          , I = u * (g + y)
          , F = Math.atan2(w - E, P - v)
          , O = Math.atan2(I - E, A - v);
        return {
            cx: v + t,
            cy: E + e,
            radius: n,
            startAngle: F,
            endAngle: O,
            anticlockwise: h * u > c * l
        }
    }
    static arc(t, e, i, r, n, o, a, l, h) {
        const u = a - o
          , c = tn._segmentsCount(Math.abs(u) * n, Math.ceil(Math.abs(u) / Fl) * 40)
          , d = u / (c * 2)
          , f = d * 2
          , p = Math.cos(d)
          , m = Math.sin(d)
          , g = c - 1
          , _ = g % 1 / g;
        for (let x = 0; x <= g; ++x) {
            const y = x + _ * x
              , v = d + o + f * y
              , E = Math.cos(v)
              , P = -Math.sin(v);
            h.push((p * E + m * P) * n + i, (p * -P + m * E) * n + r)
        }
    }
}
class Hb {
    constructor() {
        this.reset()
    }
    begin(t, e, i) {
        this.reset(),
        this.style = t,
        this.start = e,
        this.attribStart = i
    }
    end(t, e) {
        this.attribSize = e - this.attribStart,
        this.size = t - this.start
    }
    reset() {
        this.style = null,
        this.size = 0,
        this.start = 0,
        this.attribStart = 0,
        this.attribSize = 0
    }
}
class Bc {
    static curveLength(t, e, i, r, n, o, a, l) {
        let h = 0
          , u = 0
          , c = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0
          , g = 0
          , _ = 0
          , x = 0
          , y = 0
          , v = t
          , E = e;
        for (let P = 1; P <= 10; ++P)
            u = P / 10,
            c = u * u,
            d = c * u,
            f = 1 - u,
            p = f * f,
            m = p * f,
            g = m * t + 3 * p * u * i + 3 * f * c * n + d * a,
            _ = m * e + 3 * p * u * r + 3 * f * c * o + d * l,
            x = v - g,
            y = E - _,
            v = g,
            E = _,
            h += Math.sqrt(x * x + y * y);
        return h
    }
    static curveTo(t, e, i, r, n, o, a) {
        const l = a[a.length - 2]
          , h = a[a.length - 1];
        a.length -= 2;
        const u = tn._segmentsCount(Bc.curveLength(l, h, t, e, i, r, n, o));
        let c = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0;
        a.push(l, h);
        for (let g = 1, _ = 0; g <= u; ++g)
            _ = g / u,
            c = 1 - _,
            d = c * c,
            f = d * c,
            p = _ * _,
            m = p * _,
            a.push(f * l + 3 * d * _ * t + 3 * c * p * i + m * n, f * h + 3 * d * _ * e + 3 * c * p * r + m * o)
    }
}
function ly(s, t, e, i, r, n, o, a) {
    const l = s - e * r
      , h = t - i * r
      , u = s + e * n
      , c = t + i * n;
    let d, f;
    o ? (d = i,
    f = -e) : (d = -i,
    f = e);
    const p = l + d
      , m = h + f
      , g = u + d
      , _ = c + f;
    return a.push(p, m, g, _),
    2
}
function un(s, t, e, i, r, n, o, a) {
    const l = e - s
      , h = i - t;
    let u = Math.atan2(l, h)
      , c = Math.atan2(r - s, n - t);
    a && u < c ? u += Math.PI * 2 : !a && u > c && (c += Math.PI * 2);
    let d = u;
    const f = c - u
      , p = Math.abs(f)
      , m = Math.sqrt(l * l + h * h)
      , g = (15 * p * Math.sqrt(m) / Math.PI >> 0) + 1
      , _ = f / g;
    if (d += _,
    a) {
        o.push(s, t, e, i);
        for (let x = 1, y = d; x < g; x++,
        y += _)
            o.push(s, t, s + Math.sin(y) * m, t + Math.cos(y) * m);
        o.push(s, t, r, n)
    } else {
        o.push(e, i, s, t);
        for (let x = 1, y = d; x < g; x++,
        y += _)
            o.push(s + Math.sin(y) * m, t + Math.cos(y) * m, s, t);
        o.push(r, n, s, t)
    }
    return g * 2
}
function $R(s, t) {
    const e = s.shape;
    let i = s.points || e.points.slice();
    const r = t.closePointEps;
    if (i.length === 0)
        return;
    const n = s.lineStyle
      , o = new Nt(i[0],i[1])
      , a = new Nt(i[i.length - 2],i[i.length - 1])
      , l = e.type !== Ne.POLY || e.closeStroke
      , h = Math.abs(o.x - a.x) < r && Math.abs(o.y - a.y) < r;
    if (l) {
        i = i.slice(),
        h && (i.pop(),
        i.pop(),
        a.set(i[i.length - 2], i[i.length - 1]));
        const C = (o.x + a.x) * .5
          , k = (a.y + o.y) * .5;
        i.unshift(C, k),
        i.push(C, k)
    }
    const u = t.points
      , c = i.length / 2;
    let d = i.length;
    const f = u.length / 2
      , p = n.width / 2
      , m = p * p
      , g = n.miterLimit * n.miterLimit;
    let _ = i[0]
      , x = i[1]
      , y = i[2]
      , v = i[3]
      , E = 0
      , P = 0
      , w = -(x - v)
      , A = _ - y
      , I = 0
      , F = 0
      , O = Math.sqrt(w * w + A * A);
    w /= O,
    A /= O,
    w *= p,
    A *= p;
    const B = n.alignment
      , S = (1 - B) * 2
      , T = B * 2;
    l || (n.cap === _s.ROUND ? d += un(_ - w * (S - T) * .5, x - A * (S - T) * .5, _ - w * S, x - A * S, _ + w * T, x + A * T, u, !0) + 2 : n.cap === _s.SQUARE && (d += ly(_, x, w, A, S, T, !0, u))),
    u.push(_ - w * S, x - A * S, _ + w * T, x + A * T);
    for (let C = 1; C < c - 1; ++C) {
        _ = i[(C - 1) * 2],
        x = i[(C - 1) * 2 + 1],
        y = i[C * 2],
        v = i[C * 2 + 1],
        E = i[(C + 1) * 2],
        P = i[(C + 1) * 2 + 1],
        w = -(x - v),
        A = _ - y,
        O = Math.sqrt(w * w + A * A),
        w /= O,
        A /= O,
        w *= p,
        A *= p,
        I = -(v - P),
        F = y - E,
        O = Math.sqrt(I * I + F * F),
        I /= O,
        F /= O,
        I *= p,
        F *= p;
        const k = y - _
          , R = x - v
          , b = y - E
          , L = P - v
          , U = k * b + R * L
          , Y = R * b - L * k
          , $ = Y < 0;
        if (Math.abs(Y) < .001 * Math.abs(U)) {
            u.push(y - w * S, v - A * S, y + w * T, v + A * T),
            U >= 0 && (n.join === Oi.ROUND ? d += un(y, v, y - w * S, v - A * S, y - I * S, v - F * S, u, !1) + 4 : d += 2,
            u.push(y - I * T, v - F * T, y + I * S, v + F * S));
            continue
        }
        const z = (-w + _) * (-A + v) - (-w + y) * (-A + x)
          , j = (-I + E) * (-F + v) - (-I + y) * (-F + P)
          , W = (k * j - b * z) / Y
          , X = (L * z - R * j) / Y
          , et = (W - y) * (W - y) + (X - v) * (X - v)
          , Q = y + (W - y) * S
          , q = v + (X - v) * S
          , tt = y - (W - y) * T
          , Z = v - (X - v) * T
          , ot = Math.min(k * k + R * R, b * b + L * L)
          , vt = $ ? S : T
          , It = ot + vt * vt * m
          , H = et <= It;
        let Ct = n.join;
        if (Ct === Oi.MITER && et / m > g && (Ct = Oi.BEVEL),
        H)
            switch (Ct) {
            case Oi.MITER:
                {
                    u.push(Q, q, tt, Z);
                    break
                }
            case Oi.BEVEL:
                {
                    $ ? u.push(Q, q, y + w * T, v + A * T, Q, q, y + I * T, v + F * T) : u.push(y - w * S, v - A * S, tt, Z, y - I * S, v - F * S, tt, Z),
                    d += 2;
                    break
                }
            case Oi.ROUND:
                {
                    $ ? (u.push(Q, q, y + w * T, v + A * T),
                    d += un(y, v, y + w * T, v + A * T, y + I * T, v + F * T, u, !0) + 4,
                    u.push(Q, q, y + I * T, v + F * T)) : (u.push(y - w * S, v - A * S, tt, Z),
                    d += un(y, v, y - w * S, v - A * S, y - I * S, v - F * S, u, !1) + 4,
                    u.push(y - I * S, v - F * S, tt, Z));
                    break
                }
            }
        else {
            switch (u.push(y - w * S, v - A * S, y + w * T, v + A * T),
            Ct) {
            case Oi.MITER:
                {
                    $ ? u.push(tt, Z, tt, Z) : u.push(Q, q, Q, q),
                    d += 2;
                    break
                }
            case Oi.ROUND:
                {
                    $ ? d += un(y, v, y + w * T, v + A * T, y + I * T, v + F * T, u, !0) + 2 : d += un(y, v, y - w * S, v - A * S, y - I * S, v - F * S, u, !1) + 2;
                    break
                }
            }
            u.push(y - I * S, v - F * S, y + I * T, v + F * T),
            d += 2
        }
    }
    _ = i[(c - 2) * 2],
    x = i[(c - 2) * 2 + 1],
    y = i[(c - 1) * 2],
    v = i[(c - 1) * 2 + 1],
    w = -(x - v),
    A = _ - y,
    O = Math.sqrt(w * w + A * A),
    w /= O,
    A /= O,
    w *= p,
    A *= p,
    u.push(y - w * S, v - A * S, y + w * T, v + A * T),
    l || (n.cap === _s.ROUND ? d += un(y - w * (S - T) * .5, v - A * (S - T) * .5, y - w * S, v - A * S, y + w * T, v + A * T, u, !1) + 2 : n.cap === _s.SQUARE && (d += ly(y, v, w, A, S, T, !1, u)));
    const M = t.indices
      , D = tn.epsilon * tn.epsilon;
    for (let C = f; C < d + f - 2; ++C)
        _ = u[C * 2],
        x = u[C * 2 + 1],
        y = u[(C + 1) * 2],
        v = u[(C + 1) * 2 + 1],
        E = u[(C + 2) * 2],
        P = u[(C + 2) * 2 + 1],
        !(Math.abs(_ * (v - P) + y * (P - x) + E * (x - v)) < D) && M.push(C, C + 1, C + 2)
}
function zR(s, t) {
    let e = 0;
    const i = s.shape
      , r = s.points || i.points
      , n = i.type !== Ne.POLY || i.closeStroke;
    if (r.length === 0)
        return;
    const o = t.points
      , a = t.indices
      , l = r.length / 2
      , h = o.length / 2;
    let u = h;
    for (o.push(r[0], r[1]),
    e = 1; e < l; e++)
        o.push(r[e * 2], r[e * 2 + 1]),
        a.push(u, u + 1),
        u++;
    n && a.push(u, h)
}
function Sp(s, t) {
    s.lineStyle.native ? zR(s, t) : $R(s, t)
}
class Oc {
    static curveLength(t, e, i, r, n, o) {
        const a = t - 2 * i + n
          , l = e - 2 * r + o
          , h = 2 * i - 2 * t
          , u = 2 * r - 2 * e
          , c = 4 * (a * a + l * l)
          , d = 4 * (a * h + l * u)
          , f = h * h + u * u
          , p = 2 * Math.sqrt(c + d + f)
          , m = Math.sqrt(c)
          , g = 2 * c * m
          , _ = 2 * Math.sqrt(f)
          , x = d / m;
        return (g * p + m * d * (p - _) + (4 * f * c - d * d) * Math.log((2 * m + x + p) / (x + _))) / (4 * g)
    }
    static curveTo(t, e, i, r, n) {
        const o = n[n.length - 2]
          , a = n[n.length - 1]
          , l = tn._segmentsCount(Oc.curveLength(o, a, t, e, i, r));
        let h = 0
          , u = 0;
        for (let c = 1; c <= l; ++c) {
            const d = c / l;
            h = o + (t - o) * d,
            u = a + (e - a) * d,
            n.push(h + (t + (i - t) * d - h) * d, u + (e + (r - e) * d - u) * d)
        }
    }
}
const gu = {
    [Ne.POLY]: pg,
    [Ne.CIRC]: $l,
    [Ne.ELIP]: $l,
    [Ne.RECT]: Ub,
    [Ne.RREC]: Gb
}
  , Cp = []
  , $a = [];
class zl {
    constructor(t, e=null, i=null, r=null) {
        this.points = [],
        this.holes = [],
        this.shape = t,
        this.lineStyle = i,
        this.fillStyle = e,
        this.matrix = r,
        this.type = t.type
    }
    clone() {
        return new zl(this.shape,this.fillStyle,this.lineStyle,this.matrix)
    }
    destroy() {
        this.shape = null,
        this.holes.length = 0,
        this.holes = null,
        this.points.length = 0,
        this.points = null,
        this.lineStyle = null,
        this.fillStyle = null
    }
}
const ao = new Nt
  , $b = class zb extends Nm {
    constructor() {
        super(),
        this.closePointEps = 1e-4,
        this.boundsPadding = 0,
        this.uvsFloat32 = null,
        this.indicesUint16 = null,
        this.batchable = !1,
        this.points = [],
        this.colors = [],
        this.uvs = [],
        this.indices = [],
        this.textureIds = [],
        this.graphicsData = [],
        this.drawCalls = [],
        this.batchDirty = -1,
        this.batches = [],
        this.dirty = 0,
        this.cacheDirty = -1,
        this.clearDirty = 0,
        this.shapeIndex = 0,
        this._bounds = new Nl,
        this.boundsDirty = -1
    }
    get bounds() {
        return this.updateBatches(),
        this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty,
        this.calculateBounds()),
        this._bounds
    }
    invalidate() {
        this.boundsDirty = -1,
        this.dirty++,
        this.batchDirty++,
        this.shapeIndex = 0,
        this.points.length = 0,
        this.colors.length = 0,
        this.uvs.length = 0,
        this.indices.length = 0,
        this.textureIds.length = 0;
        for (let t = 0; t < this.drawCalls.length; t++)
            this.drawCalls[t].texArray.clear(),
            $a.push(this.drawCalls[t]);
        this.drawCalls.length = 0;
        for (let t = 0; t < this.batches.length; t++) {
            const e = this.batches[t];
            e.reset(),
            Cp.push(e)
        }
        this.batches.length = 0
    }
    clear() {
        return this.graphicsData.length > 0 && (this.invalidate(),
        this.clearDirty++,
        this.graphicsData.length = 0),
        this
    }
    drawShape(t, e=null, i=null, r=null) {
        const n = new zl(t,e,i,r);
        return this.graphicsData.push(n),
        this.dirty++,
        this
    }
    drawHole(t, e=null) {
        if (!this.graphicsData.length)
            return null;
        const i = new zl(t,null,null,e)
          , r = this.graphicsData[this.graphicsData.length - 1];
        return i.lineStyle = r.lineStyle,
        r.holes.push(i),
        this.dirty++,
        this
    }
    destroy() {
        super.destroy();
        for (let t = 0; t < this.graphicsData.length; ++t)
            this.graphicsData[t].destroy();
        this.points.length = 0,
        this.points = null,
        this.colors.length = 0,
        this.colors = null,
        this.uvs.length = 0,
        this.uvs = null,
        this.indices.length = 0,
        this.indices = null,
        this.indexBuffer.destroy(),
        this.indexBuffer = null,
        this.graphicsData.length = 0,
        this.graphicsData = null,
        this.drawCalls.length = 0,
        this.drawCalls = null,
        this.batches.length = 0,
        this.batches = null,
        this._bounds = null
    }
    containsPoint(t) {
        const e = this.graphicsData;
        for (let i = 0; i < e.length; ++i) {
            const r = e[i];
            if (r.fillStyle.visible && r.shape && (r.matrix ? r.matrix.applyInverse(t, ao) : ao.copyFrom(t),
            r.shape.contains(ao.x, ao.y))) {
                let n = !1;
                if (r.holes) {
                    for (let o = 0; o < r.holes.length; o++)
                        if (r.holes[o].shape.contains(ao.x, ao.y)) {
                            n = !0;
                            break
                        }
                }
                if (!n)
                    return !0
            }
        }
        return !1
    }
    updateBatches() {
        if (!this.graphicsData.length) {
            this.batchable = !0;
            return
        }
        if (!this.validateBatching())
            return;
        this.cacheDirty = this.dirty;
        const t = this.uvs
          , e = this.graphicsData;
        let i = null
          , r = null;
        this.batches.length > 0 && (i = this.batches[this.batches.length - 1],
        r = i.style);
        for (let l = this.shapeIndex; l < e.length; l++) {
            this.shapeIndex++;
            const h = e[l]
              , u = h.fillStyle
              , c = h.lineStyle;
            gu[h.type].build(h),
            h.matrix && this.transformPoints(h.points, h.matrix),
            (u.visible || c.visible) && this.processHoles(h.holes);
            for (let d = 0; d < 2; d++) {
                const f = d === 0 ? u : c;
                if (!f.visible)
                    continue;
                const p = f.texture.baseTexture
                  , m = this.indices.length
                  , g = this.points.length / 2;
                p.wrapMode = Jr.REPEAT,
                d === 0 ? this.processFill(h) : this.processLine(h);
                const _ = this.points.length / 2 - g;
                _ !== 0 && (i && !this._compareStyles(r, f) && (i.end(m, g),
                i = null),
                i || (i = Cp.pop() || new Hb,
                i.begin(f, m, g),
                this.batches.push(i),
                r = f),
                this.addUvs(this.points, t, f.texture, g, _, f.matrix))
            }
        }
        const n = this.indices.length
          , o = this.points.length / 2;
        if (i && i.end(n, o),
        this.batches.length === 0) {
            this.batchable = !0;
            return
        }
        const a = o > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && a === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = a ? new Uint32Array(this.indices) : new Uint16Array(this.indices),
        this.batchable = this.isBatchable(),
        this.batchable ? this.packBatches() : this.buildDrawCalls()
    }
    _compareStyles(t, e) {
        return !(!t || !e || t.texture.baseTexture !== e.texture.baseTexture || t.color + t.alpha !== e.color + e.alpha || !!t.native != !!e.native)
    }
    validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length)
            return !1;
        for (let t = 0, e = this.graphicsData.length; t < e; t++) {
            const i = this.graphicsData[t]
              , r = i.fillStyle
              , n = i.lineStyle;
            if (r && !r.texture.baseTexture.valid || n && !n.texture.baseTexture.valid)
                return !1
        }
        return !0
    }
    packBatches() {
        this.batchDirty++,
        this.uvsFloat32 = new Float32Array(this.uvs);
        const t = this.batches;
        for (let e = 0, i = t.length; e < i; e++) {
            const r = t[e];
            for (let n = 0; n < r.size; n++) {
                const o = r.start + n;
                this.indicesUint16[o] = this.indicesUint16[o] - r.attribStart
            }
        }
    }
    isBatchable() {
        if (this.points.length > 65535 * 2)
            return !1;
        const t = this.batches;
        for (let e = 0; e < t.length; e++)
            if (t[e].style.native)
                return !1;
        return this.points.length < zb.BATCHABLE_SIZE * 2
    }
    buildDrawCalls() {
        let t = ++At._globalBatch;
        for (let c = 0; c < this.drawCalls.length; c++)
            this.drawCalls[c].texArray.clear(),
            $a.push(this.drawCalls[c]);
        this.drawCalls.length = 0;
        const e = this.colors
          , i = this.textureIds;
        let r = $a.pop();
        r || (r = new ec,
        r.texArray = new ic),
        r.texArray.count = 0,
        r.start = 0,
        r.size = 0,
        r.type = xr.TRIANGLES;
        let n = 0
          , o = null
          , a = 0
          , l = !1
          , h = xr.TRIANGLES
          , u = 0;
        this.drawCalls.push(r);
        for (let c = 0; c < this.batches.length; c++) {
            const d = this.batches[c]
              , f = 8
              , p = d.style
              , m = p.texture.baseTexture;
            l !== !!p.native && (l = !!p.native,
            h = l ? xr.LINES : xr.TRIANGLES,
            o = null,
            n = f,
            t++),
            o !== m && (o = m,
            m._batchEnabled !== t && (n === f && (t++,
            n = 0,
            r.size > 0 && (r = $a.pop(),
            r || (r = new ec,
            r.texArray = new ic),
            this.drawCalls.push(r)),
            r.start = u,
            r.size = 0,
            r.texArray.count = 0,
            r.type = h),
            m.touched = 1,
            m._batchEnabled = t,
            m._batchLocation = n,
            m.wrapMode = Jr.REPEAT,
            r.texArray.elements[r.texArray.count++] = m,
            n++)),
            r.size += d.size,
            u += d.size,
            a = m._batchLocation,
            this.addColors(e, p.color, p.alpha, d.attribSize, d.attribStart),
            this.addTextureIds(i, a, d.attribSize, d.attribStart)
        }
        At._globalBatch = t,
        this.packAttributes()
    }
    packAttributes() {
        const t = this.points
          , e = this.uvs
          , i = this.colors
          , r = this.textureIds
          , n = new ArrayBuffer(t.length * 3 * 4)
          , o = new Float32Array(n)
          , a = new Uint32Array(n);
        let l = 0;
        for (let h = 0; h < t.length / 2; h++)
            o[l++] = t[h * 2],
            o[l++] = t[h * 2 + 1],
            o[l++] = e[h * 2],
            o[l++] = e[h * 2 + 1],
            a[l++] = i[h],
            o[l++] = r[h];
        this._buffer.update(n),
        this._indexBuffer.update(this.indicesUint16)
    }
    processFill(t) {
        t.holes.length ? pg.triangulate(t, this) : gu[t.type].triangulate(t, this)
    }
    processLine(t) {
        Sp(t, this);
        for (let e = 0; e < t.holes.length; e++)
            Sp(t.holes[e], this)
    }
    processHoles(t) {
        for (let e = 0; e < t.length; e++) {
            const i = t[e];
            gu[i.type].build(i),
            i.matrix && this.transformPoints(i.points, i.matrix)
        }
    }
    calculateBounds() {
        const t = this._bounds;
        t.clear(),
        t.addVertexData(this.points, 0, this.points.length),
        t.pad(this.boundsPadding, this.boundsPadding)
    }
    transformPoints(t, e) {
        for (let i = 0; i < t.length / 2; i++) {
            const r = t[i * 2]
              , n = t[i * 2 + 1];
            t[i * 2] = e.a * r + e.c * n + e.tx,
            t[i * 2 + 1] = e.b * r + e.d * n + e.ty
        }
    }
    addColors(t, e, i, r, n=0) {
        const o = zt.shared.setValue(e).toLittleEndianNumber()
          , a = zt.shared.setValue(o).toPremultiplied(i);
        t.length = Math.max(t.length, n + r);
        for (let l = 0; l < r; l++)
            t[n + l] = a
    }
    addTextureIds(t, e, i, r=0) {
        t.length = Math.max(t.length, r + i);
        for (let n = 0; n < i; n++)
            t[r + n] = e
    }
    addUvs(t, e, i, r, n, o=null) {
        let a = 0;
        const l = e.length
          , h = i.frame;
        for (; a < n; ) {
            let c = t[(r + a) * 2]
              , d = t[(r + a) * 2 + 1];
            if (o) {
                const f = o.a * c + o.c * d + o.tx;
                d = o.b * c + o.d * d + o.ty,
                c = f
            }
            a++,
            e.push(c / h.width, d / h.height)
        }
        const u = i.baseTexture;
        (h.width < u.width || h.height < u.height) && this.adjustUvs(e, i, l, n)
    }
    adjustUvs(t, e, i, r) {
        const n = e.baseTexture
          , o = 1e-6
          , a = i + r * 2
          , l = e.frame
          , h = l.width / n.width
          , u = l.height / n.height;
        let c = l.x / l.width
          , d = l.y / l.height
          , f = Math.floor(t[i] + o)
          , p = Math.floor(t[i + 1] + o);
        for (let m = i + 2; m < a; m += 2)
            f = Math.min(f, Math.floor(t[m] + o)),
            p = Math.min(p, Math.floor(t[m + 1] + o));
        c -= f,
        d -= p;
        for (let m = i; m < a; m += 2)
            t[m] = (t[m] + c) * h,
            t[m + 1] = (t[m + 1] + d) * u
    }
}
;
$b.BATCHABLE_SIZE = 100;
let Vb = $b;
class th {
    constructor() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = st.WHITE,
        this.matrix = null,
        this.visible = !1,
        this.reset()
    }
    clone() {
        const t = new th;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t
    }
    reset() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = st.WHITE,
        this.matrix = null,
        this.visible = !1
    }
    destroy() {
        this.texture = null,
        this.matrix = null
    }
}
class kc extends th {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.alignment = .5,
        this.native = !1,
        this.cap = _s.BUTT,
        this.join = Oi.MITER,
        this.miterLimit = 10
    }
    clone() {
        const t = new kc;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t.width = this.width,
        t.alignment = this.alignment,
        t.native = this.native,
        t.cap = this.cap,
        t.join = this.join,
        t.miterLimit = this.miterLimit,
        t
    }
    reset() {
        super.reset(),
        this.color = 0,
        this.alignment = .5,
        this.width = 0,
        this.native = !1,
        this.cap = _s.BUTT,
        this.join = Oi.MITER,
        this.miterLimit = 10
    }
}
const Xd = {}
  , Pp = class _u extends Si {
    constructor(t=null) {
        super(),
        this.shader = null,
        this.pluginName = "batch",
        this.currentPath = null,
        this.batches = [],
        this.batchTint = -1,
        this.batchDirty = -1,
        this.vertexData = null,
        this._fillStyle = new th,
        this._lineStyle = new kc,
        this._matrix = null,
        this._holeMode = !1,
        this.state = Sr.for2d(),
        this._geometry = t || new Vb,
        this._geometry.refCount++,
        this._transformID = -1,
        this._tintColor = new zt(16777215),
        this.blendMode = _t.NORMAL
    }
    get geometry() {
        return this._geometry
    }
    clone() {
        return this.finishPoly(),
        new _u(this._geometry)
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get blendMode() {
        return this.state.blendMode
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t)
    }
    get fill() {
        return this._fillStyle
    }
    get line() {
        return this._lineStyle
    }
    lineStyle(t=null, e=0, i, r=.5, n=!1) {
        return typeof t == "number" && (t = {
            width: t,
            color: e,
            alpha: i,
            alignment: r,
            native: n
        }),
        this.lineTextureStyle(t)
    }
    lineTextureStyle(t) {
        const e = {
            width: 0,
            texture: st.WHITE,
            color: t?.texture ? 16777215 : 0,
            matrix: null,
            alignment: .5,
            native: !1,
            cap: _s.BUTT,
            join: Oi.MITER,
            miterLimit: 10
        };
        t = Object.assign(e, t),
        this.normalizeColor(t),
        this.currentPath && this.startPoly();
        const i = t.width > 0 && t.alpha > 0;
        return i ? (t.matrix && (t.matrix = t.matrix.clone(),
        t.matrix.invert()),
        Object.assign(this._lineStyle, {
            visible: i
        }, t)) : this._lineStyle.reset(),
        this
    }
    startPoly() {
        if (this.currentPath) {
            const t = this.currentPath.points
              , e = this.currentPath.points.length;
            e > 2 && (this.drawShape(this.currentPath),
            this.currentPath = new js,
            this.currentPath.closeStroke = !1,
            this.currentPath.points.push(t[e - 2], t[e - 1]))
        } else
            this.currentPath = new js,
            this.currentPath.closeStroke = !1
    }
    finishPoly() {
        this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath),
        this.currentPath = null) : this.currentPath.points.length = 0)
    }
    moveTo(t, e) {
        return this.startPoly(),
        this.currentPath.points[0] = t,
        this.currentPath.points[1] = e,
        this
    }
    lineTo(t, e) {
        this.currentPath || this.moveTo(0, 0);
        const i = this.currentPath.points
          , r = i[i.length - 2]
          , n = i[i.length - 1];
        return (r !== t || n !== e) && i.push(t, e),
        this
    }
    _initCurve(t=0, e=0) {
        this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
    }
    quadraticCurveTo(t, e, i, r) {
        this._initCurve();
        const n = this.currentPath.points;
        return n.length === 0 && this.moveTo(0, 0),
        Oc.curveTo(t, e, i, r, n),
        this
    }
    bezierCurveTo(t, e, i, r, n, o) {
        return this._initCurve(),
        Bc.curveTo(t, e, i, r, n, o, this.currentPath.points),
        this
    }
    arcTo(t, e, i, r, n) {
        this._initCurve(t, e);
        const o = this.currentPath.points
          , a = Ap.curveTo(t, e, i, r, n, o);
        if (a) {
            const {cx: l, cy: h, radius: u, startAngle: c, endAngle: d, anticlockwise: f} = a;
            this.arc(l, h, u, c, d, f)
        }
        return this
    }
    arc(t, e, i, r, n, o=!1) {
        if (r === n)
            return this;
        if (!o && n <= r ? n += Fl : o && r <= n && (r += Fl),
        n - r === 0)
            return this;
        const a = t + Math.cos(r) * i
          , l = e + Math.sin(r) * i
          , h = this._geometry.closePointEps;
        let u = this.currentPath ? this.currentPath.points : null;
        if (u) {
            const c = Math.abs(u[u.length - 2] - a)
              , d = Math.abs(u[u.length - 1] - l);
            c < h && d < h || u.push(a, l)
        } else
            this.moveTo(a, l),
            u = this.currentPath.points;
        return Ap.arc(a, l, t, e, i, r, n, o, u),
        this
    }
    beginFill(t=0, e) {
        return this.beginTextureFill({
            texture: st.WHITE,
            color: t,
            alpha: e
        })
    }
    normalizeColor(t) {
        const e = zt.shared.setValue(t.color ?? 0);
        t.color = e.toNumber(),
        t.alpha ?? (t.alpha = e.alpha)
    }
    beginTextureFill(t) {
        const e = {
            texture: st.WHITE,
            color: 16777215,
            matrix: null
        };
        t = Object.assign(e, t),
        this.normalizeColor(t),
        this.currentPath && this.startPoly();
        const i = t.alpha > 0;
        return i ? (t.matrix && (t.matrix = t.matrix.clone(),
        t.matrix.invert()),
        Object.assign(this._fillStyle, {
            visible: i
        }, t)) : this._fillStyle.reset(),
        this
    }
    endFill() {
        return this.finishPoly(),
        this._fillStyle.reset(),
        this
    }
    drawRect(t, e, i, r) {
        return this.drawShape(new St(t,e,i,r))
    }
    drawRoundedRect(t, e, i, r, n) {
        return this.drawShape(new Kl(t,e,i,r,n))
    }
    drawCircle(t, e, i) {
        return this.drawShape(new ql(t,e,i))
    }
    drawEllipse(t, e, i, r) {
        return this.drawShape(new Yl(t,e,i,r))
    }
    drawPolygon(...t) {
        let e, i = !0;
        const r = t[0];
        r.points ? (i = r.closeStroke,
        e = r.points) : Array.isArray(t[0]) ? e = t[0] : e = t;
        const n = new js(e);
        return n.closeStroke = i,
        this.drawShape(n),
        this
    }
    drawShape(t) {
        return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix),
        this
    }
    clear() {
        return this._geometry.clear(),
        this._lineStyle.reset(),
        this._fillStyle.reset(),
        this._boundsID++,
        this._matrix = null,
        this._holeMode = !1,
        this.currentPath = null,
        this
    }
    isFastRect() {
        const t = this._geometry.graphicsData;
        return t.length === 1 && t[0].shape.type === Ne.RECT && !t[0].matrix && !t[0].holes.length && !(t[0].lineStyle.visible && t[0].lineStyle.width)
    }
    _render(t) {
        this.finishPoly();
        const e = this._geometry;
        e.updateBatches(),
        e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(),
        this._renderBatched(t)) : (t.batch.flush(),
        this._renderDirect(t))
    }
    _populateBatches() {
        const t = this._geometry
          , e = this.blendMode
          , i = t.batches.length;
        this.batchTint = -1,
        this._transformID = -1,
        this.batchDirty = t.batchDirty,
        this.batches.length = i,
        this.vertexData = new Float32Array(t.points);
        for (let r = 0; r < i; r++) {
            const n = t.batches[r]
              , o = n.style.color
              , a = new Float32Array(this.vertexData.buffer,n.attribStart * 4 * 2,n.attribSize * 2)
              , l = new Float32Array(t.uvsFloat32.buffer,n.attribStart * 4 * 2,n.attribSize * 2)
              , h = new Uint16Array(t.indicesUint16.buffer,n.start * 2,n.size)
              , u = {
                vertexData: a,
                blendMode: e,
                indices: h,
                uvs: l,
                _batchRGB: zt.shared.setValue(o).toRgbArray(),
                _tintRGB: o,
                _texture: n.style.texture,
                alpha: n.style.alpha,
                worldAlpha: 1
            };
            this.batches[r] = u
        }
    }
    _renderBatched(t) {
        if (this.batches.length) {
            t.batch.setObjectRenderer(t.plugins[this.pluginName]),
            this.calculateVertices(),
            this.calculateTints();
            for (let e = 0, i = this.batches.length; e < i; e++) {
                const r = this.batches[e];
                r.worldAlpha = this.worldAlpha * r.alpha,
                t.plugins[this.pluginName].render(r)
            }
        }
    }
    _renderDirect(t) {
        const e = this._resolveDirectShader(t)
          , i = this._geometry
          , r = this.worldAlpha
          , n = e.uniforms
          , o = i.drawCalls;
        n.translationMatrix = this.transform.worldTransform,
        zt.shared.setValue(this._tintColor).premultiply(r).toArray(n.tint),
        t.shader.bind(e),
        t.geometry.bind(i, e),
        t.state.set(this.state);
        for (let a = 0, l = o.length; a < l; a++)
            this._renderDrawCallDirect(t, i.drawCalls[a])
    }
    _renderDrawCallDirect(t, e) {
        const {texArray: i, type: r, size: n, start: o} = e
          , a = i.count;
        for (let l = 0; l < a; l++)
            t.texture.bind(i.elements[l], l);
        t.geometry.draw(r, n, o)
    }
    _resolveDirectShader(t) {
        let e = this.shader;
        const i = this.pluginName;
        if (!e) {
            if (!Xd[i]) {
                const {maxTextures: r} = t.plugins[i]
                  , n = new Int32Array(r);
                for (let l = 0; l < r; l++)
                    n[l] = l;
                const o = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new Qt,
                    default: ar.from({
                        uSamplers: n
                    }, !0)
                }
                  , a = t.plugins[i]._shader.program;
                Xd[i] = new Dr(a,o)
            }
            e = Xd[i]
        }
        return e
    }
    _calculateBounds() {
        this.finishPoly();
        const t = this._geometry;
        if (!t.graphicsData.length)
            return;
        const {minX: e, minY: i, maxX: r, maxY: n} = t.bounds;
        this._bounds.addFrame(this.transform, e, i, r, n)
    }
    containsPoint(t) {
        return this.worldTransform.applyInverse(t, _u._TEMP_POINT),
        this._geometry.containsPoint(_u._TEMP_POINT)
    }
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this._tintColor.toNumber();
            for (let t = 0; t < this.batches.length; t++) {
                const e = this.batches[t];
                e._tintRGB = zt.shared.setValue(this._tintColor).multiply(e._batchRGB).toLittleEndianNumber()
            }
        }
    }
    calculateVertices() {
        const t = this.transform._worldID;
        if (this._transformID === t)
            return;
        this._transformID = t;
        const e = this.transform.worldTransform
          , i = e.a
          , r = e.b
          , n = e.c
          , o = e.d
          , a = e.tx
          , l = e.ty
          , h = this._geometry.points
          , u = this.vertexData;
        let c = 0;
        for (let d = 0; d < h.length; d += 2) {
            const f = h[d]
              , p = h[d + 1];
            u[c++] = i * f + n * p + a,
            u[c++] = o * p + r * f + l
        }
    }
    closePath() {
        const t = this.currentPath;
        return t && (t.closeStroke = !0,
        this.finishPoly()),
        this
    }
    setMatrix(t) {
        return this._matrix = t,
        this
    }
    beginHole() {
        return this.finishPoly(),
        this._holeMode = !0,
        this
    }
    endHole() {
        return this.finishPoly(),
        this._holeMode = !1,
        this
    }
    destroy(t) {
        this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose(),
        this._matrix = null,
        this.currentPath = null,
        this._lineStyle.destroy(),
        this._lineStyle = null,
        this._fillStyle.destroy(),
        this._fillStyle = null,
        this._geometry = null,
        this.shader = null,
        this.vertexData = null,
        this.batches.length = 0,
        this.batches = null,
        super.destroy(t)
    }
}
;
Pp.curves = tn,
Pp._TEMP_POINT = new Nt;
let Lc = Pp;
const VR = {
    buildPoly: pg,
    buildCircle: $l,
    buildRectangle: Ub,
    buildRoundedRectangle: Gb,
    buildLine: Sp,
    ArcUtils: Ap,
    BezierUtils: Bc,
    QuadraticUtils: Oc,
    BatchPart: Hb,
    FILL_COMMANDS: gu,
    BATCH_POOL: Cp,
    DRAW_CALL_POOL: $a
};
class Xb {
    constructor(t, e) {
        this.uvBuffer = t,
        this.uvMatrix = e,
        this.data = null,
        this._bufferUpdateId = -1,
        this._textureUpdateId = -1,
        this._updateID = 0
    }
    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
            return;
        this._bufferUpdateId = this.uvBuffer._updateID,
        this._textureUpdateId = this.uvMatrix._updateID;
        const e = this.uvBuffer.data;
        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)),
        this.uvMatrix.multiplyUvs(e, this.data),
        this._updateID++
    }
}
const Wd = new Nt
  , hy = new js
  , Wb = class jb extends Si {
    constructor(t, e, i, r=xr.TRIANGLES) {
        super(),
        this.geometry = t,
        this.shader = e,
        this.state = i || Sr.for2d(),
        this.drawMode = r,
        this.start = 0,
        this.size = 0,
        this.uvs = null,
        this.indices = null,
        this.vertexData = new Float32Array(1),
        this.vertexDirty = -1,
        this._transformID = -1,
        this._roundPixels = nt.ROUND_PIXELS,
        this.batchUvs = null
    }
    get geometry() {
        return this._geometry
    }
    set geometry(t) {
        this._geometry !== t && (this._geometry && (this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose()),
        this._geometry = t,
        this._geometry && this._geometry.refCount++,
        this.vertexDirty = -1)
    }
    get uvBuffer() {
        return this.geometry.buffers[1]
    }
    get verticesBuffer() {
        return this.geometry.buffers[0]
    }
    set material(t) {
        this.shader = t
    }
    get material() {
        return this.shader
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get blendMode() {
        return this.state.blendMode
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get tint() {
        return "tint"in this.shader ? this.shader.tint : null
    }
    set tint(t) {
        this.shader.tint = t
    }
    get tintValue() {
        return this.shader.tintValue
    }
    get texture() {
        return "texture"in this.shader ? this.shader.texture : null
    }
    set texture(t) {
        this.shader.texture = t
    }
    _render(t) {
        const e = this.geometry.buffers[0].data;
        this.shader.batchable && this.drawMode === xr.TRIANGLES && e.length < jb.BATCHABLE_SIZE * 2 ? this._renderToBatch(t) : this._renderDefault(t)
    }
    _renderDefault(t) {
        const e = this.shader;
        e.alpha = this.worldAlpha,
        e.update && e.update(),
        t.batch.flush(),
        e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0),
        t.shader.bind(e),
        t.state.set(this.state),
        t.geometry.bind(this.geometry, e),
        t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
    }
    _renderToBatch(t) {
        const e = this.geometry
          , i = this.shader;
        i.uvMatrix && (i.uvMatrix.update(),
        this.calculateUvs()),
        this.calculateVertices(),
        this.indices = e.indexBuffer.data,
        this._tintRGB = i._tintRGB,
        this._texture = i.texture;
        const r = this.material.pluginName;
        t.batch.setObjectRenderer(t.plugins[r]),
        t.plugins[r].render(this)
    }
    calculateVertices() {
        const t = this.geometry.buffers[0]
          , e = t.data
          , i = t._updateID;
        if (i === this.vertexDirty && this._transformID === this.transform._worldID)
            return;
        this._transformID = this.transform._worldID,
        this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
        const r = this.transform.worldTransform
          , n = r.a
          , o = r.b
          , a = r.c
          , l = r.d
          , h = r.tx
          , u = r.ty
          , c = this.vertexData;
        for (let d = 0; d < c.length / 2; d++) {
            const f = e[d * 2]
              , p = e[d * 2 + 1];
            c[d * 2] = n * f + a * p + h,
            c[d * 2 + 1] = o * f + l * p + u
        }
        if (this._roundPixels) {
            const d = nt.RESOLUTION;
            for (let f = 0; f < c.length; ++f)
                c[f] = Math.round(c[f] * d) / d
        }
        this.vertexDirty = i
    }
    calculateUvs() {
        const t = this.geometry.buffers[1]
          , e = this.shader;
        e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new Xb(t,e.uvMatrix)),
        this.batchUvs.update(),
        this.uvs = this.batchUvs.data)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
    }
    containsPoint(t) {
        if (!this.getBounds().contains(t.x, t.y))
            return !1;
        this.worldTransform.applyInverse(t, Wd);
        const e = this.geometry.getBuffer("aVertexPosition").data
          , i = hy.points
          , r = this.geometry.getIndex().data
          , n = r.length
          , o = this.drawMode === 4 ? 3 : 1;
        for (let a = 0; a + 2 < n; a += o) {
            const l = r[a] * 2
              , h = r[a + 1] * 2
              , u = r[a + 2] * 2;
            if (i[0] = e[l],
            i[1] = e[l + 1],
            i[2] = e[h],
            i[3] = e[h + 1],
            i[4] = e[u],
            i[5] = e[u + 1],
            hy.contains(Wd.x, Wd.y))
                return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t),
        this._cachedTexture && (this._cachedTexture.destroy(),
        this._cachedTexture = null),
        this.geometry = null,
        this.shader = null,
        this.state = null,
        this.uvs = null,
        this.indices = null,
        this.vertexData = null
    }
}
;
Wb.BATCHABLE_SIZE = 100;
let ra = Wb;
class eh extends ws {
    constructor(t, e, i) {
        super();
        const r = new ce(t)
          , n = new ce(e,!0)
          , o = new ce(i,!0,!0);
        this.addAttribute("aVertexPosition", r, 2, !1, ft.FLOAT).addAttribute("aTextureCoord", n, 2, !1, ft.FLOAT).addIndex(o),
        this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var XR = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`
  , WR = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class sa extends Dr {
    constructor(t, e) {
        const i = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: Qt.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        e = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, e),
        e.uniforms && Object.assign(i, e.uniforms),
        super(e.program || qr.from(WR, XR), i),
        this._colorDirty = !1,
        this.uvMatrix = new Mc(t),
        this.batchable = e.program === void 0,
        this.pluginName = e.pluginName,
        this._tintColor = new zt(e.tint),
        this._tintRGB = this._tintColor.toLittleEndianNumber(),
        this._colorDirty = !0,
        this.alpha = e.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0),
        this.uniforms.uSampler = t,
        this.uvMatrix.texture = t)
    }
    set alpha(t) {
        t !== this._alpha && (this._alpha = t,
        this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this.tint && (this._tintColor.setValue(t),
        this._tintRGB = this._tintColor.toLittleEndianNumber(),
        this._colorDirty = !0)
    }
    get tint() {
        return this._tintColor.value
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const t = this.texture.baseTexture.alphaMode;
            zt.shared.setValue(this._tintColor).premultiply(this._alpha, t).toArray(this.uniforms.uColor)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class qb extends eh {
    constructor(t=100, e=100, i=10, r=10) {
        super(),
        this.segWidth = i,
        this.segHeight = r,
        this.width = t,
        this.height = e,
        this.build()
    }
    build() {
        const t = this.segWidth * this.segHeight
          , e = []
          , i = []
          , r = []
          , n = this.segWidth - 1
          , o = this.segHeight - 1
          , a = this.width / n
          , l = this.height / o;
        for (let u = 0; u < t; u++) {
            const c = u % this.segWidth
              , d = u / this.segWidth | 0;
            e.push(c * a, d * l),
            i.push(c / n, d / o)
        }
        const h = n * o;
        for (let u = 0; u < h; u++) {
            const c = u % n
              , d = u / n | 0
              , f = d * this.segWidth + c
              , p = d * this.segWidth + c + 1
              , m = (d + 1) * this.segWidth + c
              , g = (d + 1) * this.segWidth + c + 1;
            r.push(f, p, m, p, g, m)
        }
        this.buffers[0].data = new Float32Array(e),
        this.buffers[1].data = new Float32Array(i),
        this.indexBuffer.data = new Uint16Array(r),
        this.buffers[0].update(),
        this.buffers[1].update(),
        this.indexBuffer.update()
    }
}
class Yb extends eh {
    constructor(t=200, e, i=0) {
        super(new Float32Array(e.length * 4), new Float32Array(e.length * 4), new Uint16Array((e.length - 1) * 6)),
        this.points = e,
        this._width = t,
        this.textureScale = i,
        this.build()
    }
    get width() {
        return this._width
    }
    build() {
        const t = this.points;
        if (!t)
            return;
        const e = this.getBuffer("aVertexPosition")
          , i = this.getBuffer("aTextureCoord")
          , r = this.getIndex();
        if (t.length < 1)
            return;
        e.data.length / 4 !== t.length && (e.data = new Float32Array(t.length * 4),
        i.data = new Float32Array(t.length * 4),
        r.data = new Uint16Array((t.length - 1) * 6));
        const n = i.data
          , o = r.data;
        n[0] = 0,
        n[1] = 0,
        n[2] = 0,
        n[3] = 1;
        let a = 0
          , l = t[0];
        const h = this._width * this.textureScale
          , u = t.length;
        for (let d = 0; d < u; d++) {
            const f = d * 4;
            if (this.textureScale > 0) {
                const p = l.x - t[d].x
                  , m = l.y - t[d].y
                  , g = Math.sqrt(p * p + m * m);
                l = t[d],
                a += g / h
            } else
                a = d / (u - 1);
            n[f] = a,
            n[f + 1] = 0,
            n[f + 2] = a,
            n[f + 3] = 1
        }
        let c = 0;
        for (let d = 0; d < u - 1; d++) {
            const f = d * 2;
            o[c++] = f,
            o[c++] = f + 1,
            o[c++] = f + 2,
            o[c++] = f + 2,
            o[c++] = f + 1,
            o[c++] = f + 3
        }
        i.update(),
        r.update(),
        this.updateVertices()
    }
    updateVertices() {
        const t = this.points;
        if (t.length < 1)
            return;
        let e = t[0], i, r = 0, n = 0;
        const o = this.buffers[0].data
          , a = t.length
          , l = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        for (let h = 0; h < a; h++) {
            const u = t[h]
              , c = h * 4;
            h < t.length - 1 ? i = t[h + 1] : i = u,
            n = -(i.x - e.x),
            r = i.y - e.y;
            const d = Math.sqrt(r * r + n * n);
            d < 1e-6 ? (r = 0,
            n = 0) : (r /= d,
            n /= d,
            r *= l,
            n *= l),
            o[c] = u.x + r,
            o[c + 1] = u.y + n,
            o[c + 2] = u.x - r,
            o[c + 3] = u.y - n,
            e = u
        }
        this.buffers[0].update()
    }
    update() {
        this.textureScale > 0 ? this.build() : this.updateVertices()
    }
}
class Kb extends ra {
    constructor(t, e, i) {
        const r = new qb(t.width,t.height,e,i)
          , n = new sa(st.WHITE);
        super(r, n),
        this.texture = t,
        this.autoResize = !0
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        const t = this.geometry
          , {width: e, height: i} = this.shader.texture;
        this.autoResize && (t.width !== e || t.height !== i) && (t.width = this.shader.texture.width,
        t.height = this.shader.texture.height,
        t.build())
    }
    set texture(t) {
        this.shader.texture !== t && (this.shader.texture = t,
        this._textureID = -1,
        t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
    }
    get texture() {
        return this.shader.texture
    }
    _render(t) {
        this._textureID !== this.shader.texture._updateID && this.textureUpdated(),
        super._render(t)
    }
    destroy(t) {
        this.shader.texture.off("update", this.textureUpdated, this),
        super.destroy(t)
    }
}
const jh = 10;
class jR extends Kb {
    constructor(t, e, i, r, n) {
        super(st.WHITE, 4, 4),
        this._origWidth = t.orig.width,
        this._origHeight = t.orig.height,
        this._width = this._origWidth,
        this._height = this._origHeight,
        this._leftWidth = e ?? t.defaultBorders?.left ?? jh,
        this._rightWidth = r ?? t.defaultBorders?.right ?? jh,
        this._topHeight = i ?? t.defaultBorders?.top ?? jh,
        this._bottomHeight = n ?? t.defaultBorders?.bottom ?? jh,
        this.texture = t
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID,
        this._refresh()
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    updateHorizontalVertices() {
        const t = this.vertices
          , e = this._getMinScale();
        t[9] = t[11] = t[13] = t[15] = this._topHeight * e,
        t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e,
        t[25] = t[27] = t[29] = t[31] = this._height
    }
    updateVerticalVertices() {
        const t = this.vertices
          , e = this._getMinScale();
        t[2] = t[10] = t[18] = t[26] = this._leftWidth * e,
        t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e,
        t[6] = t[14] = t[22] = t[30] = this._width
    }
    _getMinScale() {
        const t = this._leftWidth + this._rightWidth
          , e = this._width > t ? 1 : this._width / t
          , i = this._topHeight + this._bottomHeight
          , r = this._height > i ? 1 : this._height / i;
        return Math.min(e, r)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t,
        this._refresh()
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t,
        this._refresh()
    }
    get leftWidth() {
        return this._leftWidth
    }
    set leftWidth(t) {
        this._leftWidth = t,
        this._refresh()
    }
    get rightWidth() {
        return this._rightWidth
    }
    set rightWidth(t) {
        this._rightWidth = t,
        this._refresh()
    }
    get topHeight() {
        return this._topHeight
    }
    set topHeight(t) {
        this._topHeight = t,
        this._refresh()
    }
    get bottomHeight() {
        return this._bottomHeight
    }
    set bottomHeight(t) {
        this._bottomHeight = t,
        this._refresh()
    }
    _refresh() {
        const t = this.texture
          , e = this.geometry.buffers[1].data;
        this._origWidth = t.orig.width,
        this._origHeight = t.orig.height;
        const i = 1 / this._origWidth
          , r = 1 / this._origHeight;
        e[0] = e[8] = e[16] = e[24] = 0,
        e[1] = e[3] = e[5] = e[7] = 0,
        e[6] = e[14] = e[22] = e[30] = 1,
        e[25] = e[27] = e[29] = e[31] = 1,
        e[2] = e[10] = e[18] = e[26] = i * this._leftWidth,
        e[4] = e[12] = e[20] = e[28] = 1 - i * this._rightWidth,
        e[9] = e[11] = e[13] = e[15] = r * this._topHeight,
        e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight,
        this.updateHorizontalVertices(),
        this.updateVerticalVertices(),
        this.geometry.buffers[0].update(),
        this.geometry.buffers[1].update()
    }
}
class qR extends ra {
    constructor(t=st.EMPTY, e, i, r, n) {
        const o = new eh(e,i,r);
        o.getBuffer("aVertexPosition").static = !1;
        const a = new sa(t);
        super(o, a, null, n),
        this.autoUpdate = !0
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    _render(t) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
        super._render(t)
    }
}
class YR extends ra {
    constructor(t, e, i=0) {
        const r = new Yb(t.height,e,i)
          , n = new sa(t);
        i > 0 && (t.baseTexture.wrapMode = Jr.REPEAT),
        super(r, n),
        this.autoUpdate = !0
    }
    _render(t) {
        const e = this.geometry;
        (this.autoUpdate || e._width !== this.shader.texture.height) && (e._width = this.shader.texture.height,
        e.update()),
        super._render(t)
    }
}
class KR extends Si {
    constructor(t=1500, e, i=16384, r=!1) {
        super();
        const n = 16384;
        i > n && (i = n),
        this._properties = [!1, !0, !1, !1, !1],
        this._maxSize = t,
        this._batchSize = i,
        this._buffers = null,
        this._bufferUpdateIDs = [],
        this._updateID = 0,
        this.interactiveChildren = !1,
        this.blendMode = _t.NORMAL,
        this.autoResize = r,
        this.roundPixels = !0,
        this.baseTexture = null,
        this.setProperties(e),
        this._tintColor = new zt(0),
        this.tintRgb = new Float32Array(3),
        this.tint = 16777215
    }
    setProperties(t) {
        t && (this._properties[0] = "vertices"in t || "scale"in t ? !!t.vertices || !!t.scale : this._properties[0],
        this._properties[1] = "position"in t ? !!t.position : this._properties[1],
        this._properties[2] = "rotation"in t ? !!t.rotation : this._properties[2],
        this._properties[3] = "uvs"in t ? !!t.uvs : this._properties[3],
        this._properties[4] = "tint"in t || "alpha"in t ? !!t.tint || !!t.alpha : this._properties[4])
    }
    updateTransform() {
        this.displayObjectUpdateTransform()
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t),
        this._tintColor.toRgbArray(this.tintRgb)
    }
    render(t) {
        !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture,
        this.baseTexture.valid || this.baseTexture.once("update", ()=>this.onChildrenChange(0))),
        t.batch.setObjectRenderer(t.plugins.particle),
        t.plugins.particle.render(this))
    }
    onChildrenChange(t) {
        const e = Math.floor(t / this._batchSize);
        for (; this._bufferUpdateIDs.length < e; )
            this._bufferUpdateIDs.push(0);
        this._bufferUpdateIDs[e] = ++this._updateID
    }
    dispose() {
        if (this._buffers) {
            for (let t = 0; t < this._buffers.length; ++t)
                this._buffers[t].destroy();
            this._buffers = null
        }
    }
    destroy(t) {
        super.destroy(t),
        this.dispose(),
        this._properties = null,
        this._buffers = null,
        this._bufferUpdateIDs = null
    }
}
class uy {
    constructor(t, e, i) {
        this.geometry = new ws,
        this.indexBuffer = null,
        this.size = i,
        this.dynamicProperties = [],
        this.staticProperties = [];
        for (let r = 0; r < t.length; ++r) {
            let n = t[r];
            n = {
                attributeName: n.attributeName,
                size: n.size,
                uploadFunction: n.uploadFunction,
                type: n.type || ft.FLOAT,
                offset: n.offset
            },
            e[r] ? this.dynamicProperties.push(n) : this.staticProperties.push(n)
        }
        this.staticStride = 0,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.dynamicStride = 0,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this._updateID = 0,
        this.initBuffers()
    }
    initBuffers() {
        const t = this.geometry;
        let e = 0;
        this.indexBuffer = new ce(u1(this.size),!0,!0),
        t.addIndex(this.indexBuffer),
        this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            a.offset = e,
            e += a.size,
            this.dynamicStride += a.size
        }
        const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(i),
        this.dynamicDataUint32 = new Uint32Array(i),
        this.dynamicBuffer = new ce(this.dynamicData,!1,!1);
        let r = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            a.offset = r,
            r += a.size,
            this.staticStride += a.size
        }
        const n = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(n),
        this.staticDataUint32 = new Uint32Array(n),
        this.staticBuffer = new ce(this.staticData,!0,!1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            t.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === ft.UNSIGNED_BYTE, a.type, this.dynamicStride * 4, a.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            t.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === ft.UNSIGNED_BYTE, a.type, this.staticStride * 4, a.offset * 4)
        }
    }
    uploadDynamic(t, e, i) {
        for (let r = 0; r < this.dynamicProperties.length; r++) {
            const n = this.dynamicProperties[r];
            n.uploadFunction(t, e, i, n.type === ft.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, n.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, e, i) {
        for (let r = 0; r < this.staticProperties.length; r++) {
            const n = this.staticProperties[r];
            n.uploadFunction(t, e, i, n.type === ft.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, n.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null,
        this.dynamicProperties = null,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this.staticProperties = null,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.geometry.destroy()
    }
}
var ZR = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`
  , QR = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class mg extends Ql {
    constructor(t) {
        super(t),
        this.shader = null,
        this.properties = null,
        this.tempMatrix = new Qt,
        this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: ft.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }],
        this.shader = Dr.from(QR, ZR, {}),
        this.state = Sr.for2d()
    }
    render(t) {
        const e = t.children
          , i = t._maxSize
          , r = t._batchSize
          , n = this.renderer;
        let o = e.length;
        if (o === 0)
            return;
        o > i && !t.autoResize && (o = i);
        let a = t._buffers;
        a || (a = t._buffers = this.generateBuffers(t));
        const l = e[0]._texture.baseTexture
          , h = l.alphaMode > 0;
        this.state.blendMode = km(t.blendMode, h),
        n.state.set(this.state);
        const u = n.gl
          , c = t.worldTransform.copyTo(this.tempMatrix);
        c.prepend(n.globalUniforms.uniforms.projectionMatrix),
        this.shader.uniforms.translationMatrix = c.toArray(!0),
        this.shader.uniforms.uColor = zt.shared.setValue(t.tintRgb).premultiply(t.worldAlpha, h).toArray(this.shader.uniforms.uColor),
        this.shader.uniforms.uSampler = l,
        this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, p = 0; f < o; f += r,
        p += 1) {
            let m = o - f;
            m > r && (m = r),
            p >= a.length && a.push(this._generateOneMoreBuffer(t));
            const g = a[p];
            g.uploadDynamic(e, f, m);
            const _ = t._bufferUpdateIDs[p] || 0;
            d = d || g._updateID < _,
            d && (g._updateID = t._updateID,
            g.uploadStatic(e, f, m)),
            n.geometry.bind(g.geometry),
            u.drawElements(u.TRIANGLES, m * 6, u.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(t) {
        const e = []
          , i = t._maxSize
          , r = t._batchSize
          , n = t._properties;
        for (let o = 0; o < i; o += r)
            e.push(new uy(this.properties,n,r));
        return e
    }
    _generateOneMoreBuffer(t) {
        const e = t._batchSize
          , i = t._properties;
        return new uy(this.properties,i,e)
    }
    uploadVertices(t, e, i, r, n, o) {
        let a = 0
          , l = 0
          , h = 0
          , u = 0;
        for (let c = 0; c < i; ++c) {
            const d = t[e + c]
              , f = d._texture
              , p = d.scale.x
              , m = d.scale.y
              , g = f.trim
              , _ = f.orig;
            g ? (l = g.x - d.anchor.x * _.width,
            a = l + g.width,
            u = g.y - d.anchor.y * _.height,
            h = u + g.height) : (a = _.width * (1 - d.anchor.x),
            l = _.width * -d.anchor.x,
            h = _.height * (1 - d.anchor.y),
            u = _.height * -d.anchor.y),
            r[o] = l * p,
            r[o + 1] = u * m,
            r[o + n] = a * p,
            r[o + n + 1] = u * m,
            r[o + n * 2] = a * p,
            r[o + n * 2 + 1] = h * m,
            r[o + n * 3] = l * p,
            r[o + n * 3 + 1] = h * m,
            o += n * 4
        }
    }
    uploadPosition(t, e, i, r, n, o) {
        for (let a = 0; a < i; a++) {
            const l = t[e + a].position;
            r[o] = l.x,
            r[o + 1] = l.y,
            r[o + n] = l.x,
            r[o + n + 1] = l.y,
            r[o + n * 2] = l.x,
            r[o + n * 2 + 1] = l.y,
            r[o + n * 3] = l.x,
            r[o + n * 3 + 1] = l.y,
            o += n * 4
        }
    }
    uploadRotation(t, e, i, r, n, o) {
        for (let a = 0; a < i; a++) {
            const l = t[e + a].rotation;
            r[o] = l,
            r[o + n] = l,
            r[o + n * 2] = l,
            r[o + n * 3] = l,
            o += n * 4
        }
    }
    uploadUvs(t, e, i, r, n, o) {
        for (let a = 0; a < i; ++a) {
            const l = t[e + a]._texture._uvs;
            l ? (r[o] = l.x0,
            r[o + 1] = l.y0,
            r[o + n] = l.x1,
            r[o + n + 1] = l.y1,
            r[o + n * 2] = l.x2,
            r[o + n * 2 + 1] = l.y2,
            r[o + n * 3] = l.x3,
            r[o + n * 3 + 1] = l.y3,
            o += n * 4) : (r[o] = 0,
            r[o + 1] = 0,
            r[o + n] = 0,
            r[o + n + 1] = 0,
            r[o + n * 2] = 0,
            r[o + n * 2 + 1] = 0,
            r[o + n * 3] = 0,
            r[o + n * 3 + 1] = 0,
            o += n * 4)
        }
    }
    uploadTint(t, e, i, r, n, o) {
        for (let a = 0; a < i; ++a) {
            const l = t[e + a]
              , h = zt.shared.setValue(l._tintRGB).toPremultiplied(l.alpha, l.texture.baseTexture.alphaMode > 0);
            r[o] = h,
            r[o + n] = h,
            r[o + n * 2] = h,
            r[o + n * 3] = h,
            o += n * 4
        }
    }
    destroy() {
        super.destroy(),
        this.shader && (this.shader.destroy(),
        this.shader = null),
        this.tempMatrix = null
    }
}
mg.extension = {
    name: "particle",
    type: it.RendererPlugin
};
ct.add(mg);
var ih = (s=>(s[s.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL",
s[s.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL",
s))(ih || {});
const qh = {
    willReadFrequently: !0
}
  , Lr = class dt {
    static get experimentalLetterSpacingSupported() {
        let t = dt._experimentalLetterSpacingSupported;
        if (t !== void 0) {
            const e = nt.ADAPTER.getCanvasRenderingContext2D().prototype;
            t = dt._experimentalLetterSpacingSupported = "letterSpacing"in e || "textLetterSpacing"in e
        }
        return t
    }
    constructor(t, e, i, r, n, o, a, l, h) {
        this.text = t,
        this.style = e,
        this.width = i,
        this.height = r,
        this.lines = n,
        this.lineWidths = o,
        this.lineHeight = a,
        this.maxLineWidth = l,
        this.fontProperties = h
    }
    static measureText(t, e, i, r=dt._canvas) {
        i = i ?? e.wordWrap;
        const n = e.toFontString()
          , o = dt.measureFont(n);
        o.fontSize === 0 && (o.fontSize = e.fontSize,
        o.ascent = e.fontSize);
        const a = r.getContext("2d", qh);
        a.font = n;
        const l = (i ? dt.wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/)
          , h = new Array(l.length);
        let u = 0;
        for (let p = 0; p < l.length; p++) {
            const m = dt._measureText(l[p], e.letterSpacing, a);
            h[p] = m,
            u = Math.max(u, m)
        }
        let c = u + e.strokeThickness;
        e.dropShadow && (c += e.dropShadowDistance);
        const d = e.lineHeight || o.fontSize + e.strokeThickness;
        let f = Math.max(d, o.fontSize + e.strokeThickness * 2) + e.leading + (l.length - 1) * (d + e.leading);
        return e.dropShadow && (f += e.dropShadowDistance),
        new dt(t,e,c,f,l,h,d + e.leading,u,o)
    }
    static _measureText(t, e, i) {
        let r = !1;
        dt.experimentalLetterSpacingSupported && (dt.experimentalLetterSpacing ? (i.letterSpacing = `${e}px`,
        i.textLetterSpacing = `${e}px`,
        r = !0) : (i.letterSpacing = "0px",
        i.textLetterSpacing = "0px"));
        let n = i.measureText(t).width;
        return n > 0 && (r ? n -= e : n += (dt.graphemeSegmenter(t).length - 1) * e),
        n
    }
    static wordWrap(t, e, i=dt._canvas) {
        const r = i.getContext("2d", qh);
        let n = 0
          , o = ""
          , a = "";
        const l = Object.create(null)
          , {letterSpacing: h, whiteSpace: u} = e
          , c = dt.collapseSpaces(u)
          , d = dt.collapseNewlines(u);
        let f = !c;
        const p = e.wordWrapWidth + h
          , m = dt.tokenize(t);
        for (let g = 0; g < m.length; g++) {
            let _ = m[g];
            if (dt.isNewline(_)) {
                if (!d) {
                    a += dt.addLine(o),
                    f = !c,
                    o = "",
                    n = 0;
                    continue
                }
                _ = " "
            }
            if (c) {
                const y = dt.isBreakingSpace(_)
                  , v = dt.isBreakingSpace(o[o.length - 1]);
                if (y && v)
                    continue
            }
            const x = dt.getFromCache(_, h, l, r);
            if (x > p)
                if (o !== "" && (a += dt.addLine(o),
                o = "",
                n = 0),
                dt.canBreakWords(_, e.breakWords)) {
                    const y = dt.wordWrapSplit(_);
                    for (let v = 0; v < y.length; v++) {
                        let E = y[v]
                          , P = E
                          , w = 1;
                        for (; y[v + w]; ) {
                            const I = y[v + w];
                            if (!dt.canBreakChars(P, I, _, v, e.breakWords))
                                E += I;
                            else
                                break;
                            P = I,
                            w++
                        }
                        v += w - 1;
                        const A = dt.getFromCache(E, h, l, r);
                        A + n > p && (a += dt.addLine(o),
                        f = !1,
                        o = "",
                        n = 0),
                        o += E,
                        n += A
                    }
                } else {
                    o.length > 0 && (a += dt.addLine(o),
                    o = "",
                    n = 0);
                    const y = g === m.length - 1;
                    a += dt.addLine(_, !y),
                    f = !1,
                    o = "",
                    n = 0
                }
            else
                x + n > p && (f = !1,
                a += dt.addLine(o),
                o = "",
                n = 0),
                (o.length > 0 || !dt.isBreakingSpace(_) || f) && (o += _,
                n += x)
        }
        return a += dt.addLine(o, !1),
        a
    }
    static addLine(t, e=!0) {
        return t = dt.trimRight(t),
        t = e ? `${t}
` : t,
        t
    }
    static getFromCache(t, e, i, r) {
        let n = i[t];
        return typeof n != "number" && (n = dt._measureText(t, e, r) + e,
        i[t] = n),
        n
    }
    static collapseSpaces(t) {
        return t === "normal" || t === "pre-line"
    }
    static collapseNewlines(t) {
        return t === "normal"
    }
    static trimRight(t) {
        if (typeof t != "string")
            return "";
        for (let e = t.length - 1; e >= 0; e--) {
            const i = t[e];
            if (!dt.isBreakingSpace(i))
                break;
            t = t.slice(0, -1)
        }
        return t
    }
    static isNewline(t) {
        return typeof t != "string" ? !1 : dt._newlines.includes(t.charCodeAt(0))
    }
    static isBreakingSpace(t, e) {
        return typeof t != "string" ? !1 : dt._breakingSpaces.includes(t.charCodeAt(0))
    }
    static tokenize(t) {
        const e = [];
        let i = "";
        if (typeof t != "string")
            return e;
        for (let r = 0; r < t.length; r++) {
            const n = t[r]
              , o = t[r + 1];
            if (dt.isBreakingSpace(n, o) || dt.isNewline(n)) {
                i !== "" && (e.push(i),
                i = ""),
                e.push(n);
                continue
            }
            i += n
        }
        return i !== "" && e.push(i),
        e
    }
    static canBreakWords(t, e) {
        return e
    }
    static canBreakChars(t, e, i, r, n) {
        return !0
    }
    static wordWrapSplit(t) {
        return dt.graphemeSegmenter(t)
    }
    static measureFont(t) {
        if (dt._fonts[t])
            return dt._fonts[t];
        const e = {
            ascent: 0,
            descent: 0,
            fontSize: 0
        }
          , i = dt._canvas
          , r = dt._context;
        r.font = t;
        const n = dt.METRICS_STRING + dt.BASELINE_SYMBOL
          , o = Math.ceil(r.measureText(n).width);
        let a = Math.ceil(r.measureText(dt.BASELINE_SYMBOL).width);
        const l = Math.ceil(dt.HEIGHT_MULTIPLIER * a);
        if (a = a * dt.BASELINE_MULTIPLIER | 0,
        o === 0 || l === 0)
            return dt._fonts[t] = e,
            e;
        i.width = o,
        i.height = l,
        r.fillStyle = "#f00",
        r.fillRect(0, 0, o, l),
        r.font = t,
        r.textBaseline = "alphabetic",
        r.fillStyle = "#000",
        r.fillText(n, 0, a);
        const h = r.getImageData(0, 0, o, l).data
          , u = h.length
          , c = o * 4;
        let d = 0
          , f = 0
          , p = !1;
        for (d = 0; d < a; ++d) {
            for (let m = 0; m < c; m += 4)
                if (h[f + m] !== 255) {
                    p = !0;
                    break
                }
            if (!p)
                f += c;
            else
                break
        }
        for (e.ascent = a - d,
        f = u - c,
        p = !1,
        d = l; d > a; --d) {
            for (let m = 0; m < c; m += 4)
                if (h[f + m] !== 255) {
                    p = !0;
                    break
                }
            if (!p)
                f -= c;
            else
                break
        }
        return e.descent = d - a,
        e.fontSize = e.ascent + e.descent,
        dt._fonts[t] = e,
        e
    }
    static clearMetrics(t="") {
        t ? delete dt._fonts[t] : dt._fonts = {}
    }
    static get _canvas() {
        if (!dt.__canvas) {
            let t;
            try {
                const e = new OffscreenCanvas(0,0);
                if (e.getContext("2d", qh)?.measureText)
                    return dt.__canvas = e,
                    e;
                t = nt.ADAPTER.createCanvas()
            } catch {
                t = nt.ADAPTER.createCanvas()
            }
            t.width = t.height = 10,
            dt.__canvas = t
        }
        return dt.__canvas
    }
    static get _context() {
        return dt.__context || (dt.__context = dt._canvas.getContext("2d", qh)),
        dt.__context
    }
}
;
Lr.METRICS_STRING = "|q",
Lr.BASELINE_SYMBOL = "M",
Lr.BASELINE_MULTIPLIER = 1.4,
Lr.HEIGHT_MULTIPLIER = 2,
Lr.graphemeSegmenter = (()=>{
    if (typeof Intl?.Segmenter == "function") {
        const s = new Intl.Segmenter;
        return t=>[...s.segment(t)].map(e=>e.segment)
    }
    return s=>[...s]
}
)(),
Lr.experimentalLetterSpacing = !1,
Lr._fonts = {},
Lr._newlines = [10, 13],
Lr._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
let cs = Lr;
const JR = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
  , Zb = class za {
    constructor(t) {
        this.styleID = 0,
        this.reset(),
        qd(this, t, t)
    }
    clone() {
        const t = {};
        return qd(t, this, za.defaultStyle),
        new za(t)
    }
    reset() {
        qd(this, za.defaultStyle, za.defaultStyle)
    }
    get align() {
        return this._align
    }
    set align(t) {
        this._align !== t && (this._align = t,
        this.styleID++)
    }
    get breakWords() {
        return this._breakWords
    }
    set breakWords(t) {
        this._breakWords !== t && (this._breakWords = t,
        this.styleID++)
    }
    get dropShadow() {
        return this._dropShadow
    }
    set dropShadow(t) {
        this._dropShadow !== t && (this._dropShadow = t,
        this.styleID++)
    }
    get dropShadowAlpha() {
        return this._dropShadowAlpha
    }
    set dropShadowAlpha(t) {
        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t,
        this.styleID++)
    }
    get dropShadowAngle() {
        return this._dropShadowAngle
    }
    set dropShadowAngle(t) {
        this._dropShadowAngle !== t && (this._dropShadowAngle = t,
        this.styleID++)
    }
    get dropShadowBlur() {
        return this._dropShadowBlur
    }
    set dropShadowBlur(t) {
        this._dropShadowBlur !== t && (this._dropShadowBlur = t,
        this.styleID++)
    }
    get dropShadowColor() {
        return this._dropShadowColor
    }
    set dropShadowColor(t) {
        const e = jd(t);
        this._dropShadowColor !== e && (this._dropShadowColor = e,
        this.styleID++)
    }
    get dropShadowDistance() {
        return this._dropShadowDistance
    }
    set dropShadowDistance(t) {
        this._dropShadowDistance !== t && (this._dropShadowDistance = t,
        this.styleID++)
    }
    get fill() {
        return this._fill
    }
    set fill(t) {
        const e = jd(t);
        this._fill !== e && (this._fill = e,
        this.styleID++)
    }
    get fillGradientType() {
        return this._fillGradientType
    }
    set fillGradientType(t) {
        this._fillGradientType !== t && (this._fillGradientType = t,
        this.styleID++)
    }
    get fillGradientStops() {
        return this._fillGradientStops
    }
    set fillGradientStops(t) {
        tM(this._fillGradientStops, t) || (this._fillGradientStops = t,
        this.styleID++)
    }
    get fontFamily() {
        return this._fontFamily
    }
    set fontFamily(t) {
        this.fontFamily !== t && (this._fontFamily = t,
        this.styleID++)
    }
    get fontSize() {
        return this._fontSize
    }
    set fontSize(t) {
        this._fontSize !== t && (this._fontSize = t,
        this.styleID++)
    }
    get fontStyle() {
        return this._fontStyle
    }
    set fontStyle(t) {
        this._fontStyle !== t && (this._fontStyle = t,
        this.styleID++)
    }
    get fontVariant() {
        return this._fontVariant
    }
    set fontVariant(t) {
        this._fontVariant !== t && (this._fontVariant = t,
        this.styleID++)
    }
    get fontWeight() {
        return this._fontWeight
    }
    set fontWeight(t) {
        this._fontWeight !== t && (this._fontWeight = t,
        this.styleID++)
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(t) {
        this._letterSpacing !== t && (this._letterSpacing = t,
        this.styleID++)
    }
    get lineHeight() {
        return this._lineHeight
    }
    set lineHeight(t) {
        this._lineHeight !== t && (this._lineHeight = t,
        this.styleID++)
    }
    get leading() {
        return this._leading
    }
    set leading(t) {
        this._leading !== t && (this._leading = t,
        this.styleID++)
    }
    get lineJoin() {
        return this._lineJoin
    }
    set lineJoin(t) {
        this._lineJoin !== t && (this._lineJoin = t,
        this.styleID++)
    }
    get miterLimit() {
        return this._miterLimit
    }
    set miterLimit(t) {
        this._miterLimit !== t && (this._miterLimit = t,
        this.styleID++)
    }
    get padding() {
        return this._padding
    }
    set padding(t) {
        this._padding !== t && (this._padding = t,
        this.styleID++)
    }
    get stroke() {
        return this._stroke
    }
    set stroke(t) {
        const e = jd(t);
        this._stroke !== e && (this._stroke = e,
        this.styleID++)
    }
    get strokeThickness() {
        return this._strokeThickness
    }
    set strokeThickness(t) {
        this._strokeThickness !== t && (this._strokeThickness = t,
        this.styleID++)
    }
    get textBaseline() {
        return this._textBaseline
    }
    set textBaseline(t) {
        this._textBaseline !== t && (this._textBaseline = t,
        this.styleID++)
    }
    get trim() {
        return this._trim
    }
    set trim(t) {
        this._trim !== t && (this._trim = t,
        this.styleID++)
    }
    get whiteSpace() {
        return this._whiteSpace
    }
    set whiteSpace(t) {
        this._whiteSpace !== t && (this._whiteSpace = t,
        this.styleID++)
    }
    get wordWrap() {
        return this._wordWrap
    }
    set wordWrap(t) {
        this._wordWrap !== t && (this._wordWrap = t,
        this.styleID++)
    }
    get wordWrapWidth() {
        return this._wordWrapWidth
    }
    set wordWrapWidth(t) {
        this._wordWrapWidth !== t && (this._wordWrapWidth = t,
        this.styleID++)
    }
    toFontString() {
        const t = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
        let e = this.fontFamily;
        Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
        for (let i = e.length - 1; i >= 0; i--) {
            let r = e[i].trim();
            !/([\"\'])[^\'\"]+\1/.test(r) && !JR.includes(r) && (r = `"${r}"`),
            e[i] = r
        }
        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${e.join(",")}`
    }
}
;
Zb.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: ih.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
let Ts = Zb;
function jd(s) {
    const t = zt.shared
      , e = i=>{
        const r = t.setValue(i);
        return r.alpha === 1 ? r.toHex() : r.toRgbaString()
    }
    ;
    return Array.isArray(s) ? s.map(e) : e(s)
}
function tM(s, t) {
    if (!Array.isArray(s) || !Array.isArray(t) || s.length !== t.length)
        return !1;
    for (let e = 0; e < s.length; ++e)
        if (s[e] !== t[e])
            return !1;
    return !0
}
function qd(s, t, e) {
    for (const i in e)
        Array.isArray(t[i]) ? s[i] = t[i].slice() : s[i] = t[i]
}
const eM = {
    texture: !0,
    children: !1,
    baseTexture: !0
}
  , Qb = class Ip extends ae {
    constructor(t, e, i) {
        let r = !1;
        i || (i = nt.ADAPTER.createCanvas(),
        r = !0),
        i.width = 3,
        i.height = 3;
        const n = st.from(i);
        n.orig = new St,
        n.trim = new St,
        super(n),
        this._ownCanvas = r,
        this.canvas = i,
        this.context = i.getContext("2d", {
            willReadFrequently: !0
        }),
        this._resolution = Ip.defaultResolution ?? nt.RESOLUTION,
        this._autoResolution = Ip.defaultAutoResolution,
        this._text = null,
        this._style = null,
        this._styleListener = null,
        this._font = "",
        this.text = t,
        this.style = e,
        this.localStyleID = -1
    }
    static get experimentalLetterSpacing() {
        return cs.experimentalLetterSpacing
    }
    static set experimentalLetterSpacing(t) {
        Et("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"),
        cs.experimentalLetterSpacing = t
    }
    updateText(t) {
        const e = this._style;
        if (this.localStyleID !== e.styleID && (this.dirty = !0,
        this.localStyleID = e.styleID),
        !this.dirty && t)
            return;
        this._font = this._style.toFontString();
        const i = this.context
          , r = cs.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas)
          , n = r.width
          , o = r.height
          , a = r.lines
          , l = r.lineHeight
          , h = r.lineWidths
          , u = r.maxLineWidth
          , c = r.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, n) + e.padding * 2) * this._resolution),
        this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + e.padding * 2) * this._resolution),
        i.scale(this._resolution, this._resolution),
        i.clearRect(0, 0, this.canvas.width, this.canvas.height),
        i.font = this._font,
        i.lineWidth = e.strokeThickness,
        i.textBaseline = e.textBaseline,
        i.lineJoin = e.lineJoin,
        i.miterLimit = e.miterLimit;
        let d, f;
        const p = e.dropShadow ? 2 : 1;
        for (let m = 0; m < p; ++m) {
            const g = e.dropShadow && m === 0
              , _ = g ? Math.ceil(Math.max(1, o) + e.padding * 2) : 0
              , x = _ * this._resolution;
            if (g) {
                i.fillStyle = "black",
                i.strokeStyle = "black";
                const v = e.dropShadowColor
                  , E = e.dropShadowBlur * this._resolution
                  , P = e.dropShadowDistance * this._resolution;
                i.shadowColor = zt.shared.setValue(v).setAlpha(e.dropShadowAlpha).toRgbaString(),
                i.shadowBlur = E,
                i.shadowOffsetX = Math.cos(e.dropShadowAngle) * P,
                i.shadowOffsetY = Math.sin(e.dropShadowAngle) * P + x
            } else
                i.fillStyle = this._generateFillStyle(e, a, r),
                i.strokeStyle = e.stroke,
                i.shadowColor = "black",
                i.shadowBlur = 0,
                i.shadowOffsetX = 0,
                i.shadowOffsetY = 0;
            let y = (l - c.fontSize) / 2;
            l - c.fontSize < 0 && (y = 0);
            for (let v = 0; v < a.length; v++)
                d = e.strokeThickness / 2,
                f = e.strokeThickness / 2 + v * l + c.ascent + y,
                e.align === "right" ? d += u - h[v] : e.align === "center" && (d += (u - h[v]) / 2),
                e.stroke && e.strokeThickness && this.drawLetterSpacing(a[v], d + e.padding, f + e.padding - _, !0),
                e.fill && this.drawLetterSpacing(a[v], d + e.padding, f + e.padding - _)
        }
        this.updateTexture()
    }
    drawLetterSpacing(t, e, i, r=!1) {
        const n = this._style.letterSpacing;
        let o = !1;
        if (cs.experimentalLetterSpacingSupported && (cs.experimentalLetterSpacing ? (this.context.letterSpacing = `${n}px`,
        this.context.textLetterSpacing = `${n}px`,
        o = !0) : (this.context.letterSpacing = "0px",
        this.context.textLetterSpacing = "0px")),
        n === 0 || o) {
            r ? this.context.strokeText(t, e, i) : this.context.fillText(t, e, i);
            return
        }
        let a = e;
        const l = cs.graphemeSegmenter(t);
        let h = this.context.measureText(t).width
          , u = 0;
        for (let c = 0; c < l.length; ++c) {
            const d = l[c];
            r ? this.context.strokeText(d, a, i) : this.context.fillText(d, a, i);
            let f = "";
            for (let p = c + 1; p < l.length; ++p)
                f += l[p];
            u = this.context.measureText(f).width,
            a += h - u + n,
            h = u
        }
    }
    updateTexture() {
        const t = this.canvas;
        if (this._style.trim) {
            const o = f1(t);
            o.data && (t.width = o.width,
            t.height = o.height,
            this.context.putImageData(o.data, 0, 0))
        }
        const e = this._texture
          , i = this._style
          , r = i.trim ? 0 : i.padding
          , n = e.baseTexture;
        e.trim.width = e._frame.width = t.width / this._resolution,
        e.trim.height = e._frame.height = t.height / this._resolution,
        e.trim.x = -r,
        e.trim.y = -r,
        e.orig.width = e._frame.width - r * 2,
        e.orig.height = e._frame.height - r * 2,
        this._onTextureUpdate(),
        n.setRealSize(t.width, t.height, this._resolution),
        e.updateUvs(),
        this.dirty = !1
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(t)
    }
    updateTransform() {
        this.updateText(!0),
        super.updateTransform()
    }
    getBounds(t, e) {
        return this.updateText(!0),
        this._textureID === -1 && (t = !1),
        super.getBounds(t, e)
    }
    getLocalBounds(t) {
        return this.updateText(!0),
        super.getLocalBounds.call(this, t)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _generateFillStyle(t, e, i) {
        const r = t.fill;
        if (Array.isArray(r)) {
            if (r.length === 1)
                return r[0]
        } else
            return r;
        let n;
        const o = t.dropShadow ? t.dropShadowDistance : 0
          , a = t.padding || 0
          , l = this.canvas.width / this._resolution - o - a * 2
          , h = this.canvas.height / this._resolution - o - a * 2
          , u = r.slice()
          , c = t.fillGradientStops.slice();
        if (!c.length) {
            const d = u.length + 1;
            for (let f = 1; f < d; ++f)
                c.push(f / d)
        }
        if (u.unshift(r[0]),
        c.unshift(0),
        u.push(r[r.length - 1]),
        c.push(1),
        t.fillGradientType === ih.LINEAR_VERTICAL) {
            n = this.context.createLinearGradient(l / 2, a, l / 2, h + a);
            const d = i.fontProperties.fontSize + t.strokeThickness;
            for (let f = 0; f < e.length; f++) {
                const p = i.lineHeight * (f - 1) + d
                  , m = i.lineHeight * f;
                let g = m;
                f > 0 && p > m && (g = (m + p) / 2);
                const _ = m + d
                  , x = i.lineHeight * (f + 1);
                let y = _;
                f + 1 < e.length && x < _ && (y = (_ + x) / 2);
                const v = (y - g) / h;
                for (let E = 0; E < u.length; E++) {
                    let P = 0;
                    typeof c[E] == "number" ? P = c[E] : P = E / u.length;
                    let w = Math.min(1, Math.max(0, g / h + P * v));
                    w = Number(w.toFixed(5)),
                    n.addColorStop(w, u[E])
                }
            }
        } else {
            n = this.context.createLinearGradient(a, h / 2, l + a, h / 2);
            const d = u.length + 1;
            let f = 1;
            for (let p = 0; p < u.length; p++) {
                let m;
                typeof c[p] == "number" ? m = c[p] : m = f / d,
                n.addColorStop(m, u[p]),
                f++
            }
        }
        return n
    }
    destroy(t) {
        typeof t == "boolean" && (t = {
            children: t
        }),
        t = Object.assign({}, eM, t),
        super.destroy(t),
        this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
        this.context = null,
        this.canvas = null,
        this._style = null
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        this.updateText(!0);
        const e = gs(this.scale.x) || 1;
        this.scale.x = e * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        this.updateText(!0);
        const e = gs(this.scale.y) || 1;
        this.scale.y = e * t / this._texture.orig.height,
        this._height = t
    }
    get style() {
        return this._style
    }
    set style(t) {
        t = t || {},
        t instanceof Ts ? this._style = t : this._style = new Ts(t),
        this.localStyleID = -1,
        this.dirty = !0
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(t ?? ""),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
}
;
Qb.defaultAutoResolution = !0;
let gg = Qb;
class Jb {
    constructor(t) {
        this.maxItemsPerFrame = t,
        this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}
function iM(s, t) {
    let e = !1;
    if (s?._textures?.length) {
        for (let i = 0; i < s._textures.length; i++)
            if (s._textures[i]instanceof st) {
                const r = s._textures[i].baseTexture;
                t.includes(r) || (t.push(r),
                e = !0)
            }
    }
    return e
}
function rM(s, t) {
    if (s.baseTexture instanceof At) {
        const e = s.baseTexture;
        return t.includes(e) || t.push(e),
        !0
    }
    return !1
}
function sM(s, t) {
    if (s._texture && s._texture instanceof st) {
        const e = s._texture.baseTexture;
        return t.includes(e) || t.push(e),
        !0
    }
    return !1
}
function nM(s, t) {
    return t instanceof gg ? (t.updateText(!0),
    !0) : !1
}
function oM(s, t) {
    if (t instanceof Ts) {
        const e = t.toFontString();
        return cs.measureFont(e),
        !0
    }
    return !1
}
function aM(s, t) {
    if (s instanceof gg) {
        t.includes(s.style) || t.push(s.style),
        t.includes(s) || t.push(s);
        const e = s._texture.baseTexture;
        return t.includes(e) || t.push(e),
        !0
    }
    return !1
}
function lM(s, t) {
    return s instanceof Ts ? (t.includes(s) || t.push(s),
    !0) : !1
}
const tw = class ew {
    constructor(t) {
        this.limiter = new Jb(ew.uploadsPerFrame),
        this.renderer = t,
        this.uploadHookHelper = null,
        this.queue = [],
        this.addHooks = [],
        this.uploadHooks = [],
        this.completes = [],
        this.ticking = !1,
        this.delayedTick = ()=>{
            this.queue && this.prepareItems()
        }
        ,
        this.registerFindHook(aM),
        this.registerFindHook(lM),
        this.registerFindHook(iM),
        this.registerFindHook(rM),
        this.registerFindHook(sM),
        this.registerUploadHook(nM),
        this.registerUploadHook(oM)
    }
    upload(t) {
        return new Promise(e=>{
            t && this.add(t),
            this.queue.length ? (this.completes.push(e),
            this.ticking || (this.ticking = !0,
            Ue.system.addOnce(this.tick, this, Es.UTILITY))) : e()
        }
        )
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
            const t = this.queue[0];
            let e = !1;
            if (t && !t._destroyed) {
                for (let i = 0, r = this.uploadHooks.length; i < r; i++)
                    if (this.uploadHooks[i](this.uploadHookHelper, t)) {
                        this.queue.shift(),
                        e = !0;
                        break
                    }
            }
            e || this.queue.shift()
        }
        if (this.queue.length)
            Ue.system.addOnce(this.tick, this, Es.UTILITY);
        else {
            this.ticking = !1;
            const t = this.completes.slice(0);
            this.completes.length = 0;
            for (let e = 0, i = t.length; e < i; e++)
                t[e]()
        }
    }
    registerFindHook(t) {
        return t && this.addHooks.push(t),
        this
    }
    registerUploadHook(t) {
        return t && this.uploadHooks.push(t),
        this
    }
    add(t) {
        for (let e = 0, i = this.addHooks.length; e < i && !this.addHooks[e](t, this.queue); e++)
            ;
        if (t instanceof Si)
            for (let e = t.children.length - 1; e >= 0; e--)
                this.add(t.children[e]);
        return this
    }
    destroy() {
        this.ticking && Ue.system.remove(this.tick, this),
        this.ticking = !1,
        this.addHooks = null,
        this.uploadHooks = null,
        this.renderer = null,
        this.completes = null,
        this.queue = null,
        this.limiter = null,
        this.uploadHookHelper = null
    }
}
;
tw.uploadsPerFrame = 4;
let hc = tw;
Object.defineProperties(nt, {
    UPLOADS_PER_FRAME: {
        get() {
            return hc.uploadsPerFrame
        },
        set(s) {
            Et("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"),
            hc.uploadsPerFrame = s
        }
    }
});
function iw(s, t) {
    return t instanceof At ? (t._glTextures[s.CONTEXT_UID] || s.texture.bind(t),
    !0) : !1
}
function hM(s, t) {
    if (!(t instanceof Lc))
        return !1;
    const {geometry: e} = t;
    t.finishPoly(),
    e.updateBatches();
    const {batches: i} = e;
    for (let r = 0; r < i.length; r++) {
        const {texture: n} = i[r].style;
        n && iw(s, n.baseTexture)
    }
    return e.batchable || s.geometry.bind(e, t._resolveDirectShader(s)),
    !0
}
function uM(s, t) {
    return s instanceof Lc ? (t.push(s),
    !0) : !1
}
class _g extends hc {
    constructor(t) {
        super(t),
        this.uploadHookHelper = this.renderer,
        this.registerFindHook(uM),
        this.registerUploadHook(iw),
        this.registerUploadHook(hM)
    }
}
_g.extension = {
    name: "prepare",
    type: it.RendererSystem
};
ct.add(_g);
class cM {
    constructor(t) {
        this.maxMilliseconds = t,
        this.frameStart = 0
    }
    beginFrame() {
        this.frameStart = Date.now()
    }
    allowedToUpload() {
        return Date.now() - this.frameStart < this.maxMilliseconds
    }
}
class uc extends ae {
    constructor(t, e=!0) {
        super(t[0]instanceof st ? t[0] : t[0].texture),
        this._textures = null,
        this._durations = null,
        this._autoUpdate = e,
        this._isConnectedToTicker = !1,
        this.animationSpeed = 1,
        this.loop = !0,
        this.updateAnchor = !1,
        this.onComplete = null,
        this.onFrameChange = null,
        this.onLoop = null,
        this._currentTime = 0,
        this._playing = !1,
        this._previousFrame = null,
        this.textures = t
    }
    stop() {
        this._playing && (this._playing = !1,
        this._autoUpdate && this._isConnectedToTicker && (Ue.shared.remove(this.update, this),
        this._isConnectedToTicker = !1))
    }
    play() {
        this._playing || (this._playing = !0,
        this._autoUpdate && !this._isConnectedToTicker && (Ue.shared.add(this.update, this, Es.HIGH),
        this._isConnectedToTicker = !0))
    }
    gotoAndStop(t) {
        this.stop(),
        this.currentFrame = t
    }
    gotoAndPlay(t) {
        this.currentFrame = t,
        this.play()
    }
    update(t) {
        if (!this._playing)
            return;
        const e = this.animationSpeed * t
          , i = this.currentFrame;
        if (this._durations !== null) {
            let r = this._currentTime % 1 * this._durations[this.currentFrame];
            for (r += e / 60 * 1e3; r < 0; )
                this._currentTime--,
                r += this._durations[this.currentFrame];
            const n = Math.sign(this.animationSpeed * t);
            for (this._currentTime = Math.floor(this._currentTime); r >= this._durations[this.currentFrame]; )
                r -= this._durations[this.currentFrame] * n,
                this._currentTime += n;
            this._currentTime += r / this._durations[this.currentFrame]
        } else
            this._currentTime += e;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0),
        this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1),
        this.onComplete && this.onComplete()) : i !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i || this.animationSpeed < 0 && this.currentFrame > i) && this.onLoop(),
        this.updateTexture())
    }
    updateTexture() {
        const t = this.currentFrame;
        this._previousFrame !== t && (this._previousFrame = t,
        this._texture = this._textures[t],
        this._textureID = -1,
        this._textureTrimmedID = -1,
        this._cachedTint = 16777215,
        this.uvs = this._texture._uvs.uvsFloat32,
        this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor),
        this.onFrameChange && this.onFrameChange(this.currentFrame))
    }
    destroy(t) {
        this.stop(),
        super.destroy(t),
        this.onComplete = null,
        this.onFrameChange = null,
        this.onLoop = null
    }
    static fromFrames(t) {
        const e = [];
        for (let i = 0; i < t.length; ++i)
            e.push(st.from(t[i]));
        return new uc(e)
    }
    static fromImages(t) {
        const e = [];
        for (let i = 0; i < t.length; ++i)
            e.push(st.from(t[i]));
        return new uc(e)
    }
    get totalFrames() {
        return this._textures.length
    }
    get textures() {
        return this._textures
    }
    set textures(t) {
        if (t[0]instanceof st)
            this._textures = t,
            this._durations = null;
        else {
            this._textures = [],
            this._durations = [];
            for (let e = 0; e < t.length; e++)
                this._textures.push(t[e].texture),
                this._durations.push(t[e].time)
        }
        this._previousFrame = null,
        this.gotoAndStop(0),
        this.updateTexture()
    }
    get currentFrame() {
        let t = Math.floor(this._currentTime) % this._textures.length;
        return t < 0 && (t += this._textures.length),
        t
    }
    set currentFrame(t) {
        if (t < 0 || t > this.totalFrames - 1)
            throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
        const e = this.currentFrame;
        this._currentTime = t,
        e !== this.currentFrame && this.updateTexture()
    }
    get playing() {
        return this._playing
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t,
        !this._autoUpdate && this._isConnectedToTicker ? (Ue.shared.remove(this.update, this),
        this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ue.shared.add(this.update, this),
        this._isConnectedToTicker = !0))
    }
}
const Aa = new Nt;
class yg extends ae {
    constructor(t, e=100, i=100) {
        super(t),
        this.tileTransform = new Zl,
        this._width = e,
        this._height = i,
        this.uvMatrix = this.texture.uvMatrix || new Mc(t),
        this.pluginName = "tilingSprite",
        this.uvRespectAnchor = !1
    }
    get clampMargin() {
        return this.uvMatrix.clampMargin
    }
    set clampMargin(t) {
        this.uvMatrix.clampMargin = t,
        this.uvMatrix.update(!0)
    }
    get tileScale() {
        return this.tileTransform.scale
    }
    set tileScale(t) {
        this.tileTransform.scale.copyFrom(t)
    }
    get tilePosition() {
        return this.tileTransform.position
    }
    set tilePosition(t) {
        this.tileTransform.position.copyFrom(t)
    }
    _onTextureUpdate() {
        this.uvMatrix && (this.uvMatrix.texture = this._texture),
        this._cachedTint = 16777215
    }
    _render(t) {
        const e = this._texture;
        !e || !e.valid || (this.tileTransform.updateLocalTransform(),
        this.uvMatrix.update(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this))
    }
    _calculateBounds() {
        const t = this._width * -this._anchor._x
          , e = this._height * -this._anchor._y
          , i = this._width * (1 - this._anchor._x)
          , r = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, t, e, i, r)
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x,
        this._bounds.minY = this._height * -this._anchor._y,
        this._bounds.maxX = this._width * (1 - this._anchor._x),
        this._bounds.maxY = this._height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new St),
        t = this._localBoundsRect),
        this._bounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, Aa);
        const e = this._width
          , i = this._height
          , r = -e * this.anchor._x;
        if (Aa.x >= r && Aa.x < r + e) {
            const n = -i * this.anchor._y;
            if (Aa.y >= n && Aa.y < n + i)
                return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t),
        this.tileTransform = null,
        this.uvMatrix = null
    }
    static from(t, e) {
        const i = t instanceof st ? t : st.from(t, e);
        return new yg(i,e.width,e.height)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t
    }
}
var dM = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`
  , fM = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
  , pM = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`
  , cy = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
  , mM = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Yh = new Qt;
class vg extends Ql {
    constructor(t) {
        super(t),
        t.runners.contextChange.add(this),
        this.quad = new zm,
        this.state = Sr.for2d()
    }
    contextChange() {
        const t = this.renderer
          , e = {
            globals: t.globalUniforms
        };
        this.simpleShader = Dr.from(cy, mM, e),
        this.shader = t.context.webGLVersion > 1 ? Dr.from(fM, dM, e) : Dr.from(cy, pM, e)
    }
    render(t) {
        const e = this.renderer
          , i = this.quad;
        let r = i.vertices;
        r[0] = r[6] = t._width * -t.anchor.x,
        r[1] = r[3] = t._height * -t.anchor.y,
        r[2] = r[4] = t._width * (1 - t.anchor.x),
        r[5] = r[7] = t._height * (1 - t.anchor.y);
        const n = t.uvRespectAnchor ? t.anchor.x : 0
          , o = t.uvRespectAnchor ? t.anchor.y : 0;
        r = i.uvs,
        r[0] = r[6] = -n,
        r[1] = r[3] = -o,
        r[2] = r[4] = 1 - n,
        r[5] = r[7] = 1 - o,
        i.invalidate();
        const a = t._texture
          , l = a.baseTexture
          , h = l.alphaMode > 0
          , u = t.tileTransform.localTransform
          , c = t.uvMatrix;
        let d = l.isPowerOfTwo && a.frame.width === l.width && a.frame.height === l.height;
        d && (l._glTextures[e.CONTEXT_UID] ? d = l.wrapMode !== Jr.CLAMP : l.wrapMode === Jr.CLAMP && (l.wrapMode = Jr.REPEAT));
        const f = d ? this.simpleShader : this.shader
          , p = a.width
          , m = a.height
          , g = t._width
          , _ = t._height;
        Yh.set(u.a * p / g, u.b * p / _, u.c * m / g, u.d * m / _, u.tx / g, u.ty / _),
        Yh.invert(),
        d ? Yh.prepend(c.mapCoord) : (f.uniforms.uMapCoord = c.mapCoord.toArray(!0),
        f.uniforms.uClampFrame = c.uClampFrame,
        f.uniforms.uClampOffset = c.uClampOffset),
        f.uniforms.uTransform = Yh.toArray(!0),
        f.uniforms.uColor = zt.shared.setValue(t.tint).premultiply(t.worldAlpha, h).toArray(f.uniforms.uColor),
        f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0),
        f.uniforms.uSampler = a,
        e.shader.bind(f),
        e.geometry.bind(i),
        this.state.blendMode = km(t.blendMode, h),
        e.state.set(this.state),
        e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
vg.extension = {
    name: "tilingSprite",
    type: it.RendererPlugin
};
ct.add(vg);
const rw = class Va {
    constructor(t, e, i) {
        this.linkedSheets = [],
        (t instanceof At || t instanceof st) && (t = {
            texture: t,
            data: e,
            resolutionFilename: i
        });
        const {texture: r, data: n, resolutionFilename: o=null, cachePrefix: a=""} = t;
        this.cachePrefix = a,
        this._texture = r instanceof st ? r : null,
        this.baseTexture = r instanceof At ? r : this._texture.baseTexture,
        this.textures = {},
        this.animations = {},
        this.data = n;
        const l = this.baseTexture.resource;
        this.resolution = this._updateResolution(o || (l ? l.url : null)),
        this._frames = this.data.frames,
        this._frameKeys = Object.keys(this._frames),
        this._batchIndex = 0,
        this._callback = null
    }
    _updateResolution(t=null) {
        const {scale: e} = this.data.meta;
        let i = is(t, null);
        return i === null && (i = typeof e == "number" ? e : parseFloat(e ?? "1")),
        i !== 1 && this.baseTexture.setResolution(i),
        i
    }
    parse() {
        return new Promise(t=>{
            this._callback = t,
            this._batchIndex = 0,
            this._frameKeys.length <= Va.BATCH_SIZE ? (this._processFrames(0),
            this._processAnimations(),
            this._parseComplete()) : this._nextBatch()
        }
        )
    }
    _processFrames(t) {
        let e = t;
        const i = Va.BATCH_SIZE;
        for (; e - t < i && e < this._frameKeys.length; ) {
            const r = this._frameKeys[e]
              , n = this._frames[r]
              , o = n.frame;
            if (o) {
                let a = null
                  , l = null;
                const h = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame
                  , u = new St(0,0,Math.floor(h.w) / this.resolution,Math.floor(h.h) / this.resolution);
                n.rotated ? a = new St(Math.floor(o.x) / this.resolution,Math.floor(o.y) / this.resolution,Math.floor(o.h) / this.resolution,Math.floor(o.w) / this.resolution) : a = new St(Math.floor(o.x) / this.resolution,Math.floor(o.y) / this.resolution,Math.floor(o.w) / this.resolution,Math.floor(o.h) / this.resolution),
                n.trimmed !== !1 && n.spriteSourceSize && (l = new St(Math.floor(n.spriteSourceSize.x) / this.resolution,Math.floor(n.spriteSourceSize.y) / this.resolution,Math.floor(o.w) / this.resolution,Math.floor(o.h) / this.resolution)),
                this.textures[r] = new st(this.baseTexture,a,u,l,n.rotated ? 2 : 0,n.anchor,n.borders),
                st.addToCache(this.textures[r], this.cachePrefix + r.toString())
            }
            e++
        }
    }
    _processAnimations() {
        const t = this.data.animations || {};
        for (const e in t) {
            this.animations[e] = [];
            for (let i = 0; i < t[e].length; i++) {
                const r = t[e][i];
                this.animations[e].push(this.textures[r])
            }
        }
    }
    _parseComplete() {
        const t = this._callback;
        this._callback = null,
        this._batchIndex = 0,
        t.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * Va.BATCH_SIZE),
        this._batchIndex++,
        setTimeout(()=>{
            this._batchIndex * Va.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
            this._parseComplete())
        }
        , 0)
    }
    destroy(t=!1) {
        for (const e in this.textures)
            this.textures[e].destroy();
        this._frames = null,
        this._frameKeys = null,
        this.data = null,
        this.textures = null,
        t && (this._texture?.destroy(),
        this.baseTexture.destroy()),
        this._texture = null,
        this.baseTexture = null,
        this.linkedSheets = []
    }
}
;
rw.BATCH_SIZE = 1e3;
let Rp = rw;
const gM = ["jpg", "png", "jpeg", "avif", "webp"];
function sw(s, t, e) {
    const i = {};
    if (s.forEach(r=>{
        i[r] = t
    }
    ),
    Object.keys(t.textures).forEach(r=>{
        i[`${t.cachePrefix}${r}`] = t.textures[r]
    }
    ),
    !e) {
        const r = Ee.dirname(s[0]);
        t.linkedSheets.forEach((n,o)=>{
            Object.assign(i, sw([`${r}/${t.data.meta.related_multi_packs[o]}`], n, !0))
        }
        )
    }
    return i
}
const nw = {
    extension: it.Asset,
    cache: {
        test: s=>s instanceof Rp,
        getCacheableAssets: (s,t)=>sw(s, t, !1)
    },
    resolver: {
        test: s=>{
            const t = s.split("?")[0].split(".")
              , e = t.pop()
              , i = t.pop();
            return e === "json" && gM.includes(i)
        }
        ,
        parse: s=>{
            const t = s.split(".");
            return {
                resolution: parseFloat(nt.RETINA_PREFIX.exec(s)?.[1] ?? "1"),
                format: t[t.length - 2],
                src: s
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: it.LoadParser,
            priority: hr.Normal
        },
        async testParse(s, t) {
            return Ee.extname(t.src).toLowerCase() === ".json" && !!s.frames
        },
        async parse(s, t, e) {
            const {texture: i, imageFilename: r, cachePrefix: n} = t?.data ?? {};
            let o = Ee.dirname(t.src);
            o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
            let a;
            if (i && i.baseTexture)
                a = i;
            else {
                const u = lc(o + (r ?? s.meta.image), t.src);
                a = (await e.load([u]))[u]
            }
            const l = new Rp({
                texture: a.baseTexture,
                data: s,
                resolutionFilename: t.src,
                cachePrefix: n
            });
            await l.parse();
            const h = s?.meta?.related_multi_packs;
            if (Array.isArray(h)) {
                const u = [];
                for (const d of h) {
                    if (typeof d != "string")
                        continue;
                    let f = o + d;
                    t.data?.ignoreMultiPack || (f = lc(f, t.src),
                    u.push(e.load({
                        src: f,
                        data: {
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const c = await Promise.all(u);
                l.linkedSheets = c,
                c.forEach(d=>{
                    d.linkedSheets = [l].concat(l.linkedSheets.filter(f=>f !== d))
                }
                )
            }
            return l
        },
        unload(s) {
            s.destroy(!0)
        }
    }
};
ct.add(nw);
class Vl {
    constructor() {
        this.info = [],
        this.common = [],
        this.page = [],
        this.char = [],
        this.kerning = [],
        this.distanceField = []
    }
}
class ml {
    static test(t) {
        return typeof t == "string" && t.startsWith("info face=")
    }
    static parse(t) {
        const e = t.match(/^[a-z]+\s+.+$/gm)
          , i = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
        };
        for (const n in e) {
            const o = e[n].match(/^[a-z]+/gm)[0]
              , a = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
              , l = {};
            for (const h in a) {
                const u = a[h].split("=")
                  , c = u[0]
                  , d = u[1].replace(/"/gm, "")
                  , f = parseFloat(d)
                  , p = isNaN(f) ? d : f;
                l[c] = p
            }
            i[o].push(l)
        }
        const r = new Vl;
        return i.info.forEach(n=>r.info.push({
            face: n.face,
            size: parseInt(n.size, 10)
        })),
        i.common.forEach(n=>r.common.push({
            lineHeight: parseInt(n.lineHeight, 10)
        })),
        i.page.forEach(n=>r.page.push({
            id: parseInt(n.id, 10),
            file: n.file
        })),
        i.char.forEach(n=>r.char.push({
            id: parseInt(n.id, 10),
            page: parseInt(n.page, 10),
            x: parseInt(n.x, 10),
            y: parseInt(n.y, 10),
            width: parseInt(n.width, 10),
            height: parseInt(n.height, 10),
            xoffset: parseInt(n.xoffset, 10),
            yoffset: parseInt(n.yoffset, 10),
            xadvance: parseInt(n.xadvance, 10)
        })),
        i.kerning.forEach(n=>r.kerning.push({
            first: parseInt(n.first, 10),
            second: parseInt(n.second, 10),
            amount: parseInt(n.amount, 10)
        })),
        i.distanceField.forEach(n=>r.distanceField.push({
            distanceRange: parseInt(n.distanceRange, 10),
            fieldType: n.fieldType
        })),
        r
    }
}
class cc {
    static test(t) {
        const e = t;
        return typeof t != "string" && "getElementsByTagName"in t && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null
    }
    static parse(t) {
        const e = new Vl
          , i = t.getElementsByTagName("info")
          , r = t.getElementsByTagName("common")
          , n = t.getElementsByTagName("page")
          , o = t.getElementsByTagName("char")
          , a = t.getElementsByTagName("kerning")
          , l = t.getElementsByTagName("distanceField");
        for (let h = 0; h < i.length; h++)
            e.info.push({
                face: i[h].getAttribute("face"),
                size: parseInt(i[h].getAttribute("size"), 10)
            });
        for (let h = 0; h < r.length; h++)
            e.common.push({
                lineHeight: parseInt(r[h].getAttribute("lineHeight"), 10)
            });
        for (let h = 0; h < n.length; h++)
            e.page.push({
                id: parseInt(n[h].getAttribute("id"), 10) || 0,
                file: n[h].getAttribute("file")
            });
        for (let h = 0; h < o.length; h++) {
            const u = o[h];
            e.char.push({
                id: parseInt(u.getAttribute("id"), 10),
                page: parseInt(u.getAttribute("page"), 10) || 0,
                x: parseInt(u.getAttribute("x"), 10),
                y: parseInt(u.getAttribute("y"), 10),
                width: parseInt(u.getAttribute("width"), 10),
                height: parseInt(u.getAttribute("height"), 10),
                xoffset: parseInt(u.getAttribute("xoffset"), 10),
                yoffset: parseInt(u.getAttribute("yoffset"), 10),
                xadvance: parseInt(u.getAttribute("xadvance"), 10)
            })
        }
        for (let h = 0; h < a.length; h++)
            e.kerning.push({
                first: parseInt(a[h].getAttribute("first"), 10),
                second: parseInt(a[h].getAttribute("second"), 10),
                amount: parseInt(a[h].getAttribute("amount"), 10)
            });
        for (let h = 0; h < l.length; h++)
            e.distanceField.push({
                fieldType: l[h].getAttribute("fieldType"),
                distanceRange: parseInt(l[h].getAttribute("distanceRange"), 10)
            });
        return e
    }
}
class dc {
    static test(t) {
        return typeof t == "string" && t.includes("<font>") ? cc.test(nt.ADAPTER.parseXML(t)) : !1
    }
    static parse(t) {
        return cc.parse(nt.ADAPTER.parseXML(t))
    }
}
const Yd = [ml, cc, dc];
function ow(s) {
    for (let t = 0; t < Yd.length; t++)
        if (Yd[t].test(s))
            return Yd[t];
    return null
}
function _M(s, t, e, i, r, n) {
    const o = e.fill;
    if (Array.isArray(o)) {
        if (o.length === 1)
            return o[0]
    } else
        return o;
    let a;
    const l = e.dropShadow ? e.dropShadowDistance : 0
      , h = e.padding || 0
      , u = s.width / i - l - h * 2
      , c = s.height / i - l - h * 2
      , d = o.slice()
      , f = e.fillGradientStops.slice();
    if (!f.length) {
        const p = d.length + 1;
        for (let m = 1; m < p; ++m)
            f.push(m / p)
    }
    if (d.unshift(o[0]),
    f.unshift(0),
    d.push(o[o.length - 1]),
    f.push(1),
    e.fillGradientType === ih.LINEAR_VERTICAL) {
        a = t.createLinearGradient(u / 2, h, u / 2, c + h);
        let p = 0;
        const m = (n.fontProperties.fontSize + e.strokeThickness) / c;
        for (let g = 0; g < r.length; g++) {
            const _ = n.lineHeight * g;
            for (let x = 0; x < d.length; x++) {
                let y = 0;
                typeof f[x] == "number" ? y = f[x] : y = x / d.length;
                const v = _ / c + y * m;
                let E = Math.max(p, v);
                E = Math.min(E, 1),
                a.addColorStop(E, d[x]),
                p = E
            }
        }
    } else {
        a = t.createLinearGradient(h, c / 2, u + h, c / 2);
        const p = d.length + 1;
        let m = 1;
        for (let g = 0; g < d.length; g++) {
            let _;
            typeof f[g] == "number" ? _ = f[g] : _ = m / p,
            a.addColorStop(_, d[g]),
            m++
        }
    }
    return a
}
function yM(s, t, e, i, r, n, o) {
    const a = e.text
      , l = e.fontProperties;
    t.translate(i, r),
    t.scale(n, n);
    const h = o.strokeThickness / 2
      , u = -(o.strokeThickness / 2);
    if (t.font = o.toFontString(),
    t.lineWidth = o.strokeThickness,
    t.textBaseline = o.textBaseline,
    t.lineJoin = o.lineJoin,
    t.miterLimit = o.miterLimit,
    t.fillStyle = _M(s, t, o, n, [a], e),
    t.strokeStyle = o.stroke,
    o.dropShadow) {
        const c = o.dropShadowColor
          , d = o.dropShadowBlur * n
          , f = o.dropShadowDistance * n;
        t.shadowColor = zt.shared.setValue(c).setAlpha(o.dropShadowAlpha).toRgbaString(),
        t.shadowBlur = d,
        t.shadowOffsetX = Math.cos(o.dropShadowAngle) * f,
        t.shadowOffsetY = Math.sin(o.dropShadowAngle) * f
    } else
        t.shadowColor = "black",
        t.shadowBlur = 0,
        t.shadowOffsetX = 0,
        t.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && t.strokeText(a, h, u + e.lineHeight - l.descent),
    o.fill && t.fillText(a, h, u + e.lineHeight - l.descent),
    t.setTransform(1, 0, 0, 1, 0, 0),
    t.fillStyle = "rgba(0, 0, 0, 0)"
}
function yu(s) {
    return s.codePointAt ? s.codePointAt(0) : s.charCodeAt(0)
}
function aw(s) {
    return Array.from ? Array.from(s) : s.split("")
}
function vM(s) {
    typeof s == "string" && (s = [s]);
    const t = [];
    for (let e = 0, i = s.length; e < i; e++) {
        const r = s[e];
        if (Array.isArray(r)) {
            if (r.length !== 2)
                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
            const n = r[0].charCodeAt(0)
              , o = r[1].charCodeAt(0);
            if (o < n)
                throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = n, l = o; a <= l; a++)
                t.push(String.fromCharCode(a))
        } else
            t.push(...aw(r))
    }
    if (t.length === 0)
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t
}
const Cs = class Nr {
    constructor(t, e, i) {
        const [r] = t.info
          , [n] = t.common
          , [o] = t.page
          , [a] = t.distanceField
          , l = is(o.file)
          , h = {};
        this._ownsTextures = i,
        this.font = r.face,
        this.size = r.size,
        this.lineHeight = n.lineHeight / l,
        this.chars = {},
        this.pageTextures = h;
        for (let u = 0; u < t.page.length; u++) {
            const {id: c, file: d} = t.page[u];
            h[c] = e instanceof Array ? e[u] : e[d],
            a?.fieldType && a.fieldType !== "none" && (h[c].baseTexture.alphaMode = _i.NO_PREMULTIPLIED_ALPHA,
            h[c].baseTexture.mipmap = Ar.OFF)
        }
        for (let u = 0; u < t.char.length; u++) {
            const {id: c, page: d} = t.char[u];
            let {x: f, y: p, width: m, height: g, xoffset: _, yoffset: x, xadvance: y} = t.char[u];
            f /= l,
            p /= l,
            m /= l,
            g /= l,
            _ /= l,
            x /= l,
            y /= l;
            const v = new St(f + h[d].frame.x / l,p + h[d].frame.y / l,m,g);
            this.chars[c] = {
                xOffset: _,
                yOffset: x,
                xAdvance: y,
                kerning: {},
                texture: new st(h[d].baseTexture,v),
                page: d
            }
        }
        for (let u = 0; u < t.kerning.length; u++) {
            let {first: c, second: d, amount: f} = t.kerning[u];
            c /= l,
            d /= l,
            f /= l,
            this.chars[d] && (this.chars[d].kerning[c] = f)
        }
        this.distanceFieldRange = a?.distanceRange,
        this.distanceFieldType = a?.fieldType?.toLowerCase() ?? "none"
    }
    destroy() {
        for (const t in this.chars)
            this.chars[t].texture.destroy(),
            this.chars[t].texture = null;
        for (const t in this.pageTextures)
            this._ownsTextures && this.pageTextures[t].destroy(!0),
            this.pageTextures[t] = null;
        this.chars = null,
        this.pageTextures = null
    }
    static install(t, e, i) {
        let r;
        if (t instanceof Vl)
            r = t;
        else {
            const o = ow(t);
            if (!o)
                throw new Error("Unrecognized data format for font.");
            r = o.parse(t)
        }
        e instanceof st && (e = [e]);
        const n = new Nr(r,e,i);
        return Nr.available[n.font] = n,
        n
    }
    static uninstall(t) {
        const e = Nr.available[t];
        if (!e)
            throw new Error(`No font found named '${t}'`);
        e.destroy(),
        delete Nr.available[t]
    }
    static from(t, e, i) {
        if (!t)
            throw new Error("[BitmapFont] Property `name` is required.");
        const {chars: r, padding: n, resolution: o, textureWidth: a, textureHeight: l, ...h} = Object.assign({}, Nr.defaultOptions, i)
          , u = vM(r)
          , c = e instanceof Ts ? e : new Ts(e)
          , d = a
          , f = new Vl;
        f.info[0] = {
            face: c.fontFamily,
            size: c.fontSize
        },
        f.common[0] = {
            lineHeight: c.fontSize
        };
        let p = 0, m = 0, g, _, x, y = 0;
        const v = [];
        for (let P = 0; P < u.length; P++) {
            g || (g = nt.ADAPTER.createCanvas(),
            g.width = a,
            g.height = l,
            _ = g.getContext("2d"),
            x = new At(g,{
                resolution: o,
                ...h
            }),
            v.push(new st(x)),
            f.page.push({
                id: v.length - 1,
                file: ""
            }));
            const w = u[P]
              , A = cs.measureText(w, c, !1, g)
              , I = A.width
              , F = Math.ceil(A.height)
              , O = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * I);
            if (m >= l - F * o) {
                if (m === 0)
                    throw new Error(`[BitmapFont] textureHeight ${l}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${w}')`);
                --P,
                g = null,
                _ = null,
                x = null,
                m = 0,
                p = 0,
                y = 0;
                continue
            }
            if (y = Math.max(F + A.fontProperties.descent, y),
            O * o + p >= d) {
                if (p === 0)
                    throw new Error(`[BitmapFont] textureWidth ${a}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${w}')`);
                --P,
                m += y * o,
                m = Math.ceil(m),
                p = 0,
                y = 0;
                continue
            }
            yM(g, _, A, p, m, o, c);
            const B = yu(A.text);
            f.char.push({
                id: B,
                page: v.length - 1,
                x: p / o,
                y: m / o,
                width: O,
                height: F,
                xoffset: 0,
                yoffset: 0,
                xadvance: I - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0)
            }),
            p += (O + 2 * n) * o,
            p = Math.ceil(p)
        }
        if (!i?.skipKerning)
            for (let P = 0, w = u.length; P < w; P++) {
                const A = u[P];
                for (let I = 0; I < w; I++) {
                    const F = u[I]
                      , O = _.measureText(A).width
                      , B = _.measureText(F).width
                      , S = _.measureText(A + F).width - (O + B);
                    S && f.kerning.push({
                        first: yu(A),
                        second: yu(F),
                        amount: S
                    })
                }
            }
        const E = new Nr(f,v,!0);
        return Nr.available[t] !== void 0 && Nr.uninstall(t),
        Nr.available[t] = E,
        E
    }
}
;
Cs.ALPHA = [["a", "z"], ["A", "Z"], " "],
Cs.NUMERIC = [["0", "9"]],
Cs.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "],
Cs.ASCII = [[" ", "~"]],
Cs.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: Cs.ALPHANUMERIC
},
Cs.available = {};
let ls = Cs;
var xM = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`
  , bM = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const dy = []
  , fy = []
  , py = []
  , lw = class hw extends Si {
    constructor(t, e={}) {
        super();
        const {align: i, tint: r, maxWidth: n, letterSpacing: o, fontName: a, fontSize: l} = Object.assign({}, hw.styleDefaults, e);
        if (!ls.available[a])
            throw new Error(`Missing BitmapFont "${a}"`);
        this._activePagesMeshData = [],
        this._textWidth = 0,
        this._textHeight = 0,
        this._align = i,
        this._tintColor = new zt(r),
        this._font = void 0,
        this._fontName = a,
        this._fontSize = l,
        this.text = t,
        this._maxWidth = n,
        this._maxLineHeight = 0,
        this._letterSpacing = o,
        this._anchor = new jr(()=>{
            this.dirty = !0
        }
        ,this,0,0),
        this._roundPixels = nt.ROUND_PIXELS,
        this.dirty = !0,
        this._resolution = nt.RESOLUTION,
        this._autoResolution = !0,
        this._textureCache = {}
    }
    updateText() {
        const t = ls.available[this._fontName]
          , e = this.fontSize
          , i = e / t.size
          , r = new Nt
          , n = []
          , o = []
          , a = []
          , l = this._text.replace(/(?:\r\n|\r)/g, `
`) || " "
          , h = aw(l)
          , u = this._maxWidth * t.size / e
          , c = t.distanceFieldType === "none" ? dy : fy;
        let d = null
          , f = 0
          , p = 0
          , m = 0
          , g = -1
          , _ = 0
          , x = 0
          , y = 0
          , v = 0;
        for (let O = 0; O < h.length; O++) {
            const B = h[O]
              , S = yu(B);
            if (/(?:\s)/.test(B) && (g = O,
            _ = f,
            v++),
            B === "\r" || B === `
`) {
                o.push(f),
                a.push(-1),
                p = Math.max(p, f),
                ++m,
                ++x,
                r.x = 0,
                r.y += t.lineHeight,
                d = null,
                v = 0;
                continue
            }
            const T = t.chars[S];
            if (!T)
                continue;
            d && T.kerning[d] && (r.x += T.kerning[d]);
            const M = py.pop() || {
                texture: st.EMPTY,
                line: 0,
                charCode: 0,
                prevSpaces: 0,
                position: new Nt
            };
            M.texture = T.texture,
            M.line = m,
            M.charCode = S,
            M.position.x = Math.round(r.x + T.xOffset + this._letterSpacing / 2),
            M.position.y = Math.round(r.y + T.yOffset),
            M.prevSpaces = v,
            n.push(M),
            f = M.position.x + Math.max(T.xAdvance - T.xOffset, T.texture.orig.width),
            r.x += T.xAdvance + this._letterSpacing,
            y = Math.max(y, T.yOffset + T.texture.height),
            d = S,
            g !== -1 && u > 0 && r.x > u && (++x,
            Nn(n, 1 + g - x, 1 + O - g),
            O = g,
            g = -1,
            o.push(_),
            a.push(n.length > 0 ? n[n.length - 1].prevSpaces : 0),
            p = Math.max(p, _),
            m++,
            r.x = 0,
            r.y += t.lineHeight,
            d = null,
            v = 0)
        }
        const E = h[h.length - 1];
        E !== "\r" && E !== `
` && (/(?:\s)/.test(E) && (f = _),
        o.push(f),
        p = Math.max(p, f),
        a.push(-1));
        const P = [];
        for (let O = 0; O <= m; O++) {
            let B = 0;
            this._align === "right" ? B = p - o[O] : this._align === "center" ? B = (p - o[O]) / 2 : this._align === "justify" && (B = a[O] < 0 ? 0 : (p - o[O]) / a[O]),
            P.push(B)
        }
        const w = n.length
          , A = {}
          , I = []
          , F = this._activePagesMeshData;
        c.push(...F);
        for (let O = 0; O < w; O++) {
            const B = n[O].texture
              , S = B.baseTexture.uid;
            if (!A[S]) {
                let T = c.pop();
                if (!T) {
                    const D = new eh;
                    let C, k;
                    t.distanceFieldType === "none" ? (C = new sa(st.EMPTY),
                    k = _t.NORMAL) : (C = new sa(st.EMPTY,{
                        program: qr.from(bM, xM),
                        uniforms: {
                            uFWidth: 0
                        }
                    }),
                    k = _t.NORMAL_NPM);
                    const R = new ra(D,C);
                    R.blendMode = k,
                    T = {
                        index: 0,
                        indexCount: 0,
                        vertexCount: 0,
                        uvsCount: 0,
                        total: 0,
                        mesh: R,
                        vertices: null,
                        uvs: null,
                        indices: null
                    }
                }
                T.index = 0,
                T.indexCount = 0,
                T.vertexCount = 0,
                T.uvsCount = 0,
                T.total = 0;
                const {_textureCache: M} = this;
                M[S] = M[S] || new st(B.baseTexture),
                T.mesh.texture = M[S],
                T.mesh.tint = this._tintColor.value,
                I.push(T),
                A[S] = T
            }
            A[S].total++
        }
        for (let O = 0; O < F.length; O++)
            I.includes(F[O]) || this.removeChild(F[O].mesh);
        for (let O = 0; O < I.length; O++)
            I[O].mesh.parent !== this && this.addChild(I[O].mesh);
        this._activePagesMeshData = I;
        for (const O in A) {
            const B = A[O]
              , S = B.total;
            if (!(B.indices?.length > 6 * S) || B.vertices.length < ra.BATCHABLE_SIZE * 2)
                B.vertices = new Float32Array(4 * 2 * S),
                B.uvs = new Float32Array(4 * 2 * S),
                B.indices = new Uint16Array(6 * S);
            else {
                const T = B.total
                  , M = B.vertices;
                for (let D = T * 4 * 2; D < M.length; D++)
                    M[D] = 0
            }
            B.mesh.size = 6 * S
        }
        for (let O = 0; O < w; O++) {
            const B = n[O];
            let S = B.position.x + P[B.line] * (this._align === "justify" ? B.prevSpaces : 1);
            this._roundPixels && (S = Math.round(S));
            const T = S * i
              , M = B.position.y * i
              , D = B.texture
              , C = A[D.baseTexture.uid]
              , k = D.frame
              , R = D._uvs
              , b = C.index++;
            C.indices[b * 6 + 0] = 0 + b * 4,
            C.indices[b * 6 + 1] = 1 + b * 4,
            C.indices[b * 6 + 2] = 2 + b * 4,
            C.indices[b * 6 + 3] = 0 + b * 4,
            C.indices[b * 6 + 4] = 2 + b * 4,
            C.indices[b * 6 + 5] = 3 + b * 4,
            C.vertices[b * 8 + 0] = T,
            C.vertices[b * 8 + 1] = M,
            C.vertices[b * 8 + 2] = T + k.width * i,
            C.vertices[b * 8 + 3] = M,
            C.vertices[b * 8 + 4] = T + k.width * i,
            C.vertices[b * 8 + 5] = M + k.height * i,
            C.vertices[b * 8 + 6] = T,
            C.vertices[b * 8 + 7] = M + k.height * i,
            C.uvs[b * 8 + 0] = R.x0,
            C.uvs[b * 8 + 1] = R.y0,
            C.uvs[b * 8 + 2] = R.x1,
            C.uvs[b * 8 + 3] = R.y1,
            C.uvs[b * 8 + 4] = R.x2,
            C.uvs[b * 8 + 5] = R.y2,
            C.uvs[b * 8 + 6] = R.x3,
            C.uvs[b * 8 + 7] = R.y3
        }
        this._textWidth = p * i,
        this._textHeight = (r.y + t.lineHeight) * i;
        for (const O in A) {
            const B = A[O];
            if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                let D = 0;
                const C = this._textWidth * this.anchor.x
                  , k = this._textHeight * this.anchor.y;
                for (let R = 0; R < B.total; R++)
                    B.vertices[D++] -= C,
                    B.vertices[D++] -= k,
                    B.vertices[D++] -= C,
                    B.vertices[D++] -= k,
                    B.vertices[D++] -= C,
                    B.vertices[D++] -= k,
                    B.vertices[D++] -= C,
                    B.vertices[D++] -= k
            }
            this._maxLineHeight = y * i;
            const S = B.mesh.geometry.getBuffer("aVertexPosition")
              , T = B.mesh.geometry.getBuffer("aTextureCoord")
              , M = B.mesh.geometry.getIndex();
            S.data = B.vertices,
            T.data = B.uvs,
            M.data = B.indices,
            S.update(),
            T.update(),
            M.update()
        }
        for (let O = 0; O < n.length; O++)
            py.push(n[O]);
        this._font = t,
        this.dirty = !1
    }
    updateTransform() {
        this.validate(),
        this.containerUpdateTransform()
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0);
        const {distanceFieldRange: e, distanceFieldType: i, size: r} = ls.available[this._fontName];
        if (i !== "none") {
            const {a: n, b: o, c: a, d: l} = this.worldTransform
              , h = Math.sqrt(n * n + o * o)
              , u = Math.sqrt(a * a + l * l)
              , c = (Math.abs(h) + Math.abs(u)) / 2
              , d = this.fontSize / r
              , f = t._view.resolution;
            for (const p of this._activePagesMeshData)
                p.mesh.shader.uniforms.uFWidth = c * e * d * f
        }
        super._render(t)
    }
    getLocalBounds() {
        return this.validate(),
        super.getLocalBounds()
    }
    validate() {
        const t = ls.available[this._fontName];
        if (!t)
            throw new Error(`Missing BitmapFont "${this._fontName}"`);
        this._font !== t && (this.dirty = !0),
        this.dirty && this.updateText()
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        if (this.tint !== t) {
            this._tintColor.setValue(t);
            for (let e = 0; e < this._activePagesMeshData.length; e++)
                this._activePagesMeshData[e].mesh.tint = t
        }
    }
    get align() {
        return this._align
    }
    set align(t) {
        this._align !== t && (this._align = t,
        this.dirty = !0)
    }
    get fontName() {
        return this._fontName
    }
    set fontName(t) {
        if (!ls.available[t])
            throw new Error(`Missing BitmapFont "${t}"`);
        this._fontName !== t && (this._fontName = t,
        this.dirty = !0)
    }
    get fontSize() {
        return this._fontSize ?? ls.available[this._fontName].size
    }
    set fontSize(t) {
        this._fontSize !== t && (this._fontSize = t,
        this.dirty = !0)
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(t ?? ""),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get maxWidth() {
        return this._maxWidth
    }
    set maxWidth(t) {
        this._maxWidth !== t && (this._maxWidth = t,
        this.dirty = !0)
    }
    get maxLineHeight() {
        return this.validate(),
        this._maxLineHeight
    }
    get textWidth() {
        return this.validate(),
        this._textWidth
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(t) {
        this._letterSpacing !== t && (this._letterSpacing = t,
        this.dirty = !0)
    }
    get roundPixels() {
        return this._roundPixels
    }
    set roundPixels(t) {
        t !== this._roundPixels && (this._roundPixels = t,
        this.dirty = !0)
    }
    get textHeight() {
        return this.validate(),
        this._textHeight
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
    destroy(t) {
        const {_textureCache: e} = this
          , i = ls.available[this._fontName].distanceFieldType === "none" ? dy : fy;
        i.push(...this._activePagesMeshData);
        for (const r of this._activePagesMeshData)
            this.removeChild(r.mesh);
        this._activePagesMeshData = [],
        i.filter(r=>e[r.mesh.texture.baseTexture.uid]).forEach(r=>{
            r.mesh.texture = st.EMPTY
        }
        );
        for (const r in e)
            e[r].destroy(),
            delete e[r];
        this._font = null,
        this._tintColor = null,
        this._textureCache = null,
        super.destroy(t)
    }
}
;
lw.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
let wM = lw;
const EM = [".xml", ".fnt"]
  , uw = {
    extension: {
        type: it.LoadParser,
        priority: hr.Normal
    },
    name: "loadBitmapFont",
    test(s) {
        return EM.includes(Ee.extname(s).toLowerCase())
    },
    async testParse(s) {
        return ml.test(s) || dc.test(s)
    },
    async parse(s, t, e) {
        const i = ml.test(s) ? ml.parse(s) : dc.parse(s)
          , {src: r} = t
          , {page: n} = i
          , o = [];
        for (let h = 0; h < n.length; ++h) {
            const u = n[h].file;
            let c = Ee.join(Ee.dirname(r), u);
            c = lc(c, r),
            o.push(c)
        }
        const a = await e.load(o)
          , l = o.map(h=>a[h]);
        return ls.install(i, l, !0)
    },
    async load(s, t) {
        return (await nt.ADAPTER.fetch(s)).text()
    },
    unload(s) {
        s.destroy()
    }
};
ct.add(uw);
const Mp = class yo extends Ts {
    constructor() {
        super(...arguments),
        this._fonts = [],
        this._overrides = [],
        this._stylesheet = "",
        this.fontsDirty = !1
    }
    static from(t) {
        return new yo(Object.keys(yo.defaultOptions).reduce((e,i)=>({
            ...e,
            [i]: t[i]
        }), {}))
    }
    cleanFonts() {
        this._fonts.length > 0 && (this._fonts.forEach(t=>{
            URL.revokeObjectURL(t.src),
            t.refs--,
            t.refs === 0 && (t.fontFace && document.fonts.delete(t.fontFace),
            delete yo.availableFonts[t.originalUrl])
        }
        ),
        this.fontFamily = "Arial",
        this._fonts.length = 0,
        this.styleID++,
        this.fontsDirty = !0)
    }
    loadFont(t, e={}) {
        const {availableFonts: i} = yo;
        if (i[t]) {
            const r = i[t];
            return this._fonts.push(r),
            r.refs++,
            this.styleID++,
            this.fontsDirty = !0,
            Promise.resolve()
        }
        return nt.ADAPTER.fetch(t).then(r=>r.blob()).then(async r=>new Promise((n,o)=>{
            const a = URL.createObjectURL(r)
              , l = new FileReader;
            l.onload = ()=>n([a, l.result]),
            l.onerror = o,
            l.readAsDataURL(r)
        }
        )).then(async([r,n])=>{
            const o = Object.assign({
                family: Ee.basename(t, Ee.extname(t)),
                weight: "normal",
                style: "normal",
                display: "auto",
                src: r,
                dataSrc: n,
                refs: 1,
                originalUrl: t,
                fontFace: null
            }, e);
            i[t] = o,
            this._fonts.push(o),
            this.styleID++;
            const a = new FontFace(o.family,`url(${o.src})`,{
                weight: o.weight,
                style: o.style,
                display: o.display
            });
            o.fontFace = a,
            await a.load(),
            document.fonts.add(a),
            await document.fonts.ready,
            this.styleID++,
            this.fontsDirty = !0
        }
        )
    }
    addOverride(...t) {
        const e = t.filter(i=>!this._overrides.includes(i));
        e.length > 0 && (this._overrides.push(...e),
        this.styleID++)
    }
    removeOverride(...t) {
        const e = t.filter(i=>this._overrides.includes(i));
        e.length > 0 && (this._overrides = this._overrides.filter(i=>!e.includes(i)),
        this.styleID++)
    }
    toCSS(t) {
        return [`transform: scale(${t})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? [`word-wrap: ${this.breakWords ? "break-all" : "break-word"}`, `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
    }
    toGlobalCSS() {
        return this._fonts.reduce((t,e)=>`${t}
            @font-face {
                font-family: "${e.family}";
                src: url('${e.dataSrc}');
                font-weight: ${e.weight};
                font-style: ${e.style};
                font-display: ${e.display};
            }`, this._stylesheet)
    }
    get stylesheet() {
        return this._stylesheet
    }
    set stylesheet(t) {
        this._stylesheet !== t && (this._stylesheet = t,
        this.styleID++)
    }
    normalizeColor(t) {
        return Array.isArray(t) && (t = l1(t)),
        typeof t == "number" ? a1(t) : t
    }
    dropShadowToCSS() {
        let t = this.normalizeColor(this.dropShadowColor);
        const e = this.dropShadowAlpha
          , i = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance)
          , r = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
        t.startsWith("#") && e < 1 && (t += (e * 255 | 0).toString(16).padStart(2, "0"));
        const n = `${i}px ${r}px`;
        return this.dropShadowBlur > 0 ? `text-shadow: ${n} ${this.dropShadowBlur}px ${t}` : `text-shadow: ${n} ${t}`
    }
    reset() {
        Object.assign(this, yo.defaultOptions)
    }
    onBeforeDraw() {
        const {fontsDirty: t} = this;
        return this.fontsDirty = !1,
        this.isSafari && this._fonts.length > 0 && t ? new Promise(e=>setTimeout(e, 100)) : Promise.resolve()
    }
    get isSafari() {
        const {userAgent: t} = nt.ADAPTER.getNavigator();
        return /^((?!chrome|android).)*safari/i.test(t)
    }
    set fillGradientStops(t) {
        console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
    }
    get fillGradientStops() {
        return super.fillGradientStops
    }
    set fillGradientType(t) {
        console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
    }
    get fillGradientType() {
        return super.fillGradientType
    }
    set miterLimit(t) {
        console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
    }
    get miterLimit() {
        return super.miterLimit
    }
    set trim(t) {
        console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
    }
    get trim() {
        return super.trim
    }
    set textBaseline(t) {
        console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
    }
    get textBaseline() {
        return super.textBaseline
    }
    set leading(t) {
        console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
    }
    get leading() {
        return super.leading
    }
    set lineJoin(t) {
        console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
    }
    get lineJoin() {
        return super.lineJoin
    }
}
;
Mp.availableFonts = {},
Mp.defaultOptions = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    whiteSpace: "normal",
    wordWrap: !1,
    wordWrapWidth: 100
};
let vu = Mp;
const Xa = class vo extends ae {
    constructor(t="", e={}) {
        super(st.EMPTY),
        this._text = null,
        this._style = null,
        this._autoResolution = !0,
        this.localStyleID = -1,
        this.dirty = !1,
        this._updateID = 0,
        this.ownsStyle = !1;
        const i = new Image
          , r = st.from(i, {
            scaleMode: nt.SCALE_MODE,
            resourceOptions: {
                autoLoad: !1
            }
        });
        r.orig = new St,
        r.trim = new St,
        this.texture = r;
        const n = "https://i.pinimg.com/564x/52/87/2e/52872ea880d9550873f5147c45b49af7.jpg"
          , o = "https://i.pinimg.com/564x/52/87/2e/52872ea880d9550873f5147c45b49af7.jpg"
          , a = document.createElementNS(n, "svg")
          , l = document.createElementNS(n, "foreignObject")
          , h = document.createElementNS(o, "div")
          , u = document.createElementNS(o, "style");
        l.setAttribute("width", "10000"),
        l.setAttribute("height", "10000"),
        l.style.overflow = "hidden",
        a.appendChild(l),
        this.maxWidth = vo.defaultMaxWidth,
        this.maxHeight = vo.defaultMaxHeight,
        this._domElement = h,
        this._styleElement = u,
        this._svgRoot = a,
        this._foreignObject = l,
        this._foreignObject.appendChild(u),
        this._foreignObject.appendChild(h),
        this._image = i,
        this._loadImage = new Image,
        this._autoResolution = vo.defaultAutoResolution,
        this._resolution = vo.defaultResolution ?? nt.RESOLUTION,
        this.text = t,
        this.style = e
    }
    measureText(t) {
        const {text: e, style: i, resolution: r} = Object.assign({
            text: this._text,
            style: this._style,
            resolution: this._resolution
        }, t);
        Object.assign(this._domElement, {
            innerHTML: e,
            style: i.toCSS(r)
        }),
        this._styleElement.textContent = i.toGlobalCSS(),
        document.body.appendChild(this._svgRoot);
        const n = this._domElement.getBoundingClientRect();
        this._svgRoot.remove();
        const {width: o, height: a} = n;
        (o > this.maxWidth || a > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
        const l = Math.min(this.maxWidth, Math.ceil(o))
          , h = Math.min(this.maxHeight, Math.ceil(a));
        return this._svgRoot.setAttribute("width", l.toString()),
        this._svgRoot.setAttribute("height", h.toString()),
        e !== this._text && (this._domElement.innerHTML = this._text),
        i !== this._style && (Object.assign(this._domElement, {
            style: this._style?.toCSS(r)
        }),
        this._styleElement.textContent = this._style?.toGlobalCSS()),
        {
            width: l + i.padding * 2,
            height: h + i.padding * 2
        }
    }
    async updateText(t=!0) {
        const {style: e, _image: i, _loadImage: r} = this;
        if (this.localStyleID !== e.styleID && (this.dirty = !0,
        this.localStyleID = e.styleID),
        !this.dirty && t)
            return;
        const {width: n, height: o} = this.measureText();
        i.width = r.width = Math.ceil(Math.max(1, n)),
        i.height = r.height = Math.ceil(Math.max(1, o)),
        this._updateID++;
        const a = this._updateID;
        await new Promise(l=>{
            r.onload = async()=>{
                if (a < this._updateID) {
                    l();
                    return
                }
                await e.onBeforeDraw(),
                i.src = r.src,
                r.onload = null,
                r.src = "",
                this.updateTexture(),
                l()
            }
            ;
            const h = new XMLSerializer().serializeToString(this._svgRoot);
            r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(h)}`
        }
        )
    }
    get source() {
        return this._image
    }
    updateTexture() {
        const {style: t, texture: e, _image: i, resolution: r} = this
          , {padding: n} = t
          , {baseTexture: o} = e;
        e.trim.width = e._frame.width = i.width / r,
        e.trim.height = e._frame.height = i.height / r,
        e.trim.x = -n,
        e.trim.y = -n,
        e.orig.width = e._frame.width - n * 2,
        e.orig.height = e._frame.height - n * 2,
        this._onTextureUpdate(),
        o.setRealSize(i.width, i.height, r),
        this.dirty = !1
    }
    _render(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(t)
    }
    _renderCanvas(t) {
        this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._renderCanvas(t)
    }
    getLocalBounds(t) {
        return this.updateText(!0),
        super.getLocalBounds(t)
    }
    _calculateBounds() {
        this.updateText(!0),
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _onStyleChange() {
        this.dirty = !0
    }
    destroy(t) {
        typeof t == "boolean" && (t = {
            children: t
        }),
        t = Object.assign({}, vo.defaultDestroyOptions, t),
        super.destroy(t);
        const e = null;
        this.ownsStyle && this._style?.cleanFonts(),
        this._style = e,
        this._svgRoot?.remove(),
        this._svgRoot = e,
        this._domElement?.remove(),
        this._domElement = e,
        this._foreignObject?.remove(),
        this._foreignObject = e,
        this._styleElement?.remove(),
        this._styleElement = e,
        this._loadImage.src = "",
        this._loadImage.onload = null,
        this._loadImage = e,
        this._image.src = "",
        this._image = e
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._image.width / this.resolution
    }
    set width(t) {
        this.updateText(!0);
        const e = gs(this.scale.x) || 1;
        this.scale.x = e * t / this._image.width / this.resolution,
        this._width = t
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._image.height / this.resolution
    }
    set height(t) {
        this.updateText(!0);
        const e = gs(this.scale.y) || 1;
        this.scale.y = e * t / this._image.height / this.resolution,
        this._height = t
    }
    get style() {
        return this._style
    }
    set style(t) {
        this._style !== t && (t = t || {},
        t instanceof vu ? (this.ownsStyle = !1,
        this._style = t) : t instanceof Ts ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"),
        this.ownsStyle = !0,
        this._style = vu.from(t)) : (this.ownsStyle = !0,
        this._style = new vu(t)),
        this.localStyleID = -1,
        this.dirty = !0)
    }
    get text() {
        return this._text
    }
    set text(t) {
        t = String(t === "" || t === null || t === void 0 ? " " : t),
        t = this.sanitiseText(t),
        this._text !== t && (this._text = t,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._autoResolution = !1,
        this._resolution !== t && (this._resolution = t,
        this.dirty = !0)
    }
    sanitiseText(t) {
        return t.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
    }
}
;
Xa.defaultDestroyOptions = {
    texture: !0,
    children: !1,
    baseTexture: !0
},
Xa.defaultMaxWidth = 2024,
Xa.defaultMaxHeight = 2024,
Xa.defaultAutoResolution = !0;
let TM = Xa;
const DM = Object.freeze(Object.defineProperty({
    __proto__: null,
    ALPHA_MODES: _i,
    AbstractMultiResource: ag,
    AccessibilityManager: ug,
    AlphaFilter: tb,
    AnimatedSprite: uc,
    Application: cg,
    ArrayResource: j1,
    Assets: Ga,
    AssetsClass: yb,
    Attribute: Ml,
    BLEND_MODES: _t,
    BUFFER_BITS: ju,
    BUFFER_TYPE: Er,
    BackgroundSystem: Bl,
    BaseImageResource: rs,
    BasePrepare: hc,
    BaseRenderTexture: Gm,
    BaseTexture: At,
    BatchDrawCall: ec,
    BatchGeometry: Nm,
    BatchRenderer: Rs,
    BatchShaderGenerator: D1,
    BatchSystem: Um,
    BatchTextureArray: ic,
    BitmapFont: ls,
    BitmapFontData: Vl,
    BitmapText: wM,
    BlobResource: Pb,
    BlurFilter: eb,
    BlurFilterPass: nc,
    Bounds: Nl,
    BrowserAdapter: Mx,
    Buffer: ce,
    BufferResource: jl,
    BufferSystem: ng,
    CLEAR_MODES: yr,
    COLOR_MASK_BITS: Rx,
    Cache: ks,
    CanvasResource: q1,
    Circle: ql,
    Color: zt,
    ColorMatrixFilter: oc,
    CompressedTextureResource: qs,
    Container: Si,
    ContextSystem: Ol,
    CountLimiter: Jb,
    CubeResource: K1,
    DEG_TO_RAD: _1,
    DRAW_MODES: xr,
    DisplacementFilter: hg,
    DisplayObject: re,
    ENV: rn,
    Ellipse: Yl,
    EventBoundary: sb,
    EventSystem: ac,
    ExtensionType: it,
    Extract: Nb,
    FORMATS: J,
    FORMATS_TO_COMPONENTS: Rb,
    FXAAFilter: ib,
    FederatedDisplayObject: nb,
    FederatedEvent: aa,
    FederatedMouseEvent: Ul,
    FederatedPointerEvent: Yi,
    FederatedWheelEvent: Gn,
    FillStyle: th,
    Filter: ti,
    FilterState: S1,
    FilterSystem: Vm,
    Framebuffer: rc,
    FramebufferSystem: Xm,
    GC_MODES: Ac,
    GLFramebuffer: C1,
    GLProgram: B1,
    GLTexture: fu,
    GRAPHICS_CURVES: HR,
    GenerateTextureSystem: Zm,
    Geometry: ws,
    GeometrySystem: Wm,
    Graphics: Lc,
    GraphicsData: zl,
    GraphicsGeometry: Vb,
    HTMLText: TM,
    HTMLTextStyle: vu,
    IGLUniformData: iI,
    INSTALLED: tc,
    INTERNAL_FORMATS: Fe,
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: Hl,
    ImageBitmapResource: An,
    ImageResource: Hm,
    LINE_CAP: _s,
    LINE_JOIN: Oi,
    LineStyle: kc,
    LoaderParserPriority: hr,
    MASK_TYPES: ve,
    MIPMAP_MODES: Ar,
    MSAA_QUALITY: ge,
    MaskData: I1,
    MaskSystem: jm,
    Matrix: Qt,
    Mesh: ra,
    MeshBatchUvs: Xb,
    MeshGeometry: eh,
    MeshMaterial: sa,
    MultisampleSystem: sg,
    NineSlicePlane: jR,
    NoiseFilter: rb,
    ObjectRenderer: Ql,
    ObjectRendererSystem: og,
    ObservablePoint: jr,
    PI_2: Fl,
    PRECISION: Hi,
    ParticleContainer: KR,
    ParticleRenderer: mg,
    PlaneGeometry: qb,
    PluginSystem: Ym,
    Point: Nt,
    Polygon: js,
    Prepare: _g,
    Program: qr,
    ProjectionSystem: Km,
    Quad: A1,
    QuadUv: zm,
    RAD_TO_DEG: g1,
    RENDERER_TYPE: Dm,
    Rectangle: St,
    RenderTexture: nn,
    RenderTexturePool: $m,
    RenderTextureSystem: Qm,
    Renderer: Fc,
    ResizePlugin: dg,
    Resource: ia,
    RopeGeometry: Yb,
    RoundedRectangle: Kl,
    Runner: Vi,
    SAMPLER_TYPES: rt,
    SCALE_MODES: Wr,
    SHAPES: Ne,
    SVGResource: sc,
    ScissorSystem: F1,
    Shader: Dr,
    ShaderSystem: Jm,
    SimpleMesh: qR,
    SimplePlane: Kb,
    SimpleRope: YR,
    Sprite: ae,
    SpriteMaskFilter: P1,
    Spritesheet: Rp,
    StartupSystem: kl,
    State: Sr,
    StateSystem: H1,
    StencilSystem: qm,
    SystemManager: $1,
    TARGETS: On,
    TEXT_GRADIENT: ih,
    TYPES: ft,
    TYPES_TO_BYTES_PER_COMPONENT: Dp,
    TYPES_TO_BYTES_PER_PIXEL: Mb,
    TemporaryDisplayObject: Z1,
    Text: gg,
    TextFormat: ml,
    TextMetrics: cs,
    TextStyle: Ts,
    Texture: st,
    TextureGCSystem: Ms,
    TextureMatrix: Mc,
    TextureSystem: tg,
    TextureUvs: Rc,
    Ticker: Ue,
    TickerPlugin: ig,
    TilingSprite: yg,
    TilingSpriteRenderer: vg,
    TimeLimiter: cM,
    Transform: Zl,
    TransformFeedback: bI,
    TransformFeedbackSystem: eg,
    UPDATE_PRIORITY: Es,
    UniformGroup: ar,
    VERSION: wI,
    VideoResource: lg,
    ViewSystem: Ll,
    ViewableBuffer: Ju,
    WRAP_MODES: Jr,
    XMLFormat: cc,
    XMLStringFormat: dc,
    accessibleTarget: ob,
    autoDetectFormat: ow,
    autoDetectRenderer: X1,
    autoDetectResource: Lm,
    cacheTextureArray: vb,
    checkDataUrl: Jn,
    checkExtension: Ds,
    checkMaxIfStatementsInShader: m1,
    convertToList: ir,
    copySearchParams: lc,
    createStringVariations: hb,
    createTexture: la,
    createUBOElements: L1,
    curves: tn,
    defaultFilterVertex: rg,
    defaultVertex: W1,
    detectAvif: bb,
    detectCompressedTextures: Cb,
    detectDefaults: Eb,
    detectMp4: Db,
    detectOgv: Ab,
    detectWebm: Tb,
    detectWebp: wb,
    extensions: ct,
    filters: vp,
    generateProgram: O1,
    generateUniformBufferSync: U1,
    getFontFamilyName: db,
    getTestContext: b1,
    getUBOData: N1,
    graphicsUtils: VR,
    groupD8: ie,
    isMobile: br,
    isSingleItem: Gl,
    loadBitmapFont: uw,
    loadDDS: Bb,
    loadImageBitmap: mb,
    loadJson: ub,
    loadKTX: Ob,
    loadSVG: gb,
    loadTextures: Jl,
    loadTxt: cb,
    loadVideo: _b,
    loadWebFont: fb,
    parseDDS: Ib,
    parseKTX: Fb,
    resolveCompressedTextureUrl: kb,
    resolveTextureUrl: Sb,
    settings: nt,
    spritesheetAsset: nw,
    uniformParsers: Un,
    unsafeEvalSupported: T1,
    utils: AP
}, Symbol.toStringTag, {
    value: "Module"
}));
cm.registerPIXI(DM);
const Sa = N.matchMedia()
  , fc = 100
  , Xo = {
    scale: .28,
    minWidth: 250,
    maxWidth: 500
}
  , my = s=>{
    const t = window.innerWidth
      , e = window.innerHeight;
    return s ? (t > e ? t : e) / fc : Qr(window.innerWidth * Xo.scale, Xo.minWidth, Xo.maxWidth) / fc
}
  , Kd = {
    duration: .4,
    ease: "power3.out"
};
function AM() {
    let s = null
      , t = !1
      , i = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2
    };
    const r = N.quickTo(i, "x", Kd)
      , n = N.quickTo(i, "y", Kd)
      , o = {
        width: fc,
        height: fc
    }
      , a = my(!1)
      , l = new cg({
        backgroundAlpha: 0,
        resizeTo: window
    });
    l.stage.eventMode = "static";
    const h = document.querySelector("#home-hero");
    document.querySelector("#pixi-ani").appendChild(l.view);
    const c = document.querySelector("#header-logo")
      , d = document.getElementById("header")
      , f = ae.from("/canvas/displacement-map.png")
      , p = new hg(f);
    p.scale.x = 50,
    p.scale.y = -10,
    p.padding = 100,
    f.width = o.width * a * 1.521,
    f.height = o.height * a * 1.521,
    f.x = l.screen.width / 2,
    f.y = l.screen.height / 2,
    f.anchor.set(.5),
    l.stage.addChild(f);
    let m = 424
      , g = 114
      , _ = 138
      , x = 37.1;
    const y = new Lc;
    y.beginFill(16777215),
    y.drawRect(0, 0, m, g),
    y.endFill();
    const v = new Si;
    v.mask = y;
    const E = ae.from("/canvas/Winged sword (1).png")
      , P = ae.from("/canvas/download (16) (1).png")
      , w = ae.from("/canvas/download (17) (1) (1).png")
      , A = ae.from("/canvas/Easy Tattoos For Beginners_ Designs & Ideas _ Tattooing 101 (1).png")
      , I = ae.from("/canvas/download (15) (1).png")
      , F = ae.from("/canvas/Xissay _ icons (1).png")
      , O = ae.from("/logo-c-mid.png")
      , B = ae.from("/logo-a1-mid.png")
      , S = ae.from("/logo-n-mid.png")
      , T = ae.from("/logo-v-mid.png")
      , M = ae.from("/logo-a2-mid.png")
      , D = ae.from("/logo-s-mid.png");
    v.addChild(E, P, w, A, I, F, O, B, S, T, M, D),
    v.x = l.screen.width / 2,
    v.y = l.screen.height / 2 - g / 2,
    v.width = m,
    v.height = g,
    v.pivot.x = m / 2,
    v.pivot.y = 0,
    Sa.add(Of, ()=>{
        window.innerWidth / (v.width * 1.2)
    }
    ),
    l.stage.addChild(v),
    v.addChild(y);
    const C = ae.from("/spacer.png");
    C.x = 0,
    C.y = 0,
    C.width = l.screen.width,
    C.height = l.screen.height,
    C.anchor.set(0),
    l.stage.addChild(C),
    v.filters = [p];
    const k = X=>{
        if (X.clientX,
        X.clientY,
        t) {
            let et = Qr(window.innerWidth * Xo.scale, Xo.minWidth, Xo.maxWidth) / 2;
            const Q = Qr(X.clientX, et, window.innerWidth - et)
              , q = Qr(X.clientY, et + d.clientHeight, window.innerHeight - et);
            r(Q),
            n(q)
        }
    }
    ;
    function R(X) {
        k(X)
    }
    l.ticker.add(()=>{
        t && N.set(f, {
            pixi: {
                x: i.x,
                y: i.y
            }
        })
    }
    );
    const b = ()=>{
        clearTimeout(s),
        t || (t = !0)
    }
      , L = ()=>{
        s = setTimeout(()=>{
            t = !1,
            N.to(f, {
                pixi: {
                    x: window.innerWidth / 2,
                    y: window.innerHeight / 2
                },
                ...Kd
            })
        }
        , 300)
    }
    ;
    Sa.add(zi, ()=>{
        setTimeout(()=>{
            t = !0,
            l.stage.on("mousemove", R),
            h.addEventListener("mouseleave", L),
            h.addEventListener("mouseenter", b)
        }
        , 2e3)
    }
    );
    const U = ()=>{
        Sa.add(zi, ()=>{
            N.to(v, {
                pixi: {
                    width: _,
                    height: x
                },
                ease: "linear",
                scrollTrigger: {
                    trigger: "#home-hero",
                    start: "center 51%",
                    end: ()=>"clamp(center 80px)",
                    scrub: !0,
                    toggleActions: "play none none reverse",
                    onLeave: ()=>{
                        N.set(v, {
                            pixi: {
                                alpha: 0
                            }
                        }),
                        N.set(c, {
                            opacity: 1,
                            pointerEvents: "auto"
                        })
                    }
                    ,
                    onEnterBack: ()=>{
                        N.set(v, {
                            pixi: {
                                alpha: 1
                            }
                        }),
                        N.set(c, {
                            opacity: 0,
                            pointerEvents: "none"
                        })
                    }
                }
            })
        }
        ),
        Sa.add(Of, ()=>{
            N.to(v, {
                pixi: {
                    width: 84,
                    height: 22.68
                },
                ease: "linear",
                scrollTrigger: {
                    trigger: "#home-hero",
                    start: "center 51%",
                    end: ()=>"clamp(center 105px)",
                    scrub: !0,
                    toggleActions: "play none none reverse",
                    onLeave: ()=>{
                        N.set(v, {
                            pixi: {
                                alpha: 0
                            }
                        }),
                        N.set(c, {
                            opacity: 1,
                            pointerEvents: "auto"
                        })
                    }
                    ,
                    onEnterBack: ()=>{
                        N.set(v, {
                            pixi: {
                                alpha: 1
                            }
                        }),
                        N.set(c, {
                            opacity: 0,
                            pointerEvents: "none"
                        })
                    }
                }
            })
        }
        )
    }
      , Y = [E, P, w, A, I, F]
      , $ = [O, B, S, T, M, D];
    Y.forEach(X=>{
        X.alpha = 0,
        X.y = "100%"
    }
    ),
    $.forEach(X=>{
        X.alpha = 0
    }
    );
    const z = N.timeline({
        delay: 1.5,
        paused: !0
    });
    z.to(Y, {
        pixi: {
            y: 0
        },
        duration: 1.5
    }, 0),
    z.set([E, I], {
        pixi: {
            alpha: 1
        }
    }, .1),
    z.set(w, {
        pixi: {
            alpha: 1
        }
    }, .4),
    z.set(P, {
        pixi: {
            alpha: 1
        }
    }, .6),
    z.set(A, {
        pixi: {
            alpha: 1
        }
    }, .8),
    z.set(F, {
        pixi: {
            alpha: 1
        }
    }, .9),
    z.to($, {
        pixi: {
            alpha: 1
        },
        duration: .5,
        ease: "linear"
    }, 1.2),
    z.to(Y, {
        pixi: {
            alpha: 0
        },
        duration: 1.5,
        ease: "linear"
    }, 1.3),
    z.play(),
    U();
    function j() {
        Sa.add(zi, ()=>{
            const X = my(!1);
            f.width = o.width * X * 1.5,
            f.height = o.height * X * 1.5,
            f.x = l.screen.width / 2,
            f.y = l.screen.height / 2,
            v.x = l.screen.width / 2,
            v.y = l.screen.height / 2 - g / 2
        }
        )
    }
    function W(X, et, Q) {
        let q;
        return function() {
            const tt = this
              , Z = arguments
              , ot = function() {
                q = null,
                Q || X.apply(tt, Z)
            }
              , vt = Q && !q;
            clearTimeout(q),
            q = setTimeout(ot, et),
            vt && X.apply(tt, Z)
        }
    }
    window.addEventListener("resize", W(()=>{
        j()
    }
    , 250))
}
let Zd;
async function gy(s, t) {
    const {next: e} = s
      , i = document.getElementById("header");
    document.getElementById("header-logo");
    const r = i.querySelectorAll(".modal-button")
      , n = N.matchMedia();
    Wu(),
    n.add(zi, ()=>{
        uA(".wt-project"),
        new eA("portfolio","portfolio__item")
    }
    ),
    Zd = null,
    Zd = new hA,
    Zd.initialAnimation(),
    AM();
    const o = N.timeline({
        defaults: {
            duration: 1.3
        }
    });
    N.set("#header .align-center", {
        opacity: 0
    }),
    o.set(e.container, {
        position: "relative",
        zIndex: "1",
        onComplete: function() {
            r.forEach(a=>{
                if (a.classList.contains("active")) {
                    const l = a.id;
                    Dc(l)
                }
            }
            ),
            Zn(),
            i.classList.remove("restore-theme-light"),
            window.scrollY < window.innerHeight / 2 && N.fromTo("#header .align-center", {
                opacity: 0,
                y: 10
            }, {
                opacity: 1,
                y: 0,
                delay: 1
            }),
            t()
        }
    })
}
MD();
Uw.init({
    prevent: ({href: s})=>s === "#" || s.includes("details") || s.includes("home-self"),
    transitions: [{
        name: "default-transition",
        once() {
            Wu()
        },
        beforeEnter(s) {
            const t = this.async();
            md(s, t)
        },
        enter() {},
        afterEnter(s) {
            const t = this.async();
            xa(s, t)
        }
    }, {
        name: "to-home",
        to: {
            namespace: "home"
        },
        once(s) {
            const t = this.async();
            gy(s, t)
        },
        beforeEnter(s) {
            const t = this.async();
            md(s, t)
        },
        enter() {},
        afterEnter(s) {
            const t = this.async();
            gy(s, t)
        }
    }, {
        name: "from-footer",
        from: {
            namespace: "work"
        },
        to: {
            namespace: "work"
        },
        beforeEnter(s) {
            const t = this.async();
            $D(s, t)
        },
        enter() {},
        afterEnter(s) {
            const t = this.async();
            xa(s, t)
        }
    }, {
        name: "from-project",
        from: {
            namespace: "home"
        },
        to: {
            namespace: "work"
        },
        beforeEnter(s) {
            const t = this.async();
            zD(s, t)
        },
        enter() {},
        afterEnter(s) {
            const t = this.async();
            xa(s, t)
        }
    }, {
        name: "self",
        custom(s) {
            return s.trigger.classList.contains("workModal-item")
        },
        beforeEnter(s) {
            const t = this.async();
            s.next.namespace === "home" ? (window.scrollTo({
                top: 0,
                behavior: "smooth"
            }),
            md(s, t)) : s.next.namespace === "work" && (window.scrollTo({
                top: 0,
                behavior: "smooth"
            }),
            H0(s, t))
        },
        enter() {},
        afterEnter(s) {
            const t = this.async();
            xa(s, t)
        }
    }, {
        name: "from-menu",
        from: {
            custom(s) {
                return s.trigger.classList.contains("workModal-item")
            }
        },
        to: {
            namespace: "work"
        },
        beforeEnter(s) {
            const t = this.async();
            H0(s, t)
        },
        enter() {},
        afterEnter(s) {
            const t = this.async();
            xa(s, t)
        }
    }, {
        name: "land-work",
        to: {
            namespace: "work"
        },
        once(s) {
            Wu(),
            VD(s)
        }
    }]
});
